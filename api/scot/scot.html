<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>scot package &mdash; SCoT</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="SCoT" href="../../index.html" />
    <link rel="up" title="scot" href="modules.html" />
    <link rel="next" title="scot.eegtopo package" href="scot.eegtopo.html" />
    <link rel="prev" title="scot" href="modules.html" /> 
  </head>
  <body role="document">

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scot.eegtopo.html" title="scot.eegtopo package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="scot"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SCoT</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../api_reference.html" >API Reference</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">scot</a> &raquo;</li> 
      </ul>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="scot-package">
<h1>scot package<a class="headerlink" href="#scot-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="scot.eegtopo.html">scot.eegtopo package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.eegpos3d">scot.eegtopo.eegpos3d module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.geo_euclidean">scot.eegtopo.geo_euclidean module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.geo_spherical">scot.eegtopo.geo_spherical module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.projections">scot.eegtopo.projections module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.tools">scot.eegtopo.tools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.topoplot">scot.eegtopo.topoplot module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.warp_layout">scot.eegtopo.warp_layout module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scot.external.html">scot.external package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scot.external.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.external.html#module-scot.external.infomax_">scot.external.infomax_ module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.external.html#module-scot.external">Module contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.external.html#files">Files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-scot.backend_builtin">
<span id="scot-backend-builtin-module"></span><h2>scot.backend_builtin module<a class="headerlink" href="#module-scot.backend_builtin" title="Permalink to this headline">¶</a></h2>
<p>Use internally implemented functions as backend.</p>
<dl class="function">
<dt id="scot.backend_builtin.generate">
<code class="descclassname">scot.backend_builtin.</code><code class="descname">generate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backend_builtin.generate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-scot.backend_sklearn">
<span id="scot-backend-sklearn-module"></span><h2>scot.backend_sklearn module<a class="headerlink" href="#module-scot.backend_sklearn" title="Permalink to this headline">¶</a></h2>
<p>Use scikit-learn routines as backend.</p>
<dl class="function">
<dt id="scot.backend_sklearn.generate">
<code class="descclassname">scot.backend_sklearn.</code><code class="descname">generate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backend_sklearn.generate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-scot.backendmanager">
<span id="scot-backendmanager-module"></span><h2>scot.backendmanager module<a class="headerlink" href="#module-scot.backendmanager" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="scot.backendmanager.BackendManager">
<em class="property">class </em><code class="descclassname">scot.backendmanager.</code><code class="descname">BackendManager</code><a class="headerlink" href="#scot.backendmanager.BackendManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="scot.backendmanager.BackendManager.activate">
<code class="descname">activate</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.activate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="scot.backendmanager.BackendManager.get_backend">
<code class="descname">get_backend</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.get_backend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="scot.backendmanager.BackendManager.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="scot.backendmanager.BackendManager.names">
<code class="descname">names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="scot.backendmanager.BackendManager.register">
<code class="descname">register</code><span class="sig-paren">(</span><em>name</em>, <em>activationfunction</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.register" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-scot.config">
<span id="scot-config-module"></span><h2>scot.config module<a class="headerlink" href="#module-scot.config" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="scot.config.load_configuration">
<code class="descclassname">scot.config.</code><code class="descname">load_configuration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.config.load_configuration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-scot.connectivity">
<span id="scot-connectivity-module"></span><h2>scot.connectivity module<a class="headerlink" href="#module-scot.connectivity" title="Permalink to this headline">¶</a></h2>
<p>Connectivity Analysis</p>
<dl class="class">
<dt id="scot.connectivity.Connectivity">
<em class="property">class </em><code class="descclassname">scot.connectivity.</code><code class="descname">Connectivity</code><span class="sig-paren">(</span><em>b</em>, <em>c=None</em>, <em>nfft=512</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Calculation of connectivity measures</p>
<p>This class calculates various spectral connectivity measures from a vector autoregressive (VAR) model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>b</strong> : ndarray, shape = [n_channels, n_channels*model_order]</p>
<blockquote>
<div><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><span>On the arrangement of VAR model coefficients</span></a> for details about the arrangement of coefficients.</p>
</div></blockquote>
<p><strong>c</strong> : ndarray, shape = [n_channels, n_channels], optional</p>
<blockquote>
<div><p>Covariance matrix of the driving noise process. Identity matrix is used if set to None.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote class="last">
<div><p>Number of frequency bins to calculate. Note that these points cover the range between 0 and half the
sampling rate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Connectivity measures are returned by member functions that take no arguments and return a matrix of
shape [m,m,nfft]. The first dimension is the sink, the second dimension is the source, and the third dimension is
the frequency.</p>
<p>A summary of most supported measures can be found in <a class="reference internal" href="#r1" id="id1">[R1]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> M. Billinger et al, “Single-trial connectivity estimation for classification of motor imagery data”,
<em>J. Neural Eng.</em> 10, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.A" title="scot.connectivity.Connectivity.A"><code class="xref py py-func docutils literal"><span class="pre">A()</span></code></a></td>
<td>Spectral representation of the VAR coefficients</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.H" title="scot.connectivity.Connectivity.H"><code class="xref py py-func docutils literal"><span class="pre">H()</span></code></a></td>
<td>Transfer function that turns the innovation process into the VAR process</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.S" title="scot.connectivity.Connectivity.S"><code class="xref py py-func docutils literal"><span class="pre">S()</span></code></a></td>
<td>Cross spectral density</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.logS" title="scot.connectivity.Connectivity.logS"><code class="xref py py-func docutils literal"><span class="pre">logS()</span></code></a></td>
<td>Logarithm of the cross spectral density (S), for convenience.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.G" title="scot.connectivity.Connectivity.G"><code class="xref py py-func docutils literal"><span class="pre">G()</span></code></a></td>
<td>Inverse cross spectral density</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.logG" title="scot.connectivity.Connectivity.logG"><code class="xref py py-func docutils literal"><span class="pre">logG()</span></code></a></td>
<td>Logarithm of the inverse cross spectral density</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.PHI" title="scot.connectivity.Connectivity.PHI"><code class="xref py py-func docutils literal"><span class="pre">PHI()</span></code></a></td>
<td>Phase angle</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.COH" title="scot.connectivity.Connectivity.COH"><code class="xref py py-func docutils literal"><span class="pre">COH()</span></code></a></td>
<td>Coherence</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.pCOH" title="scot.connectivity.Connectivity.pCOH"><code class="xref py py-func docutils literal"><span class="pre">pCOH()</span></code></a></td>
<td>Partial coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.PDC" title="scot.connectivity.Connectivity.PDC"><code class="xref py py-func docutils literal"><span class="pre">PDC()</span></code></a></td>
<td>Partial directed coherence</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.ffPDC" title="scot.connectivity.Connectivity.ffPDC"><code class="xref py py-func docutils literal"><span class="pre">ffPDC()</span></code></a></td>
<td>Full frequency partial directed coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.PDCF" title="scot.connectivity.Connectivity.PDCF"><code class="xref py py-func docutils literal"><span class="pre">PDCF()</span></code></a></td>
<td>PDC factor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.GPDC" title="scot.connectivity.Connectivity.GPDC"><code class="xref py py-func docutils literal"><span class="pre">GPDC()</span></code></a></td>
<td>Generalized partial directed coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.DTF" title="scot.connectivity.Connectivity.DTF"><code class="xref py py-func docutils literal"><span class="pre">DTF()</span></code></a></td>
<td>Directed transfer function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.ffDTF" title="scot.connectivity.Connectivity.ffDTF"><code class="xref py py-func docutils literal"><span class="pre">ffDTF()</span></code></a></td>
<td>Full frequency directed transfer function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.dDTF" title="scot.connectivity.Connectivity.dDTF"><code class="xref py py-func docutils literal"><span class="pre">dDTF()</span></code></a></td>
<td>Direct directed transfer function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.GDTF" title="scot.connectivity.Connectivity.GDTF"><code class="xref py py-func docutils literal"><span class="pre">GDTF()</span></code></a></td>
<td>Generalized directed transfer function</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.connectivity.Connectivity.A">
<code class="descname">A</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectral VAR coefficients</p>
<div class="math">
\[\mathbf{A}(f) = \mathbf{I} - \sum_{k=1}^{p} \mathbf{a}^{(k)} \mathrm{e}^{-2\pi f}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.COH">
<code class="descname">COH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.COH" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherence</p>
<div class="math">
\[\mathrm{COH}_{ij}(f) = \frac{S_{ij}(f)}{\sqrt{S_{ii}(f) S_{jj}(f)}}\]</div>
<p class="rubric">References</p>
<p>P. L. Nunez, R. Srinivasan, A. F. Westdorp, R. S. Wijesinghe, D. M. Tucker,
R. B. Silverstein, P. J. Cadusch. EEG coherency: I: statistics, reference electrode,
volume conduction, Laplacians, cortical imaging, and interpretation at multiple scales.
Electroenceph. Clin. Neurophysiol. 103(5): 499-515, 1997.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.Cinv">
<code class="descname">Cinv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.Cinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of the noise covariance</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.DTF">
<code class="descname">DTF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.DTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Directed transfer function</p>
<div class="math">
\[\mathrm{DTF}_{ij}(f) = \frac{H_{ij}(f)}{\sqrt{H_{i:}(f) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>M. J. Kaminski, K. J. Blinowska. A new method of the description of the information flow
in the brain structures. Biol. Cybernetics 65(3): 203-210, 1991.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.G">
<code class="descname">G</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.G" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse cross spectral density</p>
<div class="math">
\[\mathbf{G}(f) = \mathbf{A}(f) \mathbf{C}^{-1} \mathbf{A}'(f)\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.GDTF">
<code class="descname">GDTF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.GDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized directed transfer function</p>
<div class="math">
\[\mathrm{GPDC}_{ij}(f) = \frac{\sigma_j |H_{ij}(f)|}
{\sqrt{H_{i:}(f) \mathrm{diag}(\mathbf{C}) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring Connectivity in Linear Multivariate Processes:
Definitions, Interpretation, and Practical Analysis. Comput. Math. Meth. Med. 2012:140513, 2012.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.GPDC">
<code class="descname">GPDC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.GPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized partial directed coherence</p>
<div class="math">
\[\mathrm{GPDC}_{ij}(f) = \frac{|A_{ij}(f)|}
{\sigma_i \sqrt{A_{:j}'(f) \mathrm{diag}(\mathbf{C})^{-1} A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring Connectivity in Linear Multivariate Processes:
Definitions, Interpretation, and Practical Analysis. Comput. Math. Meth. Med. 2012:140513, 2012.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.H">
<code class="descname">H</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.H" title="Permalink to this definition">¶</a></dt>
<dd><p>VAR transfer function</p>
<div class="math">
\[\mathbf{H}(f) = \mathbf{A}(f)^{-1}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.PDC">
<code class="descname">PDC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.PDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial directed coherence</p>
<div class="math">
\[\mathrm{PDC}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{A_{:j}'(f) A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept in neural structure
determination. Biol. Cybernetics 84(6):463-474, 2001.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.PDCF">
<code class="descname">PDCF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.PDCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial directed coherence factor</p>
<div class="math">
\[\mathrm{PDCF}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{A_{:j}'(f) \mathbf{C}^{-1} A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept in neural structure
determination. Biol. Cybernetics 84(6):463-474, 2001.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.PHI">
<code class="descname">PHI</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.PHI" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase angle</p>
<p>Returns the phase angle of complex <a class="reference internal" href="#scot.connectivity.Connectivity.S" title="scot.connectivity.Connectivity.S"><code class="xref py py-func docutils literal"><span class="pre">S()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.S">
<code class="descname">S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.S" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross spectral density</p>
<div class="math">
\[\mathbf{S}(f) = \mathbf{H}(f) \mathbf{C} \mathbf{H}'(f)\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.absS">
<code class="descname">absS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.absS" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute cross spectral density</p>
<div class="math">
\[\mathrm{absS}(f) = | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.dDTF">
<code class="descname">dDTF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.dDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8221; Direct&#8221; directed transfer function</p>
<div class="math">
\[\mathrm{dDTF}_{ij}(f) = |\mathrm{pCOH}_{ij}(f)| \mathrm{ffDTF}_{ij}(f)\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki. Determination of
information flow direction among brain structures by a modified directed transfer
function (dDTF) method. J. Neurosci. Meth. 125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.ffDTF">
<code class="descname">ffDTF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.ffDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Full frequency directed transfer function</p>
<div class="math">
\[\mathrm{ffDTF}_{ij}(f) = \frac{H_{ij}(f)}{\sqrt{\sum_f H_{i:}(f) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki. Determination of
information flow direction among brain structures by a modified directed transfer
function (dDTF) method. J. Neurosci. Meth. 125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.ffPDC">
<code class="descname">ffPDC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.ffPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Full frequency partial directed coherence</p>
<div class="math">
\[\mathrm{ffPDC}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{\sum_f A_{:j}'(f) A_{:j}(f)}}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.logG">
<code class="descname">logG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.logG" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithmic inverse cross spectral density</p>
<div class="math">
\[\mathrm{logG}(f) = \log | \mathbf{G}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.logS">
<code class="descname">logS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.logS" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithmic cross spectral density</p>
<div class="math">
\[\mathrm{logS}(f) = \log | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.pCOH">
<code class="descname">pCOH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.pCOH" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial coherence</p>
<div class="math">
\[\mathrm{pCOH}_{ij}(f) = \frac{G_{ij}(f)}{\sqrt{G_{ii}(f) G_{jj}(f)}}\]</div>
<p class="rubric">References</p>
<p>P. J. Franaszczuk, K. J. Blinowska, M. Kowalczyk. The application of parametric multichannel
spectral estimates in the study of electrical brain activity. Biol. Cybernetics 51(4): 239-247, 1985.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.sPDC">
<code class="descname">sPDC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.sPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Squared partial directed coherence.</p>
<div class="math">
\[\mathrm{sPDC}_{ij}(f) = \frac{|A_{ij}(f)|^2}{\mathbf{1}^T | A_{:j}(f) |^2}\]</div>
<p class="rubric">References</p>
<p>L. Astolfi, F. Cincotti, D. Mattia, M. G. Marciani, L. Baccala,
F. D. Fallani, S. Salinari, M. Ursino, M. Zavaglia, F. Babiloni. Partial
directed coherence: a new concept in neural structure determination. IEEE
Trans. Biomed. Eng. 53(9):1802-1812, 2006.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="scot.connectivity.connectivity">
<code class="descclassname">scot.connectivity.</code><code class="descname">connectivity</code><span class="sig-paren">(</span><em>measure_names</em>, <em>b</em>, <em>c=None</em>, <em>nfft=512</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate connectivity measures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <a class="reference internal" href="#scot.connectivity.Connectivity" title="scot.connectivity.Connectivity"><code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</div></blockquote>
<p><strong>b</strong> : ndarray, shape = [n_channels, n_channels*model_order]</p>
<blockquote>
<div><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><span>On the arrangement of VAR model coefficients</span></a> for details about the arrangement of coefficients.</p>
</div></blockquote>
<p><strong>c</strong> : ndarray, shape = [n_channels, n_channels], optional</p>
<blockquote>
<div><p>Covariance matrix of the driving noise process. Identity matrix is used if set to None.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins to calculate. Note that these points cover the range between 0 and half the
sampling rate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : ndarray, shape = [n_channels, n_channels, <cite>nfft</cite>]</p>
<blockquote class="last">
<div><p>An ndarray of shape [m, m, nfft] is returned if measures is a string. If measures is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are ndarrays
of shape [m, m, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>When using this function it is more efficient to get several measures at once than calling the function multiple times.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">([</span><span class="s1">&#39;DTF&#39;</span><span class="p">,</span> <span class="s1">&#39;PDC&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-scot.connectivity_statistics">
<span id="scot-connectivity-statistics-module"></span><h2>scot.connectivity_statistics module<a class="headerlink" href="#module-scot.connectivity_statistics" title="Permalink to this headline">¶</a></h2>
<p>Routines for statistical evaluation of connectivity.</p>
<dl class="function">
<dt id="scot.connectivity_statistics.bootstrap_connectivity">
<code class="descclassname">scot.connectivity_statistics.</code><code class="descname">bootstrap_connectivity</code><span class="sig-paren">(</span><em>measures</em>, <em>data</em>, <em>var</em>, <em>nfft=512</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>n_jobs=1</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.bootstrap_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Bootstrap estimates of connectivity.</p>
<p>To obtain a bootstrap estimate trials are sampled randomly with replacement
from the data set.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>var</cite> will be modified by the function. Treat as</p>
</div>
<p>undefined after the function returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See
<code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>data</strong> : array, shape (n_trials, n_channels, n_samples)</p>
<blockquote>
<div><p>Time series data (multiple trials)</p>
</div></blockquote>
<p><strong>var</strong> : VARBase-like object</p>
<blockquote>
<div><p>Instance of a VAR model.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the
same number of trials as present in the data.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | None</p>
<blockquote>
<div><p>number of jobs to run in parallel. See <cite>joblib.Parallel</cite> for details.</p>
</div></blockquote>
<p><strong>verbose</strong> : int</p>
<blockquote>
<div><p>verbosity level passed to joblib.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each bootstrap estimate. If
<cite>measure_names</cite> is a list of strings a dictionary is returned, where
each key is the name of the measure, and the corresponding values are
ndarrays of shape [<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.convert_output_">
<code class="descclassname">scot.connectivity_statistics.</code><code class="descname">convert_output_</code><span class="sig-paren">(</span><em>output</em>, <em>measures</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.convert_output_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.jackknife_connectivity">
<code class="descclassname">scot.connectivity_statistics.</code><code class="descname">jackknife_connectivity</code><span class="sig-paren">(</span><em>measure_names</em>, <em>data</em>, <em>var</em>, <em>nfft=512</em>, <em>leaveout=1</em>, <em>n_jobs=1</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.jackknife_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Jackknife estimates of connectivity.</p>
<p>For each Jackknife estimate a block of trials is left out. This is repeated
until each trial was left out exactly once. The number of estimates depends
on the number of trials and the value of <cite>leaveout</cite>. It is calculated by
repeats = <cite>n_trials</cite> // <cite>leaveout</cite>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>var</cite> will be modified by the function. Treat as</p>
</div>
<p>undefined after the function returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See
<code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>data</strong> : array, shape (n_trials, n_channels, n_samples)</p>
<blockquote>
<div><p>Time series data (multiple trials)</p>
</div></blockquote>
<p><strong>var</strong> : VARBase-like object</p>
<blockquote>
<div><p>Instance of a VAR model.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins to calculate. Note that these points cover the
range between 0 and half the
sampling rate.</p>
</div></blockquote>
<p><strong>leaveout</strong> : int, optional</p>
<blockquote>
<div><p>Number of trials to leave out in each estimate.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | None</p>
<blockquote>
<div><p>number of jobs to run in parallel. See <cite>joblib.Parallel</cite> for details.</p>
</div></blockquote>
<p><strong>verbose</strong> : int</p>
<blockquote>
<div><p>verbosity level passed to joblib.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each surrogate. If
<cite>measure_names</cite> is a list of strings a dictionary is returned,
where each key is the name of the measure, and the corresponding
values are ndarrays of shape
[<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.significance_fdr">
<code class="descclassname">scot.connectivity_statistics.</code><code class="descname">significance_fdr</code><span class="sig-paren">(</span><em>p</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.significance_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate significance by controlling for the false discovery rate.</p>
<p>This function determines which of the <em>p</em>-values in <cite>p</cite> can be considered
significant. Correction for multiple comparisons is performed by
controlling the false discovery rate (FDR). The FDR is the maximum fraction
of <em>p</em>-values that are wrongly considered significant <a class="reference internal" href="#r2" id="id3">[R2]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> : ndarray, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p><em>p</em>-values</p>
</div></blockquote>
<p><strong>alpha</strong> : float</p>
<blockquote>
<div><p>Maximum false discovery rate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong> : ndarray, dtype=bool, shape = [n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Significance of each <em>p</em>-value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Y. Benjamini, Y. Hochberg, &#8220;Controlling the false discovery rate: a
practical and powerful approach to multiple testing&#8221;, Journal of the
Royal Statistical Society, Series B 57(1), pp 289-300, 1995</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.surrogate_connectivity">
<code class="descclassname">scot.connectivity_statistics.</code><code class="descname">surrogate_connectivity</code><span class="sig-paren">(</span><em>measure_names</em>, <em>data</em>, <em>var</em>, <em>nfft=512</em>, <em>repeats=100</em>, <em>n_jobs=1</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.surrogate_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates surrogate connectivity for a multivariate time series by
phase randomization <a class="reference internal" href="#r3" id="id5">[R3]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>var</cite> will be modified by the function. Treat as</p>
</div>
<p>undefined after the function returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See
<code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>data</strong> : array, shape (n_trials, n_channels, n_samples) or (n_channels, n_samples)</p>
<blockquote>
<div><p>Time series data (2D or 3D for multiple trials)</p>
</div></blockquote>
<p><strong>var</strong> : VARBase-like object</p>
<blockquote>
<div><p>Instance of a VAR model.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins to calculate. Note that these points cover the
range between 0 and half the
sampling rate.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | None</p>
<blockquote>
<div><p>number of jobs to run in parallel. See <cite>joblib.Parallel</cite> for details.</p>
</div></blockquote>
<p><strong>verbose</strong> : int</p>
<blockquote>
<div><p>verbosity level passed to joblib.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Values of the connectivity measure for each surrogate. If
<cite>measure_names</cite> is a list of strings a dictionary
is returned, where each key is the name of the measure, and the
corresponding values are ndarrays of shape
[<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
<table class="last docutils citation" frame="void" id="r3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R3]</a></td><td><ol class="first upperalpha simple" start="10">
<li>Theiler et al. &#8220;Testing for nonlinearity in time series: the</li>
</ol>
<p class="last">method of surrogate data&#8221;, Physica D, vol 58, pp. 77-94, 1992</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.test_bootstrap_difference">
<code class="descclassname">scot.connectivity_statistics.</code><code class="descname">test_bootstrap_difference</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.test_bootstrap_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Test mean difference between two bootstrap estimates.</p>
<p>This function calculates the probability <cite>p</cite> of observing a more extreme
mean difference between <cite>a</cite> and <cite>b</cite> under the null hypothesis that <cite>a</cite> and
<cite>b</cite> come from the same distribution.</p>
<p>If p is smaller than e.g. 0.05 we can reject the null hypothesis at an
alpha-level of 0.05 and conclude that <cite>a</cite> and <cite>b</cite> are likely to come from
different distributions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><em>p</em>-values are calculated along the first dimension. Thus,
n_channels * n_channels * nfft individual <em>p</em>-values are
obtained. To determine if a difference is significant it is
important to correct for multiple testing.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a, b</strong> : ndarray, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Two bootstrap estimates to compare. The number of repetitions (first
dimension) does not have be equal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : ndarray, shape = [n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p><em>p</em>-values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.significance_fdr" title="scot.connectivity_statistics.significance_fdr"><code class="xref py py-func docutils literal"><span class="pre">significance_fdr()</span></code></a></dt>
<dd>Correct for multiple testing by controlling the</dd>
</dl>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">false</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The function estimates the distribution of <cite>b[j]</cite> - <cite>a[i]</cite> by calculating
the difference for each combination of <cite>i</cite> and <cite>j</cite>. The total number of
difference samples available is therefore a.shape[0] * b.shape[0]. The
<em>p</em>-value is calculated as the smallest percentile of that distribution
that does not contain 0.</p>
</dd></dl>

</div>
<div class="section" id="module-scot.csp">
<span id="scot-csp-module"></span><h2>scot.csp module<a class="headerlink" href="#module-scot.csp" title="Permalink to this headline">¶</a></h2>
<p>common spatial patterns (CSP) implementation</p>
<dl class="function">
<dt id="scot.csp.csp">
<code class="descclassname">scot.csp.</code><code class="descname">csp</code><span class="sig-paren">(</span><em>x</em>, <em>cl</em>, <em>numcomp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.csp.csp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate common spatial patterns (CSP)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys</p>
<blockquote>
<div><p>Class labels associated with each trial. Currently only two classes are supported.</p>
</div></blockquote>
<p><strong>numcomp</strong> : {int}, optional</p>
<blockquote>
<div><p>Number of patterns to keep after applying the CSP. If <cite>numcomp</cite> is
greater than n_channels or None, all n_channels patterns are returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array, shape = [n_channels, n_components]</p>
<blockquote>
<div><p>CSP weight matrix</p>
</div></blockquote>
<p><strong>v</strong> : array, shape = [n_components, n_channels]</p>
<blockquote class="last">
<div><p>CSP projection matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.datatools">
<span id="scot-datatools-module"></span><h2>scot.datatools module<a class="headerlink" href="#module-scot.datatools" title="Permalink to this headline">¶</a></h2>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>Tools for basic data manipulation.</p>
<dl class="function">
<dt id="scot.datatools.atleast_3d">
<code class="descclassname">scot.datatools.</code><code class="descname">atleast_3d</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.atleast_3d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.datatools.cat_trials">
<code class="descclassname">scot.datatools.</code><code class="descname">cat_trials</code><span class="sig-paren">(</span><em>x3d</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.cat_trials" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate trials along time axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x3d</strong> : array, shape (t, m, n)</p>
<blockquote>
<div><p>Segmented input data with t trials, m signals, and n samples.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>x2d</strong> : array, shape (m, t * n)</p>
<blockquote class="last">
<div><p>Trials are concatenated along the second axis.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.datatools.cut_segments" title="scot.datatools.cut_segments"><code class="xref py py-obj docutils literal"><span class="pre">cut_segments</span></code></a></dt>
<dd>Cut segments from continuous data.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cat_trials</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 900)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scot.datatools.cut_segments">
<code class="descclassname">scot.datatools.</code><code class="descname">cut_segments</code><span class="sig-paren">(</span><em>x2d</em>, <em>tr</em>, <em>start</em>, <em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.cut_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Cut continuous signal into segments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x2d</strong> : array, shape (m, n)</p>
<blockquote>
<div><p>Input data with m signals and n samples.</p>
</div></blockquote>
<p><strong>tr</strong> : list of int</p>
<blockquote>
<div><p>Trigger positions.</p>
</div></blockquote>
<p><strong>start</strong> : int</p>
<blockquote>
<div><p>Window start (offset relative to trigger).</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote>
<div><p>Window end (offset relative to trigger).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>x3d</strong> : array, shape (len(tr), m, stop-start)</p>
<blockquote class="last">
<div><p>Segments cut from data. Individual segments are stacked along the first
dimension.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.datatools.cat_trials" title="scot.datatools.cat_trials"><code class="xref py py-obj docutils literal"><span class="pre">cat_trials</span></code></a></dt>
<dd>Concatenate segments.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># 5 channels, 1000 samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">750</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">250</span><span class="p">]</span>  <span class="c1"># three segments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x3d</span> <span class="o">=</span> <span class="n">cut_segments</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># each segment is 50 samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x3d</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 5, 50)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scot.datatools.dot_special">
<code class="descclassname">scot.datatools.</code><code class="descname">dot_special</code><span class="sig-paren">(</span><em>x2d</em>, <em>x3d</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.dot_special" title="Permalink to this definition">¶</a></dt>
<dd><p>Segment-wise dot product.</p>
<p>This function calculates the dot product of x2d with each trial of x3d.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x2d</strong> : array, shape (p, m)</p>
<blockquote>
<div><p>Input argument.</p>
</div></blockquote>
<p><strong>x3d</strong> : array, shape (t, m, n)</p>
<blockquote>
<div><p>Segmented input data with t trials, m signals, and n samples. The dot
product with x2d is calculated for each trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : array, shape (t, p, n)</p>
<blockquote class="last">
<div><p>Dot product of x2d with each trial of x3d.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">dot_special</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 7, 150)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scot.datatools.randomize_phase">
<code class="descclassname">scot.datatools.</code><code class="descname">randomize_phase</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.randomize_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase randomization.</p>
<p>This function randomizes the spectral phase of the input data along the
first dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array</p>
<blockquote>
<div><p>Input array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : array</p>
<blockquote class="last">
<div><p>Array of same shape as data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm randomizes the phase component of the input&#8217;s complex Fourier
transform.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scot.datatools</span> <span class="kn">import</span> <span class="n">randomize_phase</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">randomize_phase</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase randomization of sine wave and rectangular function&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../../api/scot/scot-1.py">Source code</a>, <a class="reference external" href="../../api/scot/scot-1.png">png</a>, <a class="reference external" href="../../api/scot/scot-1.hires.png">hires.png</a>, <a class="reference external" href="../../api/scot/scot-1.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../../_images/scot-1.png" src="../../_images/scot-1.png" />
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-scot.matfiles">
<span id="scot-matfiles-module"></span><h2>scot.matfiles module<a class="headerlink" href="#module-scot.matfiles" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id6">
<h3>Summary<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Routines for loading and saving Matlab&#8217;s .mat files.</p>
<dl class="function">
<dt id="scot.matfiles.loadmat">
<code class="descclassname">scot.matfiles.</code><code class="descname">loadmat</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.matfiles.loadmat" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should be called instead of direct spio.loadmat
as it cures the problem of not properly recovering python dictionaries
from mat files. It calls the function check keys to cure all entries
which are still mat-objects</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-scot.ooapi">
<span id="scot-ooapi-module"></span><h2>scot.ooapi module<a class="headerlink" href="#module-scot.ooapi" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id7">
<h3>Summary<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Object oriented API to SCoT.</p>
</div>
<div class="section" id="extended-summary">
<h3>Extended Summary<a class="headerlink" href="#extended-summary" title="Permalink to this headline">¶</a></h3>
<p>The object oriented API provides a the <cite>Workspace</cite> class, which provides high-level functionality and serves as an
example usage of the low-level API.</p>
<dl class="class">
<dt id="scot.ooapi.Workspace">
<em class="property">class </em><code class="descclassname">scot.ooapi.</code><code class="descname">Workspace</code><span class="sig-paren">(</span><em>var</em>, <em>locations=None</em>, <em>reducedim=0.99</em>, <em>nfft=512</em>, <em>fs=2</em>, <em>backend=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>SCoT Workspace</p>
<p>This class provides high-level functionality for source identification, connectivity estimation, and visualization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>var</strong> : {<code class="xref py py-class docutils literal"><span class="pre">VARBase</span></code>-like object, dict}</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object that is used for model fitting.
This can also be a dictionary that is passed as <cite>**kwargs</cite> to backend[&#8216;var&#8217;]() in order to
construct a new VAR model object.</p>
</div></blockquote>
<p><strong>locations</strong> : array_like, optional</p>
<blockquote>
<div><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int, float, &#8216;no_pca&#8217;}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer number of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to &#8216;no_pca&#8217; the PCA step is skipped.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins for connectivity estimation.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote class="last">
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>unmixing_</cite></td>
<td>(array) Estimated unmixing matrix.</td>
</tr>
<tr class="row-even"><td><cite>mixing_</cite></td>
<td>(array) Estimated mixing matrix.</td>
</tr>
<tr class="row-odd"><td><cite>plot_diagonal</cite></td>
<td>(str) Configures what is plotted in the diagonal subplots. <strong>&#8216;topo&#8217;</strong> (default) plots topoplots on the diagonal, <strong>&#8216;S&#8217;</strong> plots the spectral density of each component, and <strong>&#8216;fill&#8217;</strong> plots connectivity on the diagonal.</td>
</tr>
<tr class="row-even"><td><cite>plot_outside_topo</cite></td>
<td>(bool) Whether to place topoplots in the left column and top row.</td>
</tr>
<tr class="row-odd"><td><cite>plot_f_range</cite></td>
<td>((int, int)) Lower and upper frequency limits for plotting. Defaults to [0, fs/2].</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.ooapi.Workspace.compare_conditions">
<code class="descname">compare_conditions</code><span class="sig-paren">(</span><em>labels1</em>, <em>labels2</em>, <em>measure_name</em>, <em>alpha=0.01</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.compare_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for significant difference in connectivity of two sets of class labels.</p>
<p>Connectivity estimates are obtained by bootstrapping. Correction for multiple testing is performed by
controlling the false discovery rate (FDR).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels1, labels2</strong> : list of class labels</p>
<blockquote>
<div><p>The two sets of class labels to compare. Each set may contain more than one label.</p>
</div></blockquote>
<p><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>alpha</strong> : float, optional</p>
<blockquote>
<div><p>Maximum allowed FDR. The ratio of falsely detected significant differences is guaranteed to be less than
<cite>alpha</cite>.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : array, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Uncorrected p-values.</p>
</div></blockquote>
<p><strong>s</strong> : array, dtype=bool, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>FDR corrected significance. True means the difference is significant in this location.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.do_cspvarica">
<code class="descname">do_cspvarica</code><span class="sig-paren">(</span><em>varfit='ensemble'</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.do_cspvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform CSPVARICA</p>
<p>Perform CSPVARICA source decomposition and VAR model fitting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a different model for each class, and
&#8216;trial&#8217; fits a different model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <code class="xref py py-func docutils literal"><span class="pre">cspvarica()</span></code> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal"><span class="pre">cspvarica()</span></code></dt>
<dd>CSPVARICA implementation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.do_ica">
<code class="descname">do_ica</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.do_ica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform ICA</p>
<p>Perform plain ICA source decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <code class="xref py py-func docutils literal"><span class="pre">plainica()</span></code> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.do_mvarica">
<code class="descname">do_mvarica</code><span class="sig-paren">(</span><em>varfit='ensemble'</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.do_mvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform MVARICA</p>
<p>Perform MVARICA source decomposition and VAR model fitting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a different model for each class, and
&#8216;trial&#8217; fits a different model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <code class="xref py py-func docutils literal"><span class="pre">mvarica()</span></code> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal"><span class="pre">mvarica()</span></code></dt>
<dd>MVARICA implementation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.fit_var">
<code class="descname">fit_var</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.fit_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a var model to the source activations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain source activations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.get_bootstrap_connectivity">
<code class="descname">get_bootstrap_connectivity</code><span class="sig-paren">(</span><em>measure_names</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.get_bootstrap_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bootstrap estimates of spectral connectivity measures.</p>
<p>Bootstrapping is performed on trial level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each bootstrap estimate. If <cite>measure_names</cite> is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are
ndarrays of shape [<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.bootstrap_connectivity" title="scot.connectivity_statistics.bootstrap_connectivity"><code class="xref py py-func docutils literal"><span class="pre">scot.connectivity_statistics.bootstrap_connectivity()</span></code></a></dt>
<dd>Calculates bootstrap connectivity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.get_connectivity">
<code class="descname">get_connectivity</code><span class="sig-paren">(</span><em>measure_name</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.get_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Values of the connectivity measure.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object</p>
<blockquote>
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain a fitted VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.get_surrogate_connectivity">
<code class="descname">get_surrogate_connectivity</code><span class="sig-paren">(</span><em>measure_name</em>, <em>repeats=100</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.get_surrogate_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each surrogate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.surrogate_connectivity" title="scot.connectivity_statistics.surrogate_connectivity"><code class="xref py py-func docutils literal"><span class="pre">scot.connectivity_statistics.surrogate_connectivity()</span></code></a></dt>
<dd>Calculates surrogate connectivity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.get_tf_connectivity">
<code class="descname">get_tf_connectivity</code><span class="sig-paren">(</span><em>measure_name</em>, <em>winlen</em>, <em>winstep</em>, <em>plot=False</em>, <em>baseline=None</em>, <em>crange='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.get_tf_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate estimate of time-varying connectivity.</p>
<p>Connectivity is estimated in a sliding window approach on the current data set. The window is stepped
<cite>n_steps</cite> = (<cite>n_samples</cite> - <cite>winlen</cite>) // <cite>winstep</cite> times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>winlen</strong> : int</p>
<blockquote>
<div><p>Length of the sliding window (in samples).</p>
</div></blockquote>
<p><strong>winstep</strong> : int</p>
<blockquote>
<div><p>Step size for sliding window (in samples).</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
<p><strong>baseline</strong> : [int, int] or None</p>
<blockquote>
<div><p>Start and end of the baseline period in samples. The baseline is subtracted from the connectivity. It is
computed as the average of all windows that contain start or end, or fall between start and end.
If set to None no baseline is subtracted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array, shape = [n_channels, n_channels, nfft, n_steps]</p>
<blockquote>
<div><p>Values of the connectivity measure.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain a fitted VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.optimize_var">
<code class="descname">optimize_var</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.optimize_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the var model&#8217;s hyperparameters (such as regularization).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain source activations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.plot_connectivity_surrogate">
<code class="descname">plot_connectivity_surrogate</code><span class="sig-paren">(</span><em>measure_name</em>, <em>repeats=100</em>, <em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.plot_connectivity_surrogate" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
<p><strong>fig</strong> : {None, Figure object}, optional</p>
<blockquote>
<div><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.plot_connectivity_topos">
<code class="descname">plot_connectivity_topos</code><span class="sig-paren">(</span><em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.plot_connectivity_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot scalp projections of the sources.</p>
<p>This function only plots the topos. Use in combination with connectivity plotting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fig</strong> : {None, Figure object}, optional</p>
<blockquote>
<div><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.plot_source_topos">
<code class="descname">plot_source_topos</code><span class="sig-paren">(</span><em>common_scale=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.plot_source_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topography of the Source decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>common_scale</strong> : float, optional</p>
<blockquote class="last">
<div><p>If set to None, each topoplot&#8217;s color axis is scaled individually. Otherwise specifies the percentile
(1-99) of values in all plot. This value is taken as the maximum color scale.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="scot.ooapi.Workspace.plotting">
<code class="descname">plotting</code><a class="headerlink" href="#scot.ooapi.Workspace.plotting" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.remove_sources">
<code class="descname">remove_sources</code><span class="sig-paren">(</span><em>sources</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.remove_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sources from the decomposition.</p>
<p>This function removes sources from the decomposition. Doing so invalidates currently fitted VAR models and
connectivity estimates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sources</strong> : {slice, int, array of ints}</p>
<blockquote>
<div><p>Indices of components to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain a source decomposition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em>, <em>cl=None</em>, <em>time_offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign data to the workspace.</p>
<p>This function assigns a new data set to the workspace. Doing so invalidates currently fitted VAR models,
connectivity estimates, and activations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys</p>
<blockquote>
<div><p>Class labels associated with each trial.</p>
</div></blockquote>
<p><strong>time_offset</strong> : float, optional</p>
<blockquote class="last">
<div><p>Trial starting time; used for labelling the x-axis of time/frequency plots.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.set_locations">
<code class="descname">set_locations</code><span class="sig-paren">(</span><em>locations</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.set_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sensor locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>locations</strong> : array_like</p>
<blockquote class="last">
<div><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.set_premixing">
<code class="descname">set_premixing</code><span class="sig-paren">(</span><em>premixing</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.set_premixing" title="Permalink to this definition">¶</a></dt>
<dd><p>Set premixing matrix.</p>
<p>The premixing matrix maps data to physical channels. If the data is actual channel data,
the premixing matrix can be set to identity. Use this functionality if the data was pre-
transformed with e.g. PCA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>premixing</strong> : array_like, shape = [n_signals, n_channels]</p>
<blockquote class="last">
<div><p>Matrix that maps data signals to physical channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.set_used_labels">
<code class="descname">set_used_labels</code><span class="sig-paren">(</span><em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.set_used_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify which trials to use in subsequent analysis steps.</p>
<p>This function masks trials based on their class labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : list of class labels</p>
<blockquote class="last">
<div><p>Marks all trials that have a label that is in the <cite>labels</cite> list for further processing.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.show_plots">
<code class="descname">show_plots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.show_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Show current plots.</p>
<p>This is only a convenience wrapper around <code class="xref py py-func docutils literal"><span class="pre">matplotlib.pyplot.show_plots()</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-scot.parallel">
<span id="scot-parallel-module"></span><h2>scot.parallel module<a class="headerlink" href="#module-scot.parallel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="scot.parallel.parallel_loop">
<code class="descclassname">scot.parallel.</code><code class="descname">parallel_loop</code><span class="sig-paren">(</span><em>func</em>, <em>n_jobs=1</em>, <em>verbose=1</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.parallel.parallel_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>run loops in parallel, if joblib is available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : function</p>
<blockquote>
<div><p>function to be executed in parallel</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>number of jobs</p>
</div></blockquote>
<p><strong>verbose</strong> : int</p>
<blockquote class="last">
<div><p>verbosity level</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.pca">
<span id="scot-pca-module"></span><h2>scot.pca module<a class="headerlink" href="#module-scot.pca" title="Permalink to this headline">¶</a></h2>
<p>principal component analysis (PCA) implementation</p>
<dl class="function">
<dt id="scot.pca.pca">
<code class="descclassname">scot.pca.</code><code class="descname">pca</code><span class="sig-paren">(</span><em>x</em>, <em>subtract_mean=False</em>, <em>normalize=False</em>, <em>sort_components=True</em>, <em>reducedim=None</em>, <em>algorithm=&lt;function pca_eig&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.pca.pca" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate principal component analysis (PCA)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>subtract_mean</strong> : bool, optional</p>
<blockquote>
<div><p>Subtract sample mean from x.</p>
</div></blockquote>
<p><strong>normalize</strong> : bool, optional</p>
<blockquote>
<div><p>Normalize variances to 1 before applying PCA.</p>
</div></blockquote>
<p><strong>sort_components</strong> : bool, optional</p>
<blockquote>
<div><p>Sort principal components in order of decreasing eigenvalues.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {float, int}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer numer of 1 or greater is interpreted as the number of components to keep after applying the PCA.</p>
</div></blockquote>
<p><strong>algorithm</strong> : func, optional</p>
<blockquote>
<div><p>Specify function to use for eigenvalue decomposition (<a class="reference internal" href="#scot.pca.pca_eig" title="scot.pca.pca_eig"><code class="xref py py-func docutils literal"><span class="pre">pca_eig()</span></code></a> or <a class="reference internal" href="#scot.pca.pca_svd" title="scot.pca.pca_svd"><code class="xref py py-func docutils literal"><span class="pre">pca_svd()</span></code></a>)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array, shape = [n_channels, n_components]</p>
<blockquote>
<div><p>PCA transformation matrix</p>
</div></blockquote>
<p><strong>v</strong> : array, shape = [n_components, n_channels]</p>
<blockquote class="last">
<div><p>PCA backtransformation matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.pca.pca_eig">
<code class="descclassname">scot.pca.</code><code class="descname">pca_eig</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.pca.pca_eig" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate PCA using Eigenvalue decomposition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape = [n_channels, n_samples]</p>
<blockquote>
<div><p>Two dimensional data array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array</p>
<blockquote>
<div><p>Eigenvectors</p>
</div></blockquote>
<p><strong>s</strong> : array</p>
<blockquote class="last">
<div><p>Eigenvalues</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.pca.pca_svd">
<code class="descclassname">scot.pca.</code><code class="descname">pca_svd</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.pca.pca_svd" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate PCA using SVD</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape = [n_channels, n_samples]</p>
<blockquote>
<div><p>Two dimensional data array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array</p>
<blockquote>
<div><p>Eigenvectors</p>
</div></blockquote>
<p><strong>s</strong> : array</p>
<blockquote class="last">
<div><p>Eigenvalues</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.plainica">
<span id="scot-plainica-module"></span><h2>scot.plainica module<a class="headerlink" href="#module-scot.plainica" title="Permalink to this headline">¶</a></h2>
<p>Source decomposition with ICA.</p>
<dl class="class">
<dt id="scot.plainica.ResultICA">
<em class="property">class </em><code class="descclassname">scot.plainica.</code><code class="descname">ResultICA</code><span class="sig-paren">(</span><em>mx</em>, <em>ux</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plainica.ResultICA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Result of <a class="reference internal" href="#scot.plainica.plainica" title="scot.plainica.plainica"><code class="xref py py-func docutils literal"><span class="pre">plainica()</span></code></a></p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>mixing</cite></td>
<td>(array) estimate of the mixing matrix</td>
</tr>
<tr class="row-even"><td><cite>unmixing</cite></td>
<td>(array) estimate of the unmixing matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plainica.plainica">
<code class="descclassname">scot.plainica.</code><code class="descname">plainica</code><span class="sig-paren">(</span><em>x</em>, <em>reducedim=0.99</em>, <em>backend=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plainica.plainica" title="Permalink to this definition">¶</a></dt>
<dd><p>Source decomposition with ICA.</p>
<p>Apply ICA to the data x, with optional PCA dimensionality reduction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array, shape (n_trials, n_channels, n_samples) or (n_channels, n_samples)</p>
<blockquote>
<div><p>data set</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int, float, &#8216;no_pca&#8217;}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer numer of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to &#8216;no_pca&#8217; the PCA step is skipped.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote>
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : ResultICA</p>
<blockquote class="last">
<div><p>Source decomposition</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.plotting">
<span id="scot-plotting-module"></span><h2>scot.plotting module<a class="headerlink" href="#module-scot.plotting" title="Permalink to this headline">¶</a></h2>
<p>Graphical output with matplotlib.</p>
<p>This module attempts to import matplotlib for plotting functionality.
If matplotlib is not available no error is raised, but plotting functions will not be available.</p>
<dl class="function">
<dt id="scot.plotting.MaxNLocator">
<code class="descclassname">scot.plotting.</code><code class="descname">MaxNLocator</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.MaxNLocator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.plotting.current_axis">
<code class="descclassname">scot.plotting.</code><code class="descname">current_axis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.current_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.plotting.new_figure">
<code class="descclassname">scot.plotting.</code><code class="descname">new_figure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.new_figure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_circular">
<code class="descclassname">scot.plotting.</code><code class="descname">plot_circular</code><span class="sig-paren">(</span><em>widths</em>, <em>colors</em>, <em>curviness=0.2</em>, <em>mask=True</em>, <em>topo=None</em>, <em>topomaps=None</em>, <em>axes=None</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_circular" title="Permalink to this definition">¶</a></dt>
<dd><p>Circluar connectivity plot.</p>
<p>Topos are arranged in a circle, with arrows indicating connectivity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>widths</strong> : float or array, shape (n_channels, n_channels)</p>
<blockquote>
<div><p>Width of each arrow. Can be a scalar to assign the same width to all arrows.</p>
</div></blockquote>
<p><strong>colors</strong> : array, shape (n_channels, n_channels, 3) or (3)</p>
<blockquote>
<div><p>RGB color values for each arrow or one RGB color value for all arrows.</p>
</div></blockquote>
<p><strong>curviness</strong> : float, optional</p>
<blockquote>
<div><p>Factor that determines how much arrows tend to deviate from a straight line.</p>
</div></blockquote>
<p><strong>mask</strong> : array, dtype = bool, shape (n_channels, n_channels)</p>
<blockquote>
<div><p>Enable or disable individual arrows</p>
</div></blockquote>
<p><strong>topo</strong> : <code class="xref py py-class docutils literal"><span class="pre">Topoplot</span></code></p>
<blockquote>
<div><p>This object draws the topo plot</p>
</div></blockquote>
<p><strong>topomaps</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected map</p>
</div></blockquote>
<p><strong>axes</strong> : axis, optional</p>
<blockquote>
<div><p>Axis to draw into. A new figure is created by default.</p>
</div></blockquote>
<p><strong>order</strong> : list of int</p>
<blockquote>
<div><p>Rearrange channels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>axes</strong> : Axes object</p>
<blockquote class="last">
<div><p>The axes into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_connectivity_significance">
<code class="descclassname">scot.plotting.</code><code class="descname">plot_connectivity_significance</code><span class="sig-paren">(</span><em>s</em>, <em>fs=2</em>, <em>freq_range=(-inf</em>, <em>inf)</em>, <em>diagonal=0</em>, <em>border=False</em>, <em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_connectivity_significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot significance.</p>
<p>Significance is drawn as a background image where dark vertical stripes indicate freuquencies where a evaluates to
True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array, shape (n_channels, n_channels, n_fft), dtype bool</p>
<blockquote>
<div><p>Significance</p>
</div></blockquote>
<p><strong>fs</strong> : float</p>
<blockquote>
<div><p>Sampling frequency</p>
</div></blockquote>
<p><strong>freq_range</strong> : (float, float)</p>
<blockquote>
<div><p>Frequency range to plot</p>
</div></blockquote>
<p><strong>diagonal</strong> : {-1, 0, 1}</p>
<blockquote>
<div><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</div></blockquote>
<p><strong>border</strong> : bool</p>
<blockquote>
<div><p>If border == true the leftmost column and the topmost row are left blank</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_connectivity_spectrum">
<code class="descclassname">scot.plotting.</code><code class="descname">plot_connectivity_spectrum</code><span class="sig-paren">(</span><em>a</em>, <em>fs=2</em>, <em>freq_range=(-inf</em>, <em>inf)</em>, <em>diagonal=0</em>, <em>border=False</em>, <em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_connectivity_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw connectivity plots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array, shape (n_channels, n_channels, n_fft) or (1 or 3, n_channels, n_channels, n_fft)</p>
<blockquote>
<div><p>If a.ndim == 3, normal plots are created,
If a.ndim == 4 and a.shape[0] == 1, the area between the curve and y=0 is filled transparently,
If a.ndim == 4 and a.shape[0] == 3, a[0,:,:,:] is plotted normally and the area between a[1,:,:,:] and
a[2,:,:,:] is filled transparently.</p>
</div></blockquote>
<p><strong>fs</strong> : float</p>
<blockquote>
<div><p>Sampling frequency</p>
</div></blockquote>
<p><strong>freq_range</strong> : (float, float)</p>
<blockquote>
<div><p>Frequency range to plot</p>
</div></blockquote>
<p><strong>diagonal</strong> : {-1, 0, 1}</p>
<blockquote>
<div><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</div></blockquote>
<p><strong>border</strong> : bool</p>
<blockquote>
<div><p>If border == true the leftmost column and the topmost row are left blank</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_connectivity_timespectrum">
<code class="descclassname">scot.plotting.</code><code class="descname">plot_connectivity_timespectrum</code><span class="sig-paren">(</span><em>a</em>, <em>fs=2</em>, <em>crange=None</em>, <em>freq_range=(-inf</em>, <em>inf)</em>, <em>time_range=None</em>, <em>diagonal=0</em>, <em>border=False</em>, <em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_connectivity_timespectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw time/frequency connectivity plots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array, shape (n_channels, n_channels, n_fft, n_timesteps)</p>
<blockquote>
<div><p>Values to draw</p>
</div></blockquote>
<p><strong>fs</strong> : float</p>
<blockquote>
<div><p>Sampling frequency</p>
</div></blockquote>
<p><strong>crange</strong> : [int, int], optional</p>
<blockquote>
<div><p>Range of values covered by the colormap.
If set to None, [min(a), max(a)] is substituted.</p>
</div></blockquote>
<p><strong>freq_range</strong> : (float, float)</p>
<blockquote>
<div><p>Frequency range to plot</p>
</div></blockquote>
<p><strong>time_range</strong> : (float, float)</p>
<blockquote>
<div><p>Time range covered by <cite>a</cite></p>
</div></blockquote>
<p><strong>diagonal</strong> : {-1, 0, 1}</p>
<blockquote>
<div><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</div></blockquote>
<p><strong>border</strong> : bool</p>
<blockquote>
<div><p>If border == true the leftmost column and the topmost row are left blank</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_connectivity_topos">
<code class="descclassname">scot.plotting.</code><code class="descname">plot_connectivity_topos</code><span class="sig-paren">(</span><em>layout='diagonal'</em>, <em>topo=None</em>, <em>topomaps=None</em>, <em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_connectivity_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Place topo plots in a figure suitable for connectivity visualization.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>topo</cite> is modified by the function by calling <code class="xref py py-func docutils literal"><span class="pre">set_map()</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>layout</strong> : str</p>
<blockquote>
<div><p>&#8216;diagonal&#8217; -&gt; place topo plots on diagonal.
otherwise -&gt; place topo plots in left column and top row.</p>
</div></blockquote>
<p><strong>topo</strong> : <code class="xref py py-class docutils literal"><span class="pre">Topoplot</span></code></p>
<blockquote>
<div><p>This object draws the topo plot</p>
</div></blockquote>
<p><strong>topomaps</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected map</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_sources">
<code class="descclassname">scot.plotting.</code><code class="descname">plot_sources</code><span class="sig-paren">(</span><em>topo</em>, <em>mixmaps</em>, <em>unmixmaps</em>, <em>global_scale=None</em>, <em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot all scalp projections of mixing- and unmixing-maps.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>topo</cite> is modified by the function by calling <code class="xref py py-func docutils literal"><span class="pre">set_map()</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topo</strong> : <code class="xref py py-class docutils literal"><span class="pre">Topoplot</span></code></p>
<blockquote>
<div><p>This object draws the topo plot</p>
</div></blockquote>
<p><strong>mixmaps</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected mixing matrix</p>
</div></blockquote>
<p><strong>unmixmaps</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected unmixing matrix</p>
</div></blockquote>
<p><strong>global_scale</strong> : float, optional</p>
<blockquote>
<div><p>Set common color scale as given percentile of all map values to use as the maximum.
<cite>None</cite> scales each plot individually (default).</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_topo">
<code class="descclassname">scot.plotting.</code><code class="descname">plot_topo</code><span class="sig-paren">(</span><em>axis</em>, <em>topo</em>, <em>topomap</em>, <em>crange=None</em>, <em>offset=(0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_topo" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a topoplot in given axis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>topo</cite> is modified by the function by calling <code class="xref py py-func docutils literal"><span class="pre">set_map()</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : axis</p>
<blockquote>
<div><p>Axis to draw into.</p>
</div></blockquote>
<p><strong>topo</strong> : <code class="xref py py-class docutils literal"><span class="pre">Topoplot</span></code></p>
<blockquote>
<div><p>This object draws the topo plot</p>
</div></blockquote>
<p><strong>topomap</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected data</p>
</div></blockquote>
<p><strong>crange</strong> : [int, int], optional</p>
<blockquote>
<div><p>Range of values covered by the colormap.
If set to None, [-max(abs(topomap)), max(abs(topomap))] is substituted.</p>
</div></blockquote>
<p><strong>offset</strong> : [float, float], optional</p>
<blockquote>
<div><p>Shift the topo plot by [x,y] in axis units.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>h</strong> : image</p>
<blockquote class="last">
<div><p>Image object the map was plotted into</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_whiteness">
<code class="descclassname">scot.plotting.</code><code class="descname">plot_whiteness</code><span class="sig-paren">(</span><em>var</em>, <em>h</em>, <em>repeats=1000</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_whiteness" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw distribution of the Portmanteu whiteness test.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>var</strong> : <code class="xref py py-class docutils literal"><span class="pre">VARBase</span></code>-like object</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object whose residuals are tested for whiteness.</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Maximum lag to include in the test.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>Number of surrogate estimates to draw under the null hypothesis.</p>
</div></blockquote>
<p><strong>axis</strong> : axis, optional</p>
<blockquote>
<div><p>Axis to draw into. By default draws into <code class="xref py py-func docutils literal"><span class="pre">matplotlib.pyplot.gca()</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pr</strong> : float</p>
<blockquote class="last">
<div><p><em>p</em>-value of whiteness under the null hypothesis</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.prepare_topoplots">
<code class="descclassname">scot.plotting.</code><code class="descname">prepare_topoplots</code><span class="sig-paren">(</span><em>topo</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.prepare_topoplots" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare multiple topo maps for cached plotting.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>topo</cite> is modified by the function by calling <code class="xref py py-func docutils literal"><span class="pre">set_values()</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topo</strong> : <code class="xref py py-class docutils literal"><span class="pre">Topoplot</span></code></p>
<blockquote>
<div><p>Scalp maps are created with this class</p>
</div></blockquote>
<p><strong>values</strong> : array, shape = [n_topos, n_channels]</p>
<blockquote>
<div><p>Channel values for each topo plot</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topomaps</strong> : list of array</p>
<blockquote class="last">
<div><p>The map for each topo plot</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.show_plots">
<code class="descclassname">scot.plotting.</code><code class="descname">show_plots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.show_plots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-scot.utils">
<span id="scot-utils-module"></span><h2>scot.utils module<a class="headerlink" href="#module-scot.utils" title="Permalink to this headline">¶</a></h2>
<p>Utility functions</p>
<dl class="function">
<dt id="scot.utils.acm">
<code class="descclassname">scot.utils.</code><code class="descname">acm</code><span class="sig-paren">(</span><em>x</em>, <em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.utils.acm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute autocovariance matrix at lag l.</p>
<p>This function calculates the autocovariance matrix of <cite>x</cite> at lag <cite>l</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array, shape (n_trials, n_channels, n_samples)</p>
<blockquote>
<div><p>Signal data (2D or 3D for multiple trials)</p>
</div></blockquote>
<p><strong>l</strong> : int</p>
<blockquote>
<div><p>Lag</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>c</strong> : ndarray, shape = [nchannels, n_channels]</p>
<blockquote class="last">
<div><p>Autocovariance matrix of <cite>x</cite> at lag <cite>l</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.utils.cartesian">
<code class="descclassname">scot.utils.</code><code class="descname">cartesian</code><span class="sig-paren">(</span><em>arrays</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.utils.cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a cartesian product of input arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arrays</strong> : list of array-like</p>
<blockquote>
<div><p>1-D arrays to form the cartesian product of.</p>
</div></blockquote>
<p><strong>out</strong> : ndarray</p>
<blockquote>
<div><p>Array to place the cartesian product in.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>2-D array of shape (M, len(arrays)) containing cartesian products
formed of input arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p><a class="reference external" href="http://stackoverflow.com/a/1235363/3005167">http://stackoverflow.com/a/1235363/3005167</a></p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cartesian</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">array([[1, 4, 6],</span>
<span class="go">       [1, 4, 7],</span>
<span class="go">       [1, 5, 6],</span>
<span class="go">       [1, 5, 7],</span>
<span class="go">       [2, 4, 6],</span>
<span class="go">       [2, 4, 7],</span>
<span class="go">       [2, 5, 6],</span>
<span class="go">       [2, 5, 7],</span>
<span class="go">       [3, 4, 6],</span>
<span class="go">       [3, 4, 7],</span>
<span class="go">       [3, 5, 6],</span>
<span class="go">       [3, 5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scot.utils.cuthill_mckee">
<code class="descclassname">scot.utils.</code><code class="descname">cuthill_mckee</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.utils.cuthill_mckee" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the Cuthill-McKee algorithm.</p>
<p>Permute a symmetric binary matrix into a band matrix form with a small bandwidth.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>matrix</strong> : ndarray, dtype=bool, shape = [n, n]</p>
<blockquote>
<div><p>The matrix is internally converted to a symmetric matrix by setting each element [i,j] to True if either
[i,j] or [j,i] evaluates to true.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>order</strong> : list of int</p>
<blockquote class="last">
<div><p>Permutation intices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">cuthill_mckee</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[0, 0, 1, 1],</span>
<span class="go">       [0, 0, 0, 0],</span>
<span class="go">       [1, 0, 1, 0],</span>
<span class="go">       [1, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,:][:,</span><span class="n">p</span><span class="p">]</span>
<span class="go">array([[0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 1],</span>
<span class="go">       [0, 0, 1, 1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="scot.utils.memoize">
<em class="property">class </em><code class="descclassname">scot.utils.</code><code class="descname">memoize</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.utils.memoize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Cache the return value of a method.</p>
<p>This class is meant to be used as a decorator of methods. The return value
from a given method invocation will be cached on the instance whose method
was invoked. All arguments passed to a method decorated with memoize must
be hashable.</p>
<p>If a memoized method is invoked directly on its class the result will not
be cached. Instead the method will be invoked like a static method:</p>
</dd></dl>

</div>
<div class="section" id="module-scot.var">
<span id="scot-var-module"></span><h2>scot.var module<a class="headerlink" href="#module-scot.var" title="Permalink to this headline">¶</a></h2>
<p>Vector autoregressive (VAR) model implementation</p>
<dl class="class">
<dt id="scot.var.VAR">
<em class="property">class </em><code class="descclassname">scot.var.</code><code class="descname">VAR</code><span class="sig-paren">(</span><em>model_order</em>, <em>delta=0</em>, <em>xvschema=&lt;function multitrial&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#scot.varbase.VARBase" title="scot.varbase.VARBase"><code class="xref py py-class docutils literal"><span class="pre">scot.varbase.VARBase</span></code></a></p>
<p>Builtin implementation of VARBase.</p>
<p>This class provides least squares VAR model fitting with optional ridge
regression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model_order</strong> : int</p>
<blockquote>
<div><p>Autoregressive model order</p>
</div></blockquote>
<p><strong>delta</strong> : float, optional</p>
<blockquote>
<div><p>Ridge penalty parameter</p>
</div></blockquote>
<p><strong>xvschema</strong> : func, optional</p>
<blockquote class="last">
<div><p>Function that creates training and test sets for cross-validation. The
function takes two parameters: the current cross-validation run (int)
and the numer of trials (int). It returns a tuple of two arrays: the
training set and the testing set.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.var.VAR.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit VAR model to data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like</p>
<blockquote>
<div><p>shape = [n_trials, n_samples, n_channels] or
[n_channels, n_samples]
Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal"><span class="pre">VAR</span></code></a></p>
<blockquote class="last">
<div><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal"><span class="pre">VAR</span></code></a> object to facilitate method chaining (see usage
example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.var.VAR.optimize">
<code class="descname">optimize</code><span class="sig-paren">(</span><em>data</em>, <em>skipstep=1</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Find optimal ridge penalty with bisection search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape (n_trials, n_samples, n_channels)</p>
<blockquote>
<div><p>Segmented data set. At least 2 trials are required.</p>
</div></blockquote>
<p><strong>skipstep</strong> : int, optional</p>
<blockquote>
<div><p>Speed up calculation by skipping samples during cost function
calculation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal"><span class="pre">VAR</span></code></a></p>
<blockquote class="last">
<div><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal"><span class="pre">VAR</span></code></a> object to facilitate method chaining (see usage
example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.var.VAR.optimize_delta_bisection">
<code class="descname">optimize_delta_bisection</code><span class="sig-paren">(</span><em>data</em>, <em>skipstep=1</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR.optimize_delta_bisection" title="Permalink to this definition">¶</a></dt>
<dd><p>Find optimal ridge penalty with bisection search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape (n_trials, n_samples, n_channels)</p>
<blockquote>
<div><p>Segmented data set. At least 2 trials are required.</p>
</div></blockquote>
<p><strong>skipstep</strong> : int, optional</p>
<blockquote>
<div><p>Speed up calculation by skipping samples during cost function
calculation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal"><span class="pre">VAR</span></code></a></p>
<blockquote class="last">
<div><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal"><span class="pre">VAR</span></code></a> object to facilitate method chaining (see usage
example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.var.VAR.optimize_order">
<code class="descname">optimize_order</code><span class="sig-paren">(</span><em>data</em>, <em>min_p=1</em>, <em>max_p=None</em>, <em>n_jobs=1</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR.optimize_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine optimal model order by cross-validating the mean-squared
generalization error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape (n_trials, n_samples, n_channels)</p>
<blockquote>
<div><p>Segmented data set on which to optimize the model order. At least 2
trials are required.</p>
</div></blockquote>
<p><strong>min_p</strong> : int</p>
<blockquote>
<div><p>minimal model order to check</p>
</div></blockquote>
<p><strong>max_p</strong> : int</p>
<blockquote>
<div><p>maximum model order to check</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | None</p>
<blockquote>
<div><p>number of jobs to run in parallel. See <cite>joblib.Parallel</cite> for
details.</p>
</div></blockquote>
<p><strong>verbose</strong> : int</p>
<blockquote class="last">
<div><p>verbosity level passed to joblib.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-scot.varbase">
<span id="scot-varbase-module"></span><h2>scot.varbase module<a class="headerlink" href="#module-scot.varbase" title="Permalink to this headline">¶</a></h2>
<p>vector autoregressive (VAR) model</p>
<dl class="class">
<dt id="scot.varbase.Defaults">
<em class="property">class </em><code class="descclassname">scot.varbase.</code><code class="descname">Defaults</code><a class="headerlink" href="#scot.varbase.Defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="scot.varbase.Defaults.xvschema">
<code class="descname">xvschema</code><span class="sig-paren">(</span><em>num_trials</em>, <em>skipstep=1</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.Defaults.xvschema" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-trial cross-validation schema</p>
<p>Use one trial for testing, all others for training.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_trials</strong> : int</p>
<blockquote>
<div><p>Total number of trials</p>
</div></blockquote>
<p><strong>skipstep</strong> : int</p>
<blockquote>
<div><p>only use every <cite>skipstep</cite> trial for testing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator object</p>
<blockquote class="last">
<div><p>the generator returns tuples (trainset, testset)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="scot.varbase.VARBase">
<em class="property">class </em><code class="descclassname">scot.varbase.</code><code class="descname">VARBase</code><span class="sig-paren">(</span><em>model_order</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Represents a vector autoregressive (VAR) model.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><cite>VARBase</cite> is an abstract class that defines the interface for</p>
</div>
<p>VAR model implementations. Several methods must be implemented by derived
classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model_order</strong> : int</p>
<blockquote class="last">
<div><p>Autoregressive model order</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note on the arrangement of model coefficients:
<em>b</em> is of shape [m, m*p], with sub matrices arranged as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>b_00</td>
<td>b_01</td>
<td>...</td>
<td>b_0m</td>
</tr>
<tr class="row-even"><td>b_10</td>
<td>b_11</td>
<td>...</td>
<td>b_1m</td>
</tr>
<tr class="row-odd"><td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="row-even"><td>b_m0</td>
<td>b_m1</td>
<td>...</td>
<td>b_mm</td>
</tr>
</tbody>
</table>
<p>Each sub matrix b_ij is a column vector of length p that contains the
filter coefficients from channel j (source) to channel i (sink).</p>
<dl class="method">
<dt id="scot.varbase.VARBase.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the VAR model.</p>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit VAR model to data.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function must be implemented by derived classes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like</p>
<blockquote>
<div><p>shape = [n_trials, n_samples, n_channels] or
[n_channels, n_samples]
Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <code class="xref py py-class docutils literal"><span class="pre">VAR</span></code></p>
<blockquote class="last">
<div><p>The <code class="xref py py-class docutils literal"><span class="pre">VAR</span></code> object to facilitate method chaining (see usage
example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.from_yw">
<code class="descname">from_yw</code><span class="sig-paren">(</span><em>acms</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.from_yw" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine VAR model from autocorrelation matrices by solving the
Yule-Walker equations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>acms</strong> : array-like, shape = [n_lags, n_channels, n_channels]</p>
<blockquote>
<div><p>acms[l] contains the autocorrelation matrix at lag l. The highest
lag must equal the model order.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <code class="xref py py-class docutils literal"><span class="pre">VAR</span></code></p>
<blockquote class="last">
<div><p>The <code class="xref py py-class docutils literal"><span class="pre">VAR</span></code> object to facilitate method chaining (see usage
example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.is_stable">
<code class="descname">is_stable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.is_stable" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the VAR model is stable.</p>
<p>This function tests stability of the VAR model as described in <a class="reference internal" href="#r4" id="id8">[R4]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : bool</p>
<blockquote class="last">
<div><p>True if the model is stable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R4]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> H. Lütkepohl, &#8220;New Introduction to Multiple Time Series
Analysis&#8221;, 2005, Springer, Berlin, Germany</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.optimize">
<code class="descname">optimize</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize model fitting hyperparameters (such as regularization
penalty)</p>
<blockquote>
<div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function must be implemented by derived classes.</p>
</div>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_trials, n_samples, n_channels] or</p>
<blockquote class="last">
<div><p>[n_channels, n_samples]
Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict samples on actual data.</p>
<p>The result of this function is used for calculating the residuals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like</p>
<blockquote>
<div><p>shape = [n_trials, n_samples, n_channels] or
[n_channels, n_samples]
Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>predicted</strong> : shape = <cite>data</cite>.shape</p>
<blockquote class="last">
<div><p>Data as predicted by the VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Residuals are obtained by r = x - var.predict(x)</p>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.simulate">
<code class="descname">simulate</code><span class="sig-paren">(</span><em>l</em>, <em>noisefunc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate vector autoregressive (VAR) model</p>
<p>This function generates data from the VAR model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l</strong> : {int, [int, int]}</p>
<blockquote>
<div><p>Specify number of samples to generate. Can be a tuple or list
where l[0] is the number of samples and l[1] is the number of
trials.</p>
</div></blockquote>
<p><strong>noisefunc</strong> : func, optional</p>
<blockquote>
<div><p>This function is used to create the generating noise process.
If set to None Gaussian white noise with zero mean and unit
variance is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>data</strong> : array, shape = [n_trials, n_samples, n_channels]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.test_whiteness">
<code class="descname">test_whiteness</code><span class="sig-paren">(</span><em>h</em>, <em>repeats=100</em>, <em>get_q=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.test_whiteness" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the VAR model residuals are white (uncorrelated up to a lag
of h).</p>
<p>This function calculates the Li-McLeod as Portmanteau test statistic Q
to test against the null hypothesis H0: &#8220;the residuals are white&#8221; <a class="reference internal" href="#r5" id="id10">[R5]</a>.
Surrogate data for H0 is created by sampling from random permutations
of the residuals.</p>
<p>Usually the returned p-value is compared against a pre-defined type 1
error level of alpha=0.05 or alpha=0.01. If p&lt;=alpha, the hypothesis of
white residuals is rejected, which indicates that the VAR model does
not properly describe the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h</strong> : int</p>
<blockquote>
<div><p>Maximum lag that is included in the test statistic.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to create under the null hypothesis.</p>
</div></blockquote>
<p><strong>get_q</strong> : bool, optional</p>
<blockquote>
<div><p>Return Q statistic along with <em>p</em>-value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pr</strong> : float</p>
<blockquote>
<div><p>Probability of observing a more extreme value of Q under the
assumption that H0 is true.</p>
</div></blockquote>
<p><strong>q0</strong> : list of float, optional (<cite>get_q</cite>)</p>
<blockquote>
<div><p>Individual surrogate estimates that were used for estimating the
distribution of Q under H0.</p>
</div></blockquote>
<p><strong>q</strong> : float, optional (<cite>get_q</cite>)</p>
<blockquote class="last">
<div><p>Value of the Q statistic of the residuals</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>According to <a class="reference internal" href="#r6" id="id11">[R6]</a> h must satisfy h = O(n^0.5), where n is the length
(time samples) of the residuals.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R5]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> H. Lütkepohl, &#8220;New Introduction to Multiple Time Series
Analysis&#8221;, 2005, Springer, Berlin, Germany</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R6]</td><td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> J.R.M. Hosking, &#8220;The Multivariate Portmanteau Statistic&#8221;, 1980,
J. Am. Statist. Assoc.</td></tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="scot.varbase.test_whiteness">
<code class="descclassname">scot.varbase.</code><code class="descname">test_whiteness</code><span class="sig-paren">(</span><em>data</em>, <em>h</em>, <em>p=0</em>, <em>repeats=100</em>, <em>get_q=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.test_whiteness" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if signals are white (serially uncorrelated up to a lag of h).</p>
<p>This function calculates the Li-McLeod as Portmanteau test statistic Q to
test against the null hypothesis H0: &#8220;the residuals are white&#8221; <a class="reference internal" href="#r7" id="id14">[R7]</a>.
Surrogate data for H0 is created by sampling from random permutations of
the residuals.</p>
<p>Usually the returned p-value is compared against a pre-defined type 1 error
level of alpha=0.05 or alpha=0.01. If p&lt;=alpha, the hypothesis of white
residuals is rejected, which indicates that the VAR model does not properly
describe the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>signals</strong> : array-like</p>
<blockquote>
<div><p>shape = [n_trials, n_samples, n_channels] or [n_channels, n_samples]
Continuous or segmented data set.</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Maximum lag that is included in the test statistic.</p>
</div></blockquote>
<p><strong>p</strong> : int, optional</p>
<blockquote>
<div><p>Model order if the <cite>signals</cite> are the residuals resulting from fitting a
VAR model</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to create under the null hypothesis.</p>
</div></blockquote>
<p><strong>get_q</strong> : bool, optional</p>
<blockquote>
<div><p>Return Q statistic along with <em>p</em>-value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pr</strong> : float</p>
<blockquote>
<div><p>Probability of observing a more extreme value of Q under the assumption
that H0 is true.</p>
</div></blockquote>
<p><strong>q0</strong> : list of float, optional (<cite>get_q</cite>)</p>
<blockquote>
<div><p>Individual surrogate estimates that were used for estimating the
distribution of Q under H0.</p>
</div></blockquote>
<p><strong>q</strong> : float, optional (<cite>get_q</cite>)</p>
<blockquote class="last">
<div><p>Value of the Q statistic of the residuals</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>According to <a class="reference internal" href="#r8" id="id15">[R8]</a> h must satisfy h = O(n^0.5), where n is the length (time
samples) of the residuals.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R7]</td><td><em>(<a class="fn-backref" href="#id14">1</a>, <a class="fn-backref" href="#id16">2</a>)</em> H. Lütkepohl, &#8220;New Introduction to Multiple Time Series Analysis&#8221;,
2005, Springer, Berlin, Germany</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R8]</td><td><em>(<a class="fn-backref" href="#id15">1</a>, <a class="fn-backref" href="#id17">2</a>)</em> J.R.M. Hosking, &#8220;The Multivariate Portmanteau Statistic&#8221;, 1980, J.
Am. Statist. Assoc.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.varica">
<span id="scot-varica-module"></span><h2>scot.varica module<a class="headerlink" href="#module-scot.varica" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="scot.varica.cspvarica">
<code class="descclassname">scot.varica.</code><code class="descname">cspvarica</code><span class="sig-paren">(</span><em>x</em>, <em>var</em>, <em>cl</em>, <em>reducedim=None</em>, <em>optimize_var=False</em>, <em>backend=None</em>, <em>varfit='ensemble'</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varica.cspvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs joint VAR model fitting and ICA source separation.</p>
<p>This function implements the CSPVARICA procedure <a class="reference internal" href="#r9" id="id18">[R9]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</p>
<blockquote>
<div><p>data set</p>
</div></blockquote>
<p><strong>var</strong> : <code class="xref py py-class docutils literal"><span class="pre">VARBase</span></code>-like object</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object that is used for model fitting.</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys</p>
<blockquote>
<div><p>Class labels associated with each trial.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int}, optional</p>
<blockquote>
<div><p>Number of (most discriminative) components to keep after applying the CSP.
If set to None, retain all components.</p>
</div></blockquote>
<p><strong>optimize_var</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to call automatic optimization of the VAR fitting routine.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote>
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
<p><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a new model for each class, and
&#8216;trial&#8217; fits a new model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Result</strong> : class</p>
<blockquote class="last">
<div><p>A class with the following attributes is returned:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mixing</td>
<td>Source mixing matrix</td>
</tr>
<tr class="row-even"><td>unmixing</td>
<td>Source unmixing matrix</td>
</tr>
<tr class="row-odd"><td>residuals</td>
<td>Residuals of the VAR model(s) in source space</td>
</tr>
<tr class="row-even"><td>var_residuals</td>
<td>Residuals of the VAR model(s) in EEG space (before ICA)</td>
</tr>
<tr class="row-odd"><td>c</td>
<td>Noise covariance of the VAR model(s) in source space</td>
</tr>
<tr class="row-even"><td>b</td>
<td>VAR model coefficients (source space)</td>
</tr>
<tr class="row-odd"><td>a</td>
<td>VAR model coefficients (EEG space)</td>
</tr>
</tbody>
</table>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>CSPVARICA is performed with the following steps:
1. Dimensionality reduction with CSP
2. Fitting a VAR model tho the data
3. Decomposing the VAR model residuals with ICA
4. Correcting the VAR coefficients</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R9]</td><td><em>(<a class="fn-backref" href="#id18">1</a>, <a class="fn-backref" href="#id19">2</a>)</em> <ol class="last upperalpha simple" start="13">
<li>Billinger et al. &#8220;SCoT: A Python Toolbox for EEG Source Connectivity&#8221;, Frontiers in Neuroinformatics, 2014</li>
</ol>
</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.varica.mvarica">
<code class="descclassname">scot.varica.</code><code class="descname">mvarica</code><span class="sig-paren">(</span><em>x</em>, <em>var</em>, <em>cl=None</em>, <em>reducedim=0.99</em>, <em>optimize_var=False</em>, <em>backend=None</em>, <em>varfit='ensemble'</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varica.mvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs joint VAR model fitting and ICA source separation.</p>
<p>This function implements the MVARICA procedure <a class="reference internal" href="#r10" id="id20">[R10]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</p>
<blockquote>
<div><p>data set</p>
</div></blockquote>
<p><strong>var</strong> : <code class="xref py py-class docutils literal"><span class="pre">VARBase</span></code>-like object</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object that is used for model fitting.</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys, optional</p>
<blockquote>
<div><p>Class labels associated with each trial.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int, float, &#8216;no_pca&#8217;, None}, optional</p>
<blockquote>
<div><p>A number of less than 1 is interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer number of 1 or greater is interpreted as the number of components to keep after applying PCA.
If set to None, all PCA components are retained. If set to &#8216;no_pca&#8217;, the PCA step is skipped.</p>
</div></blockquote>
<p><strong>optimize_var</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to call automatic optimization of the VAR fitting routine.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote>
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
<p><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a new model for each class, and
&#8216;trial&#8217; fits a new model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote class="last">
<div><p>A class with the following attributes is returned:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mixing</td>
<td>Source mixing matrix</td>
</tr>
<tr class="row-even"><td>unmixing</td>
<td>Source unmixing matrix</td>
</tr>
<tr class="row-odd"><td>residuals</td>
<td>Residuals of the VAR model(s) in source space</td>
</tr>
<tr class="row-even"><td>var_residuals</td>
<td>Residuals of the VAR model(s) in EEG space (before ICA)</td>
</tr>
<tr class="row-odd"><td>c</td>
<td>Noise covariance of the VAR model(s) in source space</td>
</tr>
<tr class="row-even"><td>b</td>
<td>VAR model coefficients (source space)</td>
</tr>
<tr class="row-odd"><td>a</td>
<td>VAR model coefficients (EEG space)</td>
</tr>
</tbody>
</table>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>MVARICA is performed with the following steps:        
1. Optional dimensionality reduction with PCA
2. Fitting a VAR model tho the data
3. Decomposing the VAR model residuals with ICA
4. Correcting the VAR coefficients</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R10]</td><td><em>(<a class="fn-backref" href="#id20">1</a>, <a class="fn-backref" href="#id21">2</a>)</em> <ol class="last upperalpha simple" start="7">
<li>Gomez-Herrero et al. &#8220;Measuring directional coupling between EEG sources&#8221;, NeuroImage, 2008</li>
</ol>
</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.xvschema">
<span id="scot-xvschema-module"></span><h2>scot.xvschema module<a class="headerlink" href="#module-scot.xvschema" title="Permalink to this headline">¶</a></h2>
<p>Cross-validation schemas</p>
<dl class="function">
<dt id="scot.xvschema.make_nfold">
<code class="descclassname">scot.xvschema.</code><code class="descname">make_nfold</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.xvschema.make_nfold" title="Permalink to this definition">¶</a></dt>
<dd><p>n-fold cross validation</p>
<p>Use each of n blocks for testing once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int</p>
<blockquote>
<div><p>number of blocks</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gengen</strong> : func</p>
<blockquote class="last">
<div><p>a function that returns the generator</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.xvschema.multitrial">
<code class="descclassname">scot.xvschema.</code><code class="descname">multitrial</code><span class="sig-paren">(</span><em>num_trials</em>, <em>skipstep=1</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.xvschema.multitrial" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-trial cross-validation schema</p>
<p>Use one trial for testing, all others for training.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_trials</strong> : int</p>
<blockquote>
<div><p>Total number of trials</p>
</div></blockquote>
<p><strong>skipstep</strong> : int</p>
<blockquote>
<div><p>only use every <cite>skipstep</cite> trial for testing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator object</p>
<blockquote class="last">
<div><p>the generator returns tuples (trainset, testset)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.xvschema.singletrial">
<code class="descclassname">scot.xvschema.</code><code class="descname">singletrial</code><span class="sig-paren">(</span><em>num_trials</em>, <em>skipstep=1</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.xvschema.singletrial" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-trial cross-validation schema</p>
<p>Use one trial for training, all others for testing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_trials</strong> : int</p>
<blockquote>
<div><p>Total number of trials</p>
</div></blockquote>
<p><strong>skipstep</strong> : int</p>
<blockquote>
<div><p>only use every <cite>skipstep</cite> trial for training</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator object</p>
<blockquote class="last">
<div><p>the generator returns tuples (trainset, testset)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.xvschema.splitset">
<code class="descclassname">scot.xvschema.</code><code class="descname">splitset</code><span class="sig-paren">(</span><em>num_trials</em>, <em>skipstep=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.xvschema.splitset" title="Permalink to this definition">¶</a></dt>
<dd><p>Split-set cross validation</p>
<p>Use half the trials for training, and the other half for testing. Then
repeat the other way round.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_trials</strong> : int</p>
<blockquote>
<div><p>Total number of trials</p>
</div></blockquote>
<p><strong>skipstep</strong> : int</p>
<blockquote>
<div><p>unused</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator object</p>
<blockquote class="last">
<div><p>the generator returns tuples (trainset, testset)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-scot" title="Permalink to this headline">¶</a></h2>
<p>SCoT: The Source Connectivity Toolbox</p>
<dl class="class">
<dt id="scot.Workspace">
<em class="property">class </em><code class="descclassname">scot.</code><code class="descname">Workspace</code><span class="sig-paren">(</span><em>var</em>, <em>locations=None</em>, <em>reducedim=0.99</em>, <em>nfft=512</em>, <em>fs=2</em>, <em>backend=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>SCoT Workspace</p>
<p>This class provides high-level functionality for source identification, connectivity estimation, and visualization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>var</strong> : {<code class="xref py py-class docutils literal"><span class="pre">VARBase</span></code>-like object, dict}</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object that is used for model fitting.
This can also be a dictionary that is passed as <cite>**kwargs</cite> to backend[&#8216;var&#8217;]() in order to
construct a new VAR model object.</p>
</div></blockquote>
<p><strong>locations</strong> : array_like, optional</p>
<blockquote>
<div><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int, float, &#8216;no_pca&#8217;}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer number of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to &#8216;no_pca&#8217; the PCA step is skipped.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins for connectivity estimation.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote class="last">
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>unmixing_</cite></td>
<td>(array) Estimated unmixing matrix.</td>
</tr>
<tr class="row-even"><td><cite>mixing_</cite></td>
<td>(array) Estimated mixing matrix.</td>
</tr>
<tr class="row-odd"><td><cite>plot_diagonal</cite></td>
<td>(str) Configures what is plotted in the diagonal subplots. <strong>&#8216;topo&#8217;</strong> (default) plots topoplots on the diagonal, <strong>&#8216;S&#8217;</strong> plots the spectral density of each component, and <strong>&#8216;fill&#8217;</strong> plots connectivity on the diagonal.</td>
</tr>
<tr class="row-even"><td><cite>plot_outside_topo</cite></td>
<td>(bool) Whether to place topoplots in the left column and top row.</td>
</tr>
<tr class="row-odd"><td><cite>plot_f_range</cite></td>
<td>((int, int)) Lower and upper frequency limits for plotting. Defaults to [0, fs/2].</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.Workspace.compare_conditions">
<code class="descname">compare_conditions</code><span class="sig-paren">(</span><em>labels1</em>, <em>labels2</em>, <em>measure_name</em>, <em>alpha=0.01</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.compare_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for significant difference in connectivity of two sets of class labels.</p>
<p>Connectivity estimates are obtained by bootstrapping. Correction for multiple testing is performed by
controlling the false discovery rate (FDR).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels1, labels2</strong> : list of class labels</p>
<blockquote>
<div><p>The two sets of class labels to compare. Each set may contain more than one label.</p>
</div></blockquote>
<p><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</div></blockquote>
<p><strong>alpha</strong> : float, optional</p>
<blockquote>
<div><p>Maximum allowed FDR. The ratio of falsely detected significant differences is guaranteed to be less than
<cite>alpha</cite>.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : array, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Uncorrected p-values.</p>
</div></blockquote>
<p><strong>s</strong> : array, dtype=bool, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>FDR corrected significance. True means the difference is significant in this location.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.do_cspvarica">
<code class="descname">do_cspvarica</code><span class="sig-paren">(</span><em>varfit='ensemble'</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.do_cspvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform CSPVARICA</p>
<p>Perform CSPVARICA source decomposition and VAR model fitting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a different model for each class, and
&#8216;trial&#8217; fits a different model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <code class="xref py py-func docutils literal"><span class="pre">cspvarica()</span></code> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal"><span class="pre">cspvarica()</span></code></dt>
<dd>CSPVARICA implementation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.do_ica">
<code class="descname">do_ica</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.do_ica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform ICA</p>
<p>Perform plain ICA source decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <a class="reference internal" href="#module-scot.plainica" title="scot.plainica"><code class="xref py py-func docutils literal"><span class="pre">plainica()</span></code></a> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.do_mvarica">
<code class="descname">do_mvarica</code><span class="sig-paren">(</span><em>varfit='ensemble'</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.do_mvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform MVARICA</p>
<p>Perform MVARICA source decomposition and VAR model fitting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a different model for each class, and
&#8216;trial&#8217; fits a different model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <code class="xref py py-func docutils literal"><span class="pre">mvarica()</span></code> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal"><span class="pre">mvarica()</span></code></dt>
<dd>MVARICA implementation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.fit_var">
<code class="descname">fit_var</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.fit_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a var model to the source activations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain source activations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.get_bootstrap_connectivity">
<code class="descname">get_bootstrap_connectivity</code><span class="sig-paren">(</span><em>measure_names</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.get_bootstrap_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bootstrap estimates of spectral connectivity measures.</p>
<p>Bootstrapping is performed on trial level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each bootstrap estimate. If <cite>measure_names</cite> is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are
ndarrays of shape [<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.bootstrap_connectivity" title="scot.connectivity_statistics.bootstrap_connectivity"><code class="xref py py-func docutils literal"><span class="pre">scot.connectivity_statistics.bootstrap_connectivity()</span></code></a></dt>
<dd>Calculates bootstrap connectivity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.get_connectivity">
<code class="descname">get_connectivity</code><span class="sig-paren">(</span><em>measure_name</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.get_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Values of the connectivity measure.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object</p>
<blockquote>
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain a fitted VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.get_surrogate_connectivity">
<code class="descname">get_surrogate_connectivity</code><span class="sig-paren">(</span><em>measure_name</em>, <em>repeats=100</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.get_surrogate_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each surrogate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.surrogate_connectivity" title="scot.connectivity_statistics.surrogate_connectivity"><code class="xref py py-func docutils literal"><span class="pre">scot.connectivity_statistics.surrogate_connectivity()</span></code></a></dt>
<dd>Calculates surrogate connectivity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.get_tf_connectivity">
<code class="descname">get_tf_connectivity</code><span class="sig-paren">(</span><em>measure_name</em>, <em>winlen</em>, <em>winstep</em>, <em>plot=False</em>, <em>baseline=None</em>, <em>crange='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.get_tf_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate estimate of time-varying connectivity.</p>
<p>Connectivity is estimated in a sliding window approach on the current data set. The window is stepped
<cite>n_steps</cite> = (<cite>n_samples</cite> - <cite>winlen</cite>) // <cite>winstep</cite> times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</div></blockquote>
<p><strong>winlen</strong> : int</p>
<blockquote>
<div><p>Length of the sliding window (in samples).</p>
</div></blockquote>
<p><strong>winstep</strong> : int</p>
<blockquote>
<div><p>Step size for sliding window (in samples).</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
<p><strong>baseline</strong> : [int, int] or None</p>
<blockquote>
<div><p>Start and end of the baseline period in samples. The baseline is subtracted from the connectivity. It is
computed as the average of all windows that contain start or end, or fall between start and end.
If set to None no baseline is subtracted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array, shape = [n_channels, n_channels, nfft, n_steps]</p>
<blockquote>
<div><p>Values of the connectivity measure.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain a fitted VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.optimize_var">
<code class="descname">optimize_var</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.optimize_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the var model&#8217;s hyperparameters (such as regularization).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain source activations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.plot_connectivity_surrogate">
<code class="descname">plot_connectivity_surrogate</code><span class="sig-paren">(</span><em>measure_name</em>, <em>repeats=100</em>, <em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.plot_connectivity_surrogate" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
<p><strong>fig</strong> : {None, Figure object}, optional</p>
<blockquote>
<div><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.plot_connectivity_topos">
<code class="descname">plot_connectivity_topos</code><span class="sig-paren">(</span><em>fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.plot_connectivity_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot scalp projections of the sources.</p>
<p>This function only plots the topos. Use in combination with connectivity plotting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fig</strong> : {None, Figure object}, optional</p>
<blockquote>
<div><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.plot_source_topos">
<code class="descname">plot_source_topos</code><span class="sig-paren">(</span><em>common_scale=None</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.plot_source_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topography of the Source decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>common_scale</strong> : float, optional</p>
<blockquote class="last">
<div><p>If set to None, each topoplot&#8217;s color axis is scaled individually. Otherwise specifies the percentile
(1-99) of values in all plot. This value is taken as the maximum color scale.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="scot.Workspace.plotting">
<code class="descname">plotting</code><a class="headerlink" href="#scot.Workspace.plotting" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="scot.Workspace.remove_sources">
<code class="descname">remove_sources</code><span class="sig-paren">(</span><em>sources</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.remove_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sources from the decomposition.</p>
<p>This function removes sources from the decomposition. Doing so invalidates currently fitted VAR models and
connectivity estimates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sources</strong> : {slice, int, array of ints}</p>
<blockquote>
<div><p>Indices of components to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal"><span class="pre">Workspace</span></code></a> instance does not contain a source decomposition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em>, <em>cl=None</em>, <em>time_offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign data to the workspace.</p>
<p>This function assigns a new data set to the workspace. Doing so invalidates currently fitted VAR models,
connectivity estimates, and activations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys</p>
<blockquote>
<div><p>Class labels associated with each trial.</p>
</div></blockquote>
<p><strong>time_offset</strong> : float, optional</p>
<blockquote class="last">
<div><p>Trial starting time; used for labelling the x-axis of time/frequency plots.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.set_locations">
<code class="descname">set_locations</code><span class="sig-paren">(</span><em>locations</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.set_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sensor locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>locations</strong> : array_like</p>
<blockquote class="last">
<div><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.set_premixing">
<code class="descname">set_premixing</code><span class="sig-paren">(</span><em>premixing</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.set_premixing" title="Permalink to this definition">¶</a></dt>
<dd><p>Set premixing matrix.</p>
<p>The premixing matrix maps data to physical channels. If the data is actual channel data,
the premixing matrix can be set to identity. Use this functionality if the data was pre-
transformed with e.g. PCA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>premixing</strong> : array_like, shape = [n_signals, n_channels]</p>
<blockquote class="last">
<div><p>Matrix that maps data signals to physical channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.set_used_labels">
<code class="descname">set_used_labels</code><span class="sig-paren">(</span><em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.set_used_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify which trials to use in subsequent analysis steps.</p>
<p>This function masks trials based on their class labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : list of class labels</p>
<blockquote class="last">
<div><p>Marks all trials that have a label that is in the <cite>labels</cite> list for further processing.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.show_plots">
<code class="descname">show_plots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.show_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Show current plots.</p>
<p>This is only a convenience wrapper around <code class="xref py py-func docutils literal"><span class="pre">matplotlib.pyplot.show_plots()</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="scot.Connectivity">
<em class="property">class </em><code class="descclassname">scot.</code><code class="descname">Connectivity</code><span class="sig-paren">(</span><em>b</em>, <em>c=None</em>, <em>nfft=512</em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Calculation of connectivity measures</p>
<p>This class calculates various spectral connectivity measures from a vector autoregressive (VAR) model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>b</strong> : ndarray, shape = [n_channels, n_channels*model_order]</p>
<blockquote>
<div><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><span>On the arrangement of VAR model coefficients</span></a> for details about the arrangement of coefficients.</p>
</div></blockquote>
<p><strong>c</strong> : ndarray, shape = [n_channels, n_channels], optional</p>
<blockquote>
<div><p>Covariance matrix of the driving noise process. Identity matrix is used if set to None.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote class="last">
<div><p>Number of frequency bins to calculate. Note that these points cover the range between 0 and half the
sampling rate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Connectivity measures are returned by member functions that take no arguments and return a matrix of
shape [m,m,nfft]. The first dimension is the sink, the second dimension is the source, and the third dimension is
the frequency.</p>
<p>A summary of most supported measures can be found in <a class="reference internal" href="#r11" id="id22">[R11]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R11]</td><td><em>(<a class="fn-backref" href="#id22">1</a>, <a class="fn-backref" href="#id23">2</a>)</em> M. Billinger et al, “Single-trial connectivity estimation for classification of motor imagery data”,
<em>J. Neural Eng.</em> 10, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.A" title="scot.Connectivity.A"><code class="xref py py-func docutils literal"><span class="pre">A()</span></code></a></td>
<td>Spectral representation of the VAR coefficients</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.H" title="scot.Connectivity.H"><code class="xref py py-func docutils literal"><span class="pre">H()</span></code></a></td>
<td>Transfer function that turns the innovation process into the VAR process</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.S" title="scot.Connectivity.S"><code class="xref py py-func docutils literal"><span class="pre">S()</span></code></a></td>
<td>Cross spectral density</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.logS" title="scot.Connectivity.logS"><code class="xref py py-func docutils literal"><span class="pre">logS()</span></code></a></td>
<td>Logarithm of the cross spectral density (S), for convenience.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.G" title="scot.Connectivity.G"><code class="xref py py-func docutils literal"><span class="pre">G()</span></code></a></td>
<td>Inverse cross spectral density</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.logG" title="scot.Connectivity.logG"><code class="xref py py-func docutils literal"><span class="pre">logG()</span></code></a></td>
<td>Logarithm of the inverse cross spectral density</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.PHI" title="scot.Connectivity.PHI"><code class="xref py py-func docutils literal"><span class="pre">PHI()</span></code></a></td>
<td>Phase angle</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.COH" title="scot.Connectivity.COH"><code class="xref py py-func docutils literal"><span class="pre">COH()</span></code></a></td>
<td>Coherence</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.pCOH" title="scot.Connectivity.pCOH"><code class="xref py py-func docutils literal"><span class="pre">pCOH()</span></code></a></td>
<td>Partial coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.PDC" title="scot.Connectivity.PDC"><code class="xref py py-func docutils literal"><span class="pre">PDC()</span></code></a></td>
<td>Partial directed coherence</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.ffPDC" title="scot.Connectivity.ffPDC"><code class="xref py py-func docutils literal"><span class="pre">ffPDC()</span></code></a></td>
<td>Full frequency partial directed coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.PDCF" title="scot.Connectivity.PDCF"><code class="xref py py-func docutils literal"><span class="pre">PDCF()</span></code></a></td>
<td>PDC factor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.GPDC" title="scot.Connectivity.GPDC"><code class="xref py py-func docutils literal"><span class="pre">GPDC()</span></code></a></td>
<td>Generalized partial directed coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.DTF" title="scot.Connectivity.DTF"><code class="xref py py-func docutils literal"><span class="pre">DTF()</span></code></a></td>
<td>Directed transfer function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.ffDTF" title="scot.Connectivity.ffDTF"><code class="xref py py-func docutils literal"><span class="pre">ffDTF()</span></code></a></td>
<td>Full frequency directed transfer function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.dDTF" title="scot.Connectivity.dDTF"><code class="xref py py-func docutils literal"><span class="pre">dDTF()</span></code></a></td>
<td>Direct directed transfer function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.GDTF" title="scot.Connectivity.GDTF"><code class="xref py py-func docutils literal"><span class="pre">GDTF()</span></code></a></td>
<td>Generalized directed transfer function</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.Connectivity.A">
<code class="descname">A</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectral VAR coefficients</p>
<div class="math">
\[\mathbf{A}(f) = \mathbf{I} - \sum_{k=1}^{p} \mathbf{a}^{(k)} \mathrm{e}^{-2\pi f}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.COH">
<code class="descname">COH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.COH" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherence</p>
<div class="math">
\[\mathrm{COH}_{ij}(f) = \frac{S_{ij}(f)}{\sqrt{S_{ii}(f) S_{jj}(f)}}\]</div>
<p class="rubric">References</p>
<p>P. L. Nunez, R. Srinivasan, A. F. Westdorp, R. S. Wijesinghe, D. M. Tucker,
R. B. Silverstein, P. J. Cadusch. EEG coherency: I: statistics, reference electrode,
volume conduction, Laplacians, cortical imaging, and interpretation at multiple scales.
Electroenceph. Clin. Neurophysiol. 103(5): 499-515, 1997.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.Cinv">
<code class="descname">Cinv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.Cinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of the noise covariance</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.DTF">
<code class="descname">DTF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.DTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Directed transfer function</p>
<div class="math">
\[\mathrm{DTF}_{ij}(f) = \frac{H_{ij}(f)}{\sqrt{H_{i:}(f) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>M. J. Kaminski, K. J. Blinowska. A new method of the description of the information flow
in the brain structures. Biol. Cybernetics 65(3): 203-210, 1991.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.G">
<code class="descname">G</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.G" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse cross spectral density</p>
<div class="math">
\[\mathbf{G}(f) = \mathbf{A}(f) \mathbf{C}^{-1} \mathbf{A}'(f)\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.GDTF">
<code class="descname">GDTF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.GDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized directed transfer function</p>
<div class="math">
\[\mathrm{GPDC}_{ij}(f) = \frac{\sigma_j |H_{ij}(f)|}
{\sqrt{H_{i:}(f) \mathrm{diag}(\mathbf{C}) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring Connectivity in Linear Multivariate Processes:
Definitions, Interpretation, and Practical Analysis. Comput. Math. Meth. Med. 2012:140513, 2012.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.GPDC">
<code class="descname">GPDC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.GPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized partial directed coherence</p>
<div class="math">
\[\mathrm{GPDC}_{ij}(f) = \frac{|A_{ij}(f)|}
{\sigma_i \sqrt{A_{:j}'(f) \mathrm{diag}(\mathbf{C})^{-1} A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring Connectivity in Linear Multivariate Processes:
Definitions, Interpretation, and Practical Analysis. Comput. Math. Meth. Med. 2012:140513, 2012.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.H">
<code class="descname">H</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.H" title="Permalink to this definition">¶</a></dt>
<dd><p>VAR transfer function</p>
<div class="math">
\[\mathbf{H}(f) = \mathbf{A}(f)^{-1}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.PDC">
<code class="descname">PDC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.PDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial directed coherence</p>
<div class="math">
\[\mathrm{PDC}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{A_{:j}'(f) A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept in neural structure
determination. Biol. Cybernetics 84(6):463-474, 2001.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.PDCF">
<code class="descname">PDCF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.PDCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial directed coherence factor</p>
<div class="math">
\[\mathrm{PDCF}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{A_{:j}'(f) \mathbf{C}^{-1} A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept in neural structure
determination. Biol. Cybernetics 84(6):463-474, 2001.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.PHI">
<code class="descname">PHI</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.PHI" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase angle</p>
<p>Returns the phase angle of complex <a class="reference internal" href="#scot.Connectivity.S" title="scot.Connectivity.S"><code class="xref py py-func docutils literal"><span class="pre">S()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.S">
<code class="descname">S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.S" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross spectral density</p>
<div class="math">
\[\mathbf{S}(f) = \mathbf{H}(f) \mathbf{C} \mathbf{H}'(f)\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.absS">
<code class="descname">absS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.absS" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute cross spectral density</p>
<div class="math">
\[\mathrm{absS}(f) = | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.dDTF">
<code class="descname">dDTF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.dDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8221; Direct&#8221; directed transfer function</p>
<div class="math">
\[\mathrm{dDTF}_{ij}(f) = |\mathrm{pCOH}_{ij}(f)| \mathrm{ffDTF}_{ij}(f)\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki. Determination of
information flow direction among brain structures by a modified directed transfer
function (dDTF) method. J. Neurosci. Meth. 125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.ffDTF">
<code class="descname">ffDTF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.ffDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Full frequency directed transfer function</p>
<div class="math">
\[\mathrm{ffDTF}_{ij}(f) = \frac{H_{ij}(f)}{\sqrt{\sum_f H_{i:}(f) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki. Determination of
information flow direction among brain structures by a modified directed transfer
function (dDTF) method. J. Neurosci. Meth. 125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.ffPDC">
<code class="descname">ffPDC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.ffPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Full frequency partial directed coherence</p>
<div class="math">
\[\mathrm{ffPDC}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{\sum_f A_{:j}'(f) A_{:j}(f)}}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.logG">
<code class="descname">logG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.logG" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithmic inverse cross spectral density</p>
<div class="math">
\[\mathrm{logG}(f) = \log | \mathbf{G}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.logS">
<code class="descname">logS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.logS" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithmic cross spectral density</p>
<div class="math">
\[\mathrm{logS}(f) = \log | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.pCOH">
<code class="descname">pCOH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.pCOH" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial coherence</p>
<div class="math">
\[\mathrm{pCOH}_{ij}(f) = \frac{G_{ij}(f)}{\sqrt{G_{ii}(f) G_{jj}(f)}}\]</div>
<p class="rubric">References</p>
<p>P. J. Franaszczuk, K. J. Blinowska, M. Kowalczyk. The application of parametric multichannel
spectral estimates in the study of electrical brain activity. Biol. Cybernetics 51(4): 239-247, 1985.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.sPDC">
<code class="descname">sPDC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.sPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Squared partial directed coherence.</p>
<div class="math">
\[\mathrm{sPDC}_{ij}(f) = \frac{|A_{ij}(f)|^2}{\mathbf{1}^T | A_{:j}(f) |^2}\]</div>
<p class="rubric">References</p>
<p>L. Astolfi, F. Cincotti, D. Mattia, M. G. Marciani, L. Baccala,
F. D. Fallani, S. Salinari, M. Ursino, M. Zavaglia, F. Babiloni. Partial
directed coherence: a new concept in neural structure determination. IEEE
Trans. Biomed. Eng. 53(9):1802-1812, 2006.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scot.eegtopo.html" title="scot.eegtopo package"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="scot"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SCoT</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../api_reference.html" >API Reference</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >scot</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2013-2016 SCoT Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>