<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>scot package &#8212; SCoT</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=514cf933" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    
    <script src="../../_static/documentation_options.js?v=2b62b5d0"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="scot.eegtopo package" href="scot.eegtopo.html" />
    <link rel="prev" title="scot" href="modules.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scot.eegtopo.html" title="scot.eegtopo package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="scot"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SCoT</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../api_reference.html" >API Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">scot</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">scot package</a></li> 
      </ul>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="scot-package">
<h1>scot package<a class="headerlink" href="#scot-package" title="Link to this heading">¶</a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="scot.eegtopo.html">scot.eegtopo package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.eegpos3d">scot.eegtopo.eegpos3d module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.eegpos3d.construct_1020_easycap"><code class="docutils literal notranslate"><span class="pre">construct_1020_easycap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.eegpos3d.intersection"><code class="docutils literal notranslate"><span class="pre">intersection()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.geo_euclidean">scot.eegtopo.geo_euclidean module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector"><code class="docutils literal notranslate"><span class="pre">Vector</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.close"><code class="docutils literal notranslate"><span class="pre">Vector.close()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.copy"><code class="docutils literal notranslate"><span class="pre">Vector.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.cross"><code class="docutils literal notranslate"><span class="pre">Vector.cross()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.dot"><code class="docutils literal notranslate"><span class="pre">Vector.dot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.fromiterable"><code class="docutils literal notranslate"><span class="pre">Vector.fromiterable()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.fromvector"><code class="docutils literal notranslate"><span class="pre">Vector.fromvector()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.norm"><code class="docutils literal notranslate"><span class="pre">Vector.norm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.norm2"><code class="docutils literal notranslate"><span class="pre">Vector.norm2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.normalize"><code class="docutils literal notranslate"><span class="pre">Vector.normalize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.normalized"><code class="docutils literal notranslate"><span class="pre">Vector.normalized()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.rotate"><code class="docutils literal notranslate"><span class="pre">Vector.rotate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_euclidean.Vector.rotated"><code class="docutils literal notranslate"><span class="pre">Vector.rotated()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.geo_spherical">scot.eegtopo.geo_spherical module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Circle"><code class="docutils literal notranslate"><span class="pre">Circle</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Circle.angle"><code class="docutils literal notranslate"><span class="pre">Circle.angle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Circle.distance"><code class="docutils literal notranslate"><span class="pre">Circle.distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Circle.get_point"><code class="docutils literal notranslate"><span class="pre">Circle.get_point()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Circle.get_radius"><code class="docutils literal notranslate"><span class="pre">Circle.get_radius()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Construct"><code class="docutils literal notranslate"><span class="pre">Construct</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Construct.circle_intersect_circle"><code class="docutils literal notranslate"><span class="pre">Construct.circle_intersect_circle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Construct.line_intersect_circle"><code class="docutils literal notranslate"><span class="pre">Construct.line_intersect_circle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Construct.line_intersect_line"><code class="docutils literal notranslate"><span class="pre">Construct.line_intersect_line()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Construct.midpoint"><code class="docutils literal notranslate"><span class="pre">Construct.midpoint()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Line"><code class="docutils literal notranslate"><span class="pre">Line</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Line.distance"><code class="docutils literal notranslate"><span class="pre">Line.distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Line.get_point"><code class="docutils literal notranslate"><span class="pre">Line.get_point()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Point"><code class="docutils literal notranslate"><span class="pre">Point</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Point.distance"><code class="docutils literal notranslate"><span class="pre">Point.distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Point.distances"><code class="docutils literal notranslate"><span class="pre">Point.distances()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Point.fromvector"><code class="docutils literal notranslate"><span class="pre">Point.fromvector()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Point.list"><code class="docutils literal notranslate"><span class="pre">Point.list</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.geo_spherical.Point.vector"><code class="docutils literal notranslate"><span class="pre">Point.vector</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.projections">scot.eegtopo.projections module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.projections.array_project_radial_to2d"><code class="docutils literal notranslate"><span class="pre">array_project_radial_to2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.projections.array_project_radial_to3d"><code class="docutils literal notranslate"><span class="pre">array_project_radial_to3d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.projections.project_radial_to2d"><code class="docutils literal notranslate"><span class="pre">project_radial_to2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.projections.project_radial_to3d"><code class="docutils literal notranslate"><span class="pre">project_radial_to3d()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.tools">scot.eegtopo.tools module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.tools.Struct"><code class="docutils literal notranslate"><span class="pre">Struct</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.tools.Struct.keys"><code class="docutils literal notranslate"><span class="pre">Struct.keys()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.topoplot">scot.eegtopo.topoplot module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot"><code class="docutils literal notranslate"><span class="pre">Topoplot</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.calc_g"><code class="docutils literal notranslate"><span class="pre">Topoplot.calc_g()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.calc_gmap"><code class="docutils literal notranslate"><span class="pre">Topoplot.calc_gmap()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.calc_legendre_factors"><code class="docutils literal notranslate"><span class="pre">Topoplot.calc_legendre_factors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.create_map"><code class="docutils literal notranslate"><span class="pre">Topoplot.create_map()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.get_map"><code class="docutils literal notranslate"><span class="pre">Topoplot.get_map()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.plot_circles"><code class="docutils literal notranslate"><span class="pre">Topoplot.plot_circles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.plot_head"><code class="docutils literal notranslate"><span class="pre">Topoplot.plot_head()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.plot_locations"><code class="docutils literal notranslate"><span class="pre">Topoplot.plot_locations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.plot_map"><code class="docutils literal notranslate"><span class="pre">Topoplot.plot_map()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.set_locations"><code class="docutils literal notranslate"><span class="pre">Topoplot.set_locations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.set_map"><code class="docutils literal notranslate"><span class="pre">Topoplot.set_map()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.Topoplot.set_values"><code class="docutils literal notranslate"><span class="pre">Topoplot.set_values()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.topoplot.topoplot"><code class="docutils literal notranslate"><span class="pre">topoplot()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.warp_layout">scot.eegtopo.warp_layout module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="scot.eegtopo.html#scot.eegtopo.warp_layout.warp_locations"><code class="docutils literal notranslate"><span class="pre">warp_locations()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scot.external.html">scot.external package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scot.external.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.external.html#module-scot.external.infomax_">scot.external.infomax_ module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.external.html#scot.external.infomax_.infomax"><code class="docutils literal notranslate"><span class="pre">infomax()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scot.external.html#scot.external.infomax_.logger"><code class="docutils literal notranslate"><span class="pre">logger</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.external.html#scot.external.infomax_.logger.info"><code class="docutils literal notranslate"><span class="pre">logger.info()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.external.html#module-scot.external">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scot.tests.html">scot.tests package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.test_eegtopo.html">scot.tests.test_eegtopo package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.test_eegtopo.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.test_eegtopo.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.test_eegtopo.html#module-scot.tests.test_eegtopo.test_warp">scot.tests.test_eegtopo.test_warp module</a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.test_eegtopo.html#module-scot.tests.test_eegtopo">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.generate_testdata">scot.tests.generate_testdata module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.generate_testdata.generate_covsig"><code class="docutils literal notranslate"><span class="pre">generate_covsig()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_connectivity">scot.tests.test_connectivity module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_connectivity.TestFunctionality"><code class="docutils literal notranslate"><span class="pre">TestFunctionality</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_connectivity.TestFunctionality.setUp"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_connectivity.TestFunctionality.tearDown"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_connectivity.TestFunctionality.testClass"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.testClass()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_connectivity.TestFunctionality.testFunction"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.testFunction()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_connectivity.assert_zerostructure"><code class="docutils literal notranslate"><span class="pre">assert_zerostructure()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_csp">scot.tests.test_csp module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDefaults"><code class="docutils literal notranslate"><span class="pre">TestDefaults</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDefaults.setUp"><code class="docutils literal notranslate"><span class="pre">TestDefaults.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDefaults.tearDown"><code class="docutils literal notranslate"><span class="pre">TestDefaults.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDefaults.testInputSafety"><code class="docutils literal notranslate"><span class="pre">TestDefaults.testInputSafety()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDefaults.testInvalidInput"><code class="docutils literal notranslate"><span class="pre">TestDefaults.testInvalidInput()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDefaults.testInverse"><code class="docutils literal notranslate"><span class="pre">TestDefaults.testInverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDefaults.testOutputSizes"><code class="docutils literal notranslate"><span class="pre">TestDefaults.testOutputSizes()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDimensionalityReduction"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDimensionalityReduction.setUp"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDimensionalityReduction.tearDown"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDimensionalityReduction.testOutput"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.testOutput()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDimensionalityReduction.testOutputSizes"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.testOutputSizes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestDimensionalityReduction.testPseudoInverse"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.testPseudoInverse()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestFunctionality"><code class="docutils literal notranslate"><span class="pre">TestFunctionality</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestFunctionality.setUp"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestFunctionality.tearDown"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_csp.TestFunctionality.testComponentSeparation"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.testComponentSeparation()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_datatools">scot.tests.test_datatools module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestDataMangling"><code class="docutils literal notranslate"><span class="pre">TestDataMangling</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestDataMangling.setUp"><code class="docutils literal notranslate"><span class="pre">TestDataMangling.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestDataMangling.tearDown"><code class="docutils literal notranslate"><span class="pre">TestDataMangling.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestDataMangling.test_acm_1d"><code class="docutils literal notranslate"><span class="pre">TestDataMangling.test_acm_1d()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestDataMangling.test_cat_trials"><code class="docutils literal notranslate"><span class="pre">TestDataMangling.test_cat_trials()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestDataMangling.test_cut_epochs"><code class="docutils literal notranslate"><span class="pre">TestDataMangling.test_cut_epochs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestDataMangling.test_dot_special"><code class="docutils literal notranslate"><span class="pre">TestDataMangling.test_dot_special()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestRegressions"><code class="docutils literal notranslate"><span class="pre">TestRegressions</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestRegressions.setUp"><code class="docutils literal notranslate"><span class="pre">TestRegressions.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestRegressions.tearDown"><code class="docutils literal notranslate"><span class="pre">TestRegressions.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_datatools.TestRegressions.test_cat_trials_dimensions"><code class="docutils literal notranslate"><span class="pre">TestRegressions.test_cat_trials_dimensions()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_ooapi">scot.tests.test_ooapi module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA"><code class="docutils literal notranslate"><span class="pre">TestMVARICA</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.setUp"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.tearDown"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.testBackendRegression"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.testBackendRegression()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.testExceptions"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.testExceptions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.testFunctionality"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.testFunctionality()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.testModelIdentification"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.testModelIdentification()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.testTrivia"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.testTrivia()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.test_plotting"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.test_plotting()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.test_premixing"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.test_premixing()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.test_random_state"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.test_random_state()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_ooapi.TestMVARICA.test_source_selection"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.test_source_selection()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_parallel">scot.tests.test_parallel module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_parallel.TestFunctions"><code class="docutils literal notranslate"><span class="pre">TestFunctions</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_parallel.TestFunctions.setUp"><code class="docutils literal notranslate"><span class="pre">TestFunctions.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_parallel.TestFunctions.tearDown"><code class="docutils literal notranslate"><span class="pre">TestFunctions.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_parallel.TestFunctions.test_output"><code class="docutils literal notranslate"><span class="pre">TestFunctions.test_output()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_parallel.TestFunctions.test_parallel_loop"><code class="docutils literal notranslate"><span class="pre">TestFunctions.test_parallel_loop()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_parallel.f"><code class="docutils literal notranslate"><span class="pre">f()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_parallel.g"><code class="docutils literal notranslate"><span class="pre">g()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_parallel.h"><code class="docutils literal notranslate"><span class="pre">h()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_pca">scot.tests.test_pca module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDefaults"><code class="docutils literal notranslate"><span class="pre">TestDefaults</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDefaults.setUp"><code class="docutils literal notranslate"><span class="pre">TestDefaults.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDefaults.tearDown"><code class="docutils literal notranslate"><span class="pre">TestDefaults.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDefaults.testInputSafety"><code class="docutils literal notranslate"><span class="pre">TestDefaults.testInputSafety()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDefaults.testInverse"><code class="docutils literal notranslate"><span class="pre">TestDefaults.testInverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDefaults.testOutputSizes"><code class="docutils literal notranslate"><span class="pre">TestDefaults.testOutputSizes()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDimensionalityReduction"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDimensionalityReduction.setUp"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDimensionalityReduction.tearDown"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDimensionalityReduction.testOutputSizes"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.testOutputSizes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDimensionalityReduction.testPseudoInverse"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.testPseudoInverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestDimensionalityReduction.testSorting"><code class="docutils literal notranslate"><span class="pre">TestDimensionalityReduction.testSorting()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestFunctionality"><code class="docutils literal notranslate"><span class="pre">TestFunctionality</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestFunctionality.setUp"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestFunctionality.tearDown"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestFunctionality.testDecorrelation"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.testDecorrelation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestFunctionality.testIdentity"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.testIdentity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_pca.TestFunctionality.testSorting"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.testSorting()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_plainica">scot.tests.test_plainica module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_plainica.TestICA"><code class="docutils literal notranslate"><span class="pre">TestICA</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plainica.TestICA.setUp"><code class="docutils literal notranslate"><span class="pre">TestICA.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plainica.TestICA.tearDown"><code class="docutils literal notranslate"><span class="pre">TestICA.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plainica.TestICA.testInterface"><code class="docutils literal notranslate"><span class="pre">TestICA.testInterface()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plainica.TestICA.testModelIdentification"><code class="docutils literal notranslate"><span class="pre">TestICA.testModelIdentification()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_plotting">scot.tests.test_plotting module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality"><code class="docutils literal notranslate"><span class="pre">TestFunctionality</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality.setUp"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality.tearDown"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality.test_circular"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.test_circular()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality.test_connectivity_significance"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.test_connectivity_significance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality.test_connectivity_spectrum"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.test_connectivity_spectrum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality.test_connectivity_timespectrum"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.test_connectivity_timespectrum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality.test_topoplots"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.test_topoplots()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_plotting.TestFunctionality.test_whiteness"><code class="docutils literal notranslate"><span class="pre">TestFunctionality.test_whiteness()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_statistics">scot.tests.test_statistics module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_statistics.TestFunctions"><code class="docutils literal notranslate"><span class="pre">TestFunctions</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_statistics.TestFunctions.generate_data"><code class="docutils literal notranslate"><span class="pre">TestFunctions.generate_data()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_statistics.TestFunctions.setUp"><code class="docutils literal notranslate"><span class="pre">TestFunctions.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_statistics.TestFunctions.tearDown"><code class="docutils literal notranslate"><span class="pre">TestFunctions.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_statistics.TestFunctions.test_bootstrap"><code class="docutils literal notranslate"><span class="pre">TestFunctions.test_bootstrap()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_statistics.TestFunctions.test_bootstrap_difference_and_fdr"><code class="docutils literal notranslate"><span class="pre">TestFunctions.test_bootstrap_difference_and_fdr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_statistics.TestFunctions.test_jackknife"><code class="docutils literal notranslate"><span class="pre">TestFunctions.test_jackknife()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_statistics.TestFunctions.test_surrogate"><code class="docutils literal notranslate"><span class="pre">TestFunctions.test_surrogate()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_utils">scot.tests.test_utils module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_utils.TestUtils"><code class="docutils literal notranslate"><span class="pre">TestUtils</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_utils.TestUtils.setUp"><code class="docutils literal notranslate"><span class="pre">TestUtils.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_utils.TestUtils.tearDown"><code class="docutils literal notranslate"><span class="pre">TestUtils.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_utils.TestUtils.test_cuthill"><code class="docutils literal notranslate"><span class="pre">TestUtils.test_cuthill()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_utils.TestUtils.test_memoize"><code class="docutils literal notranslate"><span class="pre">TestUtils.test_memoize()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_var">scot.tests.test_var module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR"><code class="docutils literal notranslate"><span class="pre">TestVAR</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.generate_data"><code class="docutils literal notranslate"><span class="pre">TestVAR.generate_data()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.setUp"><code class="docutils literal notranslate"><span class="pre">TestVAR.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.tearDown"><code class="docutils literal notranslate"><span class="pre">TestVAR.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.test_abstract"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_abstract()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.test_predict"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.test_simulate"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_simulate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.test_stable"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_stable()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.test_whiteness"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_whiteness()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var.TestVAR.test_yulewalker"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_yulewalker()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_var_builtin">scot.tests.test_var_builtin module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR"><code class="docutils literal notranslate"><span class="pre">TestVAR</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.setUp"><code class="docutils literal notranslate"><span class="pre">TestVAR.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.tearDown"><code class="docutils literal notranslate"><span class="pre">TestVAR.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.test_bisection_invalid"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_bisection_invalid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.test_bisection_overdetermined"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_bisection_overdetermined()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.test_bisection_underdetermined"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_bisection_underdetermined()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.test_fit"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.test_fit_regularized"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_fit_regularized()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.test_optimize"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_optimize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_builtin.TestVAR.test_residuals"><code class="docutils literal notranslate"><span class="pre">TestVAR.test_residuals()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_var_sklearn">scot.tests.test_var_sklearn module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.CommonTests"><code class="docutils literal notranslate"><span class="pre">CommonTests</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.CommonTests.setUp"><code class="docutils literal notranslate"><span class="pre">CommonTests.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.CommonTests.tearDown"><code class="docutils literal notranslate"><span class="pre">CommonTests.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.CommonTests.test_fit"><code class="docutils literal notranslate"><span class="pre">CommonTests.test_fit()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestElasticNet"><code class="docutils literal notranslate"><span class="pre">TestElasticNet</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestElasticNet.setUp"><code class="docutils literal notranslate"><span class="pre">TestElasticNet.setUp()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestLasso"><code class="docutils literal notranslate"><span class="pre">TestLasso</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestLasso.setUp"><code class="docutils literal notranslate"><span class="pre">TestLasso.setUp()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestLassoLars"><code class="docutils literal notranslate"><span class="pre">TestLassoLars</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestLassoLars.setUp"><code class="docutils literal notranslate"><span class="pre">TestLassoLars.setUp()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestRidge"><code class="docutils literal notranslate"><span class="pre">TestRidge</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestRidge.setUp"><code class="docutils literal notranslate"><span class="pre">TestRidge.setUp()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestRidgeCV"><code class="docutils literal notranslate"><span class="pre">TestRidgeCV</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestRidgeCV.setUp"><code class="docutils literal notranslate"><span class="pre">TestRidgeCV.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_var_sklearn.TestRidgeCV.test_alpha"><code class="docutils literal notranslate"><span class="pre">TestRidgeCV.test_alpha()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_varica">scot.tests.test_varica module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestCSPVARICA"><code class="docutils literal notranslate"><span class="pre">TestCSPVARICA</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestCSPVARICA.setUp"><code class="docutils literal notranslate"><span class="pre">TestCSPVARICA.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestCSPVARICA.tearDown"><code class="docutils literal notranslate"><span class="pre">TestCSPVARICA.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestCSPVARICA.testFit"><code class="docutils literal notranslate"><span class="pre">TestCSPVARICA.testFit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestCSPVARICA.testInterface"><code class="docutils literal notranslate"><span class="pre">TestCSPVARICA.testInterface()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestMVARICA"><code class="docutils literal notranslate"><span class="pre">TestMVARICA</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestMVARICA.setUp"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestMVARICA.tearDown"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestMVARICA.testFit"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.testFit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestMVARICA.testInterface"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.testInterface()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_varica.TestMVARICA.testModelIdentification"><code class="docutils literal notranslate"><span class="pre">TestMVARICA.testModelIdentification()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests.test_xvschema">scot.tests.test_xvschema module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestBuiltin"><code class="docutils literal notranslate"><span class="pre">TestBuiltin</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestBuiltin.setUp"><code class="docutils literal notranslate"><span class="pre">TestBuiltin.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestBuiltin.tearDown"><code class="docutils literal notranslate"><span class="pre">TestBuiltin.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestBuiltin.test_multitrial"><code class="docutils literal notranslate"><span class="pre">TestBuiltin.test_multitrial()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestBuiltin.test_nfold"><code class="docutils literal notranslate"><span class="pre">TestBuiltin.test_nfold()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestBuiltin.test_singletrial"><code class="docutils literal notranslate"><span class="pre">TestBuiltin.test_singletrial()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestBuiltin.test_splitset"><code class="docutils literal notranslate"><span class="pre">TestBuiltin.test_splitset()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestSklearn"><code class="docutils literal notranslate"><span class="pre">TestSklearn</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestSklearn.setUp"><code class="docutils literal notranslate"><span class="pre">TestSklearn.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestSklearn.tearDown"><code class="docutils literal notranslate"><span class="pre">TestSklearn.tearDown()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestSklearn.test_application"><code class="docutils literal notranslate"><span class="pre">TestSklearn.test_application()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestSklearn.test_kfold"><code class="docutils literal notranslate"><span class="pre">TestSklearn.test_kfold()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="scot.tests.html#scot.tests.test_xvschema.TestSklearn.test_leave1out"><code class="docutils literal notranslate"><span class="pre">TestSklearn.test_leave1out()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scot.tests.html#module-scot.tests">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-scot.backend_builtin">
<span id="scot-backend-builtin-module"></span><h2>scot.backend_builtin module<a class="headerlink" href="#module-scot.backend_builtin" title="Link to this heading">¶</a></h2>
<p>Use internally implemented functions as backend.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.backend_builtin.generate">
<span class="sig-prename descclassname"><span class="pre">scot.backend_builtin.</span></span><span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backend_builtin.generate" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-scot.backend_mne">
<span id="scot-backend-mne-module"></span><h2>scot.backend_mne module<a class="headerlink" href="#module-scot.backend_mne" title="Link to this heading">¶</a></h2>
<p>Use mne-python routines as backend.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.backend_mne.generate">
<span class="sig-prename descclassname"><span class="pre">scot.backend_mne.</span></span><span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backend_mne.generate" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-scot.backend_sklearn">
<span id="scot-backend-sklearn-module"></span><h2>scot.backend_sklearn module<a class="headerlink" href="#module-scot.backend_sklearn" title="Link to this heading">¶</a></h2>
<p>Use scikit-learn routines as backend.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.backend_sklearn.generate">
<span class="sig-prename descclassname"><span class="pre">scot.backend_sklearn.</span></span><span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backend_sklearn.generate" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-scot.backendmanager">
<span id="scot-backendmanager-module"></span><h2>scot.backendmanager module<a class="headerlink" href="#module-scot.backendmanager" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="scot.backendmanager.BackendManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.backendmanager.</span></span><span class="sig-name descname"><span class="pre">BackendManager</span></span><a class="headerlink" href="#scot.backendmanager.BackendManager" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="scot.backendmanager.BackendManager.activate">
<span class="sig-name descname"><span class="pre">activate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.activate" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.backendmanager.BackendManager.get_backend">
<span class="sig-name descname"><span class="pre">get_backend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.get_backend" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.backendmanager.BackendManager.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.items" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.backendmanager.BackendManager.names">
<span class="sig-name descname"><span class="pre">names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.names" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.backendmanager.BackendManager.register">
<span class="sig-name descname"><span class="pre">register</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation_function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.backendmanager.BackendManager.register" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-scot.config">
<span id="scot-config-module"></span><h2>scot.config module<a class="headerlink" href="#module-scot.config" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="scot.config.load_configuration">
<span class="sig-prename descclassname"><span class="pre">scot.config.</span></span><span class="sig-name descname"><span class="pre">load_configuration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.config.load_configuration" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-scot.connectivity">
<span id="scot-connectivity-module"></span><h2>scot.connectivity module<a class="headerlink" href="#module-scot.connectivity" title="Link to this heading">¶</a></h2>
<p>Connectivity analysis</p>
<dl class="py class">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.connectivity.</span></span><span class="sig-name descname"><span class="pre">Connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Calculation of connectivity measures.</p>
<p>This class calculates various spectral connectivity measures from a vector
autoregressive (VAR) model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>b</strong><span class="classifier">array, shape (n_channels, n_channels * model_order)</span></dt><dd><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><span class="std std-ref">On the arrangement of VAR model coefficients</span></a> for details
about the arrangement of coefficients.</p>
</dd>
<dt><strong>c</strong><span class="classifier">array, shape (n_channels, n_channels), optional</span></dt><dd><p>Covariance matrix of the driving noise process. Identity matrix is used
if set to None (default).</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequency bins to calculate. Note that these points cover the
range between 0 and half the sampling rate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Connectivity measures are returned by member functions that take no
arguments and return a matrix of shape (m, m, nfft). The first dimension is
the sink, the second dimension is the source, and the third dimension is
the frequency.</p>
<p>An overview of most supported measures can be found in <a class="reference internal" href="#rca8c5f2081de-1" id="id1">[1]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rca8c5f2081de-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>M. Billinger, C. Brunner, G. R. Müller-Putz. Single-trial
connectivity estimation for classification of motor imagery data. J.
Neural Eng. 10, 2013.</p>
</div>
</div>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>:func:`A`</strong></p></td>
<td><p>Spectral representation of the VAR coefficients.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`H`</strong></p></td>
<td><p>Transfer function (turns the innovation process into the VAR process).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`S`</strong></p></td>
<td><p>Cross-spectral density.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`logS`</strong></p></td>
<td><p>Logarithm of the cross-spectral density (S).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`G`</strong></p></td>
<td><p>Inverse cross-spectral density.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`logG`</strong></p></td>
<td><p>Logarithm of the inverse cross-spectral density.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`PHI`</strong></p></td>
<td><p>Phase angle.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`COH`</strong></p></td>
<td><p>Coherence.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`pCOH`</strong></p></td>
<td><p>Partial coherence.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`PDC`</strong></p></td>
<td><p>Partial directed coherence.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`ffPDC`</strong></p></td>
<td><p>Full frequency partial directed coherence.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`PDCF`</strong></p></td>
<td><p>PDC factor.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`GPDC`</strong></p></td>
<td><p>Generalized partial directed coherence.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`DTF`</strong></p></td>
<td><p>Directed transfer function.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`ffDTF`</strong></p></td>
<td><p>Full frequency directed transfer function.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`dDTF`</strong></p></td>
<td><p>Direct directed transfer function.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`GDTF`</strong></p></td>
<td><p>Generalized directed transfer function.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.A">
<span class="sig-name descname"><span class="pre">A</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.A" title="Link to this definition">¶</a></dt>
<dd><p>Spectral VAR coefficients.</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}(f) = \mathbf{I} - \sum_{k=1}^{p} \mathbf{a}^{(k)}
\mathrm{e}^{-2\pi f}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.COH">
<span class="sig-name descname"><span class="pre">COH</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.COH" title="Link to this definition">¶</a></dt>
<dd><p>Coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{COH}_{ij}(f) = \\frac{S_{ij}(f)}
{\sqrt{S_{ii}(f) S_{jj}(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>P. L. Nunez, R. Srinivasan, A. F. Westdorp, R. S. Wijesinghe,
D. M. Tucker, R. B. Silverstein, P. J. Cadusch. EEG coherency I:
statistics, reference electrode, volume conduction, Laplacians,
cortical imaging, and interpretation at multiple scales. Electroenceph.
Clin. Neurophysiol. 103(5): 499-515, 1997.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.Cinv">
<span class="sig-name descname"><span class="pre">Cinv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.Cinv" title="Link to this definition">¶</a></dt>
<dd><p>Inverse of the noise covariance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.DTF">
<span class="sig-name descname"><span class="pre">DTF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.DTF" title="Link to this definition">¶</a></dt>
<dd><p>Directed transfer function.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{DTF}_{ij}(f) = \\frac{H_{ij}(f)}
{\sqrt{H_{i:}(f) H_{i:}'(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>M. J. Kaminski, K. J. Blinowska. A new method of the description of the
information flow in the brain structures. Biol. Cybernetics 65(3):
203-210, 1991.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.G">
<span class="sig-name descname"><span class="pre">G</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.G" title="Link to this definition">¶</a></dt>
<dd><p>Inverse cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathbf{G}(f) = \mathbf{A}(f) \mathbf{C}^{-1} \mathbf{A}'(f)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.GDTF">
<span class="sig-name descname"><span class="pre">GDTF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.GDTF" title="Link to this definition">¶</a></dt>
<dd><p>Generalized directed transfer function.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{GPDC}_{ij}(f) = \\frac{\sigma_j |H_{ij}(f)|}
{\sqrt{H_{i:}(f) \mathrm{diag}(\mathbf{C}) H_{i:}'(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring connectivity in linear
multivariate processes: definitions, interpretation, and practical
analysis. Comput. Math. Meth. Med. 2012: 140513, 2012.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.GPDC">
<span class="sig-name descname"><span class="pre">GPDC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.GPDC" title="Link to this definition">¶</a></dt>
<dd><p>Generalized partial directed coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{GPDC}_{ij}(f) = \\frac{|A_{ij}(f)|}\end{split}\]</div>
<p>{sigma_i sqrt{A_{:j}’(f) mathrm{diag}(mathbf{C})^{-1} A_{:j}(f)}}</p>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring connectivity in linear
multivariate processes: definitions, interpretation, and practical
analysis. Comput. Math. Meth. Med. 2012: 140513, 2012.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.H">
<span class="sig-name descname"><span class="pre">H</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.H" title="Link to this definition">¶</a></dt>
<dd><p>VAR transfer function.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}(f) = \mathbf{A}(f)^{-1}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.PDC">
<span class="sig-name descname"><span class="pre">PDC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.PDC" title="Link to this definition">¶</a></dt>
<dd><p>Partial directed coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{PDC}_{ij}(f) = \\frac{A_{ij}(f)}
{\sqrt{A_{:j}'(f) A_{:j}(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept
in neural structure determination. Biol. Cybernetics 84(6): 463-474,
2001.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.PDCF">
<span class="sig-name descname"><span class="pre">PDCF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.PDCF" title="Link to this definition">¶</a></dt>
<dd><p>Partial directed coherence factor.</p>
<div class="math notranslate nohighlight">
\[\mathrm{PDCF}_{ij}(f) =\]</div>
<p>\frac{A_{ij}(f)}{sqrt{A_{:j}’(f) mathbf{C}^{-1} A_{:j}(f)}}</p>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept
in neural structure determination. Biol. Cybernetics 84(6): 463-474,
2001.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.PHI">
<span class="sig-name descname"><span class="pre">PHI</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.PHI" title="Link to this definition">¶</a></dt>
<dd><p>Phase angle.</p>
<p>Phase angle of complex <a class="reference internal" href="#scot.connectivity.Connectivity.S" title="scot.connectivity.Connectivity.S"><code class="xref py py-func docutils literal notranslate"><span class="pre">S()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.S">
<span class="sig-name descname"><span class="pre">S</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.S" title="Link to this definition">¶</a></dt>
<dd><p>Cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathbf{S}(f) = \mathbf{H}(f) \mathbf{C} \mathbf{H}'(f)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.absS">
<span class="sig-name descname"><span class="pre">absS</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.absS" title="Link to this definition">¶</a></dt>
<dd><p>Absolute cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathrm{absS}(f) = | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.dDTF">
<span class="sig-name descname"><span class="pre">dDTF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.dDTF" title="Link to this definition">¶</a></dt>
<dd><p>Direct directed transfer function.</p>
<div class="math notranslate nohighlight">
\[\mathrm{dDTF}_{ij}(f) = |\mathrm{pCOH}_{ij}(f)|
\mathrm{ffDTF}_{ij}(f)\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki.
Determination of information flow direction among brain structures by a
modified directed transfer function (dDTF) method. J. Neurosci. Meth.
125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.ffDTF">
<span class="sig-name descname"><span class="pre">ffDTF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.ffDTF" title="Link to this definition">¶</a></dt>
<dd><p>Full frequency directed transfer function.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{ffDTF}_{ij}(f) =
\\frac{H_{ij}(f)}{\sqrt{\sum_f H_{i:}(f) H_{i:}'(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki.
Determination of information flow direction among brain structures by a
modified directed transfer function (dDTF) method. J. Neurosci. Meth.
125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.ffPDC">
<span class="sig-name descname"><span class="pre">ffPDC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.ffPDC" title="Link to this definition">¶</a></dt>
<dd><p>Full frequency partial directed coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{ffPDC}_{ij}(f) =
\\frac{A_{ij}(f)}{\sqrt{\sum_f A_{:j}'(f) A_{:j}(f)}}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.logG">
<span class="sig-name descname"><span class="pre">logG</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.logG" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic inverse cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathrm{logG}(f) = \log | \mathbf{G}(f) |\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.logS">
<span class="sig-name descname"><span class="pre">logS</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.logS" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathrm{logS}(f) = \log | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.pCOH">
<span class="sig-name descname"><span class="pre">pCOH</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.pCOH" title="Link to this definition">¶</a></dt>
<dd><p>Partial coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{pCOH}_{ij}(f) = \\frac{G_{ij}(f)}
{\sqrt{G_{ii}(f) G_{jj}(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>P. J. Franaszczuk, K. J. Blinowska, M. Kowalczyk. The application of
parametric multichannel spectral estimates in the study of electrical
brain activity. Biol. Cybernetics 51(4): 239-247, 1985.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.connectivity.Connectivity.sPDC">
<span class="sig-name descname"><span class="pre">sPDC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.Connectivity.sPDC" title="Link to this definition">¶</a></dt>
<dd><p>Squared partial directed coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{sPDC}_{ij}(f) = \\frac{|A_{ij}(f)|^2}
{\mathbf{1}^T | A_{:j}(f) |^2}\end{split}\]</div>
<p class="rubric">References</p>
<p>L. Astolfi, F. Cincotti, D. Mattia, M. G. Marciani, L. Baccala, F. D.
Fallani, S. Salinari, M. Ursino, M. Zavaglia, F. Babiloni. Partial
directed coherence: a new concept in neural structure determination.
IEEE Trans. Biomed. Eng. 53(9): 1802-1812, 2006.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.connectivity.connectivity">
<span class="sig-prename descclassname"><span class="pre">scot.connectivity.</span></span><span class="sig-name descname"><span class="pre">connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity.connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate connectivity measures.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_names</strong><span class="classifier">str or list of str</span></dt><dd><p>Name(s) of the connectivity measure(s) to calculate. See
<a class="reference internal" href="#scot.connectivity.Connectivity" title="scot.connectivity.Connectivity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</dd>
<dt><strong>b</strong><span class="classifier">array, shape (n_channels, n_channels * model_order)</span></dt><dd><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><span class="std std-ref">On the arrangement of VAR model coefficients</span></a> for details
about the arrangement of coefficients.</p>
</dd>
<dt><strong>c</strong><span class="classifier">array, shape (n_channels, n_channels), optional</span></dt><dd><p>Covariance matrix of the driving noise process. Identity matrix is used
if set to None (default).</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequency bins to calculate. Note that these points cover the
range between 0 and half the sampling rate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">array, shape (n_channels, n_channels, <cite>nfft</cite>)</span></dt><dd><p>An array of shape (m, m, nfft) is returned if measures is a string. If
measures is a list of strings, a dictionary is returned, where each key
is the name of the measure, and the corresponding values are arrays of
shape (m, m, nfft).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When using this function, it is more efficient to get several measures at
once than calling the function multiple times.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">([</span><span class="s1">&#39;DTF&#39;</span><span class="p">,</span> <span class="s1">&#39;PDC&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-scot.connectivity_statistics">
<span id="scot-connectivity-statistics-module"></span><h2>scot.connectivity_statistics module<a class="headerlink" href="#module-scot.connectivity_statistics" title="Link to this heading">¶</a></h2>
<p>Routines for statistical evaluation of connectivity.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.connectivity_statistics.bootstrap_connectivity">
<span class="sig-prename descclassname"><span class="pre">scot.connectivity_statistics.</span></span><span class="sig-name descname"><span class="pre">bootstrap_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measures</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.bootstrap_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate bootstrap estimates of connectivity.</p>
<p>To obtain a bootstrap estimate trials are sampled randomly with replacement
from the data set.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <cite>var</cite> will be modified by the function. Treat as</p>
</div>
<p>undefined after the function returns.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measures</strong><span class="classifier">str or list of str</span></dt><dd><p>Name(s) of the connectivity measure(s) to calculate. See
<code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array, shape (trials, channels, samples)</span></dt><dd><p>Time series data (multiple trials).</p>
</dd>
<dt><strong>var</strong><span class="classifier">VARBase-like object</span></dt><dd><p>Instance of a VAR model.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequency bins to calculate. Note that these points cover the
range between 0 and half the sampling rate.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bootstrap estimates to take.</p>
</dd>
<dt><strong>num_samples</strong><span class="classifier">int, optional</span></dt><dd><p>Number of samples to take for each bootstrap estimates. Defaults to the
same number of trials as present in the data.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int, optional</span></dt><dd><p>n_jobs : int | None, optional
Number of jobs to run in parallel. If set to None, joblib is not used
at all. See <cite>joblib.Parallel</cite> for details.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">int, optional</span></dt><dd><p>Verbosity level passed to joblib.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>measure</strong><span class="classifier">array, shape (<cite>repeats</cite>, n_channels, n_channels, nfft)</span></dt><dd><p>Values of the connectivity measure for each bootstrap estimate. If
<cite>measure_names</cite> is a list of strings a dictionary is returned, where
each key is the name of the measure, and the corresponding values are
arrays of shape (<cite>repeats</cite>, n_channels, n_channels, nfft).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.connectivity_statistics.convert_output_">
<span class="sig-prename descclassname"><span class="pre">scot.connectivity_statistics.</span></span><span class="sig-name descname"><span class="pre">convert_output_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measures</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.convert_output_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.connectivity_statistics.jackknife_connectivity">
<span class="sig-prename descclassname"><span class="pre">scot.connectivity_statistics.</span></span><span class="sig-name descname"><span class="pre">jackknife_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measures</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaveout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.jackknife_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate jackknife estimates of connectivity.</p>
<p>For each jackknife estimate a block of trials is left out. This is repeated
until each trial was left out exactly once. The number of estimates depends
on the number of trials and the value of <cite>leaveout</cite>. It is calculated by
repeats = <cite>n_trials</cite> // <cite>leaveout</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <cite>var</cite> will be modified by the function. Treat as</p>
</div>
<p>undefined after the function returns.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measures</strong><span class="classifier">str or list of str</span></dt><dd><p>Name(s) of the connectivity measure(s) to calculate. See
<code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array, shape (trials, channels, samples)</span></dt><dd><p>Time series data (multiple trials).</p>
</dd>
<dt><strong>var</strong><span class="classifier">VARBase-like object</span></dt><dd><p>Instance of a VAR model.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequency bins to calculate. Note that these points cover the
range between 0 and half the sampling rate.</p>
</dd>
<dt><strong>leaveout</strong><span class="classifier">int, optional</span></dt><dd><p>Number of trials to leave out in each estimate.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int | None, optional</span></dt><dd><p>Number of jobs to run in parallel. If set to None, joblib is not used
at all. See <cite>joblib.Parallel</cite> for details.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">int, optional</span></dt><dd><p>Verbosity level passed to joblib.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">array, shape (<cite>repeats</cite>, n_channels, n_channels, nfft)</span></dt><dd><p>Values of the connectivity measure for each surrogate. If
<cite>measure_names</cite> is a list of strings a dictionary is returned, where
each key is the name of the measure, and the corresponding values are
arrays of shape (<cite>repeats</cite>, n_channels, n_channels, nfft).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.connectivity_statistics.significance_fdr">
<span class="sig-prename descclassname"><span class="pre">scot.connectivity_statistics.</span></span><span class="sig-name descname"><span class="pre">significance_fdr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.significance_fdr" title="Link to this definition">¶</a></dt>
<dd><p>Calculate significance by controlling for the false discovery rate.</p>
<p>This function determines which of the p-values in <cite>p</cite> can be considered
significant. Correction for multiple comparisons is performed by
controlling the false discovery rate (FDR). The FDR is the maximum fraction
of p-values that are wrongly considered significant <a class="reference internal" href="#rdbfbde22e3e3-1" id="id3">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">array, shape (channels, channels, nfft)</span></dt><dd><p>p-values.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Maximum false discovery rate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>s</strong><span class="classifier">array, dtype=bool, shape (channels, channels, nfft)</span></dt><dd><p>Significance of each p-value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rdbfbde22e3e3-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>Y. Benjamini, Y. Hochberg. Controlling the false discovery rate: a
practical and powerful approach to multiple testing. J. Royal Stat.
Soc. Series B 57(1): 289-300, 1995.</p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.connectivity_statistics.surrogate_connectivity">
<span class="sig-prename descclassname"><span class="pre">scot.connectivity_statistics.</span></span><span class="sig-name descname"><span class="pre">surrogate_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.connectivity_statistics.surrogate_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate surrogate connectivity for a multivariate time series by phase
randomization <a class="reference internal" href="#r123541f4872d-1" id="id5">[1]</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <cite>var</cite> will be modified by the function. Treat as</p>
</div>
<p>undefined after the function returns.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measures</strong><span class="classifier">str or list of str</span></dt><dd><p>Name(s) of the connectivity measure(s) to calculate. See
<code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array, shape (trials, channels, samples) or (channels, samples)</span></dt><dd><p>Time series data (2D or 3D for multiple trials)</p>
</dd>
<dt><strong>var</strong><span class="classifier">VARBase-like object</span></dt><dd><p>Instance of a VAR model.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequency bins to calculate. Note that these points cover the
range between 0 and half the sampling rate.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>Number of surrogate samples to take.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int | None, optional</span></dt><dd><p>Number of jobs to run in parallel. If set to None, joblib is not used
at all. See <cite>joblib.Parallel</cite> for details.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">int, optional</span></dt><dd><p>Verbosity level passed to joblib.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">array, shape (<cite>repeats</cite>, n_channels, n_channels, nfft)</span></dt><dd><p>Values of the connectivity measure for each surrogate. If
<cite>measure_names</cite> is a list of strings a dictionary is returned, where
each key is the name of the measure, and the corresponding values are
arrays of shape (<cite>repeats</cite>, n_channels, n_channels, nfft).</p>
</dd>
</dl>
<div role="list" class="citation-list">
<div class="citation" id="r123541f4872d-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p>J. Theiler et al. Testing for nonlinearity in time series: the
method of surrogate data. Physica D, 58: 77-94, 1992.</p>
</div>
</div>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-scot.csp">
<span id="scot-csp-module"></span><h2>scot.csp module<a class="headerlink" href="#module-scot.csp" title="Link to this heading">¶</a></h2>
<p>Common spatial patterns (CSP) implementation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.csp.csp">
<span class="sig-prename descclassname"><span class="pre">scot.csp.</span></span><span class="sig-name descname"><span class="pre">csp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numcomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.csp.csp" title="Link to this definition">¶</a></dt>
<dd><p>Calculate common spatial patterns (CSP).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array, shape (trials, channels, samples) or (channels, samples)</span></dt><dd><p>EEG data set.</p>
</dd>
<dt><strong>cl</strong><span class="classifier">list of valid dict keys</span></dt><dd><p>Class labels associated with each trial. Currently, only two classes
are supported.</p>
</dd>
<dt><strong>numcomp</strong><span class="classifier">int, optional</span></dt><dd><p>Number of patterns to keep after applying CSP. If <cite>numcomp</cite> is greater
than channels or None, all patterns are returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">array, shape (channels, components)</span></dt><dd><p>CSP weight matrix.</p>
</dd>
<dt><strong>v</strong><span class="classifier">array, shape (components, channels)</span></dt><dd><p>CSP projection matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-scot.datasets">
<span id="scot-datasets-module"></span><h2>scot.datasets module<a class="headerlink" href="#module-scot.datasets" title="Link to this heading">¶</a></h2>
<dl class="py exception">
<dt class="sig sig-object py" id="scot.datasets.MD5MismatchError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.datasets.</span></span><span class="sig-name descname"><span class="pre">MD5MismatchError</span></span><a class="headerlink" href="#scot.datasets.MD5MismatchError" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.datasets.convert">
<span class="sig-prename descclassname"><span class="pre">scot.datasets.</span></span><span class="sig-name descname"><span class="pre">convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datasets.convert" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.datasets.fetch">
<span class="sig-prename descclassname"><span class="pre">scot.datasets.</span></span><span class="sig-name descname"><span class="pre">fetch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mi'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datadir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/home/martin/scot_data'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datasets.fetch" title="Link to this definition">¶</a></dt>
<dd><p>Fetch example dataset.</p>
<p>If the requested dataset is not found in the location specified by
<cite>datadir</cite>, the function attempts to download it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataset</strong><span class="classifier">str</span></dt><dd><p>Which dataset to load. Currently only ‘mi’ is supported.</p>
</dd>
<dt><strong>datadir</strong><span class="classifier">str</span></dt><dd><p>Path to the storage location of example datasets. Datasets are
downloaded to this location if they cannot be found. If the directory
does not exist it is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">list of dicts</span></dt><dd><p>The data set is stored in a list, where each list element
corresponds to data from one subject. Each list element is a
dictionary with the following keys:
- “eeg” … EEG signals
- “triggers” … Trigger latencies
- “labels” … Class labels
- “fs” … Sample rate
- “locations” … Channel locations</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-scot.datatools">
<span id="scot-datatools-module"></span><h2>scot.datatools module<a class="headerlink" href="#module-scot.datatools" title="Link to this heading">¶</a></h2>
<section id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h3>
<p>Tools for basic data manipulation.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="scot.datatools.acm">
<span class="sig-prename descclassname"><span class="pre">scot.datatools.</span></span><span class="sig-name descname"><span class="pre">acm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.acm" title="Link to this definition">¶</a></dt>
<dd><p>Compute autocovariance matrix at lag l.</p>
<p>This function calculates the autocovariance matrix of <cite>x</cite> at lag <cite>l</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array, shape (n_trials, n_channels, n_samples)</span></dt><dd><p>Signal data (2D or 3D for multiple trials)</p>
</dd>
<dt><strong>l</strong><span class="classifier">int</span></dt><dd><p>Lag</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>c</strong><span class="classifier">ndarray, shape = [nchannels, n_channels]</span></dt><dd><p>Autocovariance matrix of <cite>x</cite> at lag <cite>l</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.datatools.atleast_3d">
<span class="sig-prename descclassname"><span class="pre">scot.datatools.</span></span><span class="sig-name descname"><span class="pre">atleast_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.atleast_3d" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.datatools.cat_trials">
<span class="sig-prename descclassname"><span class="pre">scot.datatools.</span></span><span class="sig-name descname"><span class="pre">cat_trials</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x3d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.cat_trials" title="Link to this definition">¶</a></dt>
<dd><p>Concatenate trials along time axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x3d</strong><span class="classifier">array, shape (t, m, n)</span></dt><dd><p>Segmented input data with t trials, m signals, and n samples.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x2d</strong><span class="classifier">array, shape (m, t * n)</span></dt><dd><p>Trials are concatenated along the second axis.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#scot.datatools.cut_segments" title="scot.datatools.cut_segments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut_segments</span></code></a></dt><dd><p>Cut segments from continuous data.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cat_trials</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 900)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.datatools.cut_segments">
<span class="sig-prename descclassname"><span class="pre">scot.datatools.</span></span><span class="sig-name descname"><span class="pre">cut_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x2d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.cut_segments" title="Link to this definition">¶</a></dt>
<dd><p>Cut continuous signal into segments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x2d</strong><span class="classifier">array, shape (m, n)</span></dt><dd><p>Input data with m signals and n samples.</p>
</dd>
<dt><strong>tr</strong><span class="classifier">list of int</span></dt><dd><p>Trigger positions.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Window start (offset relative to trigger).</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int</span></dt><dd><p>Window end (offset relative to trigger).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x3d</strong><span class="classifier">array, shape (len(tr), m, stop-start)</span></dt><dd><p>Segments cut from data. Individual segments are stacked along the first
dimension.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#scot.datatools.cat_trials" title="scot.datatools.cat_trials"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cat_trials</span></code></a></dt><dd><p>Concatenate segments.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># 5 channels, 1000 samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">750</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">250</span><span class="p">]</span>  <span class="c1"># three segments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x3d</span> <span class="o">=</span> <span class="n">cut_segments</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># each segment is 50 samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x3d</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 5, 50)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.datatools.dot_special">
<span class="sig-prename descclassname"><span class="pre">scot.datatools.</span></span><span class="sig-name descname"><span class="pre">dot_special</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x2d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x3d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.dot_special" title="Link to this definition">¶</a></dt>
<dd><p>Segment-wise dot product.</p>
<p>This function calculates the dot product of x2d with each trial of x3d.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x2d</strong><span class="classifier">array, shape (p, m)</span></dt><dd><p>Input argument.</p>
</dd>
<dt><strong>x3d</strong><span class="classifier">array, shape (t, m, n)</span></dt><dd><p>Segmented input data with t trials, m signals, and n samples. The dot
product with x2d is calculated for each trial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array, shape (t, p, n)</span></dt><dd><p>Dot product of x2d with each trial of x3d.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">dot_special</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 7, 150)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.datatools.randomize_phase">
<span class="sig-prename descclassname"><span class="pre">scot.datatools.</span></span><span class="sig-name descname"><span class="pre">randomize_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.datatools.randomize_phase" title="Link to this definition">¶</a></dt>
<dd><p>Phase randomization.</p>
<p>This function randomizes the spectral phase of the input data along the
last dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Array of same shape as data.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The algorithm randomizes the phase component of the input’s complex Fourier
transform.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scot.datatools</span> <span class="kn">import</span> <span class="n">randomize_phase</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="mi">1000</span><span class="p">))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">randomize_phase</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase randomization of sine wave and rectangular function&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">]),</span> <span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">]),</span> <span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference download internal" download="" href="../../_downloads/2e9870f773cf065caf5ab617e9da066d/scot-1.py"><code class="xref download docutils literal notranslate"><span class="pre">Source</span> <span class="pre">code</span></code></a>, <a class="reference download internal" download="" href="../../_downloads/d3573800a8ae99448190e78675818f1c/scot-1.png"><code class="xref download docutils literal notranslate"><span class="pre">png</span></code></a>, <a class="reference download internal" download="" href="../../_downloads/488711c4259c6636170653b38cc59acc/scot-1.hires.png"><code class="xref download docutils literal notranslate"><span class="pre">hires.png</span></code></a>, <a class="reference download internal" download="" href="../../_downloads/e357e24a72d1435ede73cc862ce723d0/scot-1.pdf"><code class="xref download docutils literal notranslate"><span class="pre">pdf</span></code></a>)</p>
<figure class="align-default">
<img alt="../../_images/scot-1.png" class="plot-directive" src="../../_images/scot-1.png" />
</figure>
</dd></dl>

</section>
<section id="module-scot.matfiles">
<span id="scot-matfiles-module"></span><h2>scot.matfiles module<a class="headerlink" href="#module-scot.matfiles" title="Link to this heading">¶</a></h2>
<section id="id6">
<h3>Summary<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>Routines for loading and saving Matlab’s .mat files.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="scot.matfiles.loadmat">
<span class="sig-prename descclassname"><span class="pre">scot.matfiles.</span></span><span class="sig-name descname"><span class="pre">loadmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.matfiles.loadmat" title="Link to this definition">¶</a></dt>
<dd><p>This function should be called instead of direct spio.loadmat
as it cures the problem of not properly recovering python dictionaries
from mat files. It calls the function check keys to cure all entries
which are still mat-objects</p>
</dd></dl>

</section>
<section id="module-scot.ooapi">
<span id="scot-ooapi-module"></span><h2>scot.ooapi module<a class="headerlink" href="#module-scot.ooapi" title="Link to this heading">¶</a></h2>
<section id="id7">
<h3>Summary<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h3>
<p>Object oriented API to SCoT.</p>
</section>
<section id="extended-summary">
<h3>Extended Summary<a class="headerlink" href="#extended-summary" title="Link to this heading">¶</a></h3>
<p>The object oriented API provides a the <cite>Workspace</cite> class, which provides high-level functionality and serves as an
example usage of the low-level API.</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="scot.ooapi.Workspace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.ooapi.</span></span><span class="sig-name descname"><span class="pre">Workspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reducedim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>SCoT Workspace</p>
<p>This class provides high-level functionality for source identification, connectivity estimation, and visualization.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>var</strong><span class="classifier">{<code class="xref py py-class docutils literal notranslate"><span class="pre">VARBase</span></code>-like object, dict}</span></dt><dd><p>Vector autoregressive model (VAR) object that is used for model fitting.
This can also be a dictionary that is passed as <cite>**kwargs</cite> to backend[‘var’]() in order to
construct a new VAR model object.</p>
</dd>
<dt><strong>locations</strong><span class="classifier">array_like, optional</span></dt><dd><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</dd>
<dt><strong>reducedim</strong><span class="classifier">{int, float, ‘no_pca’}, optional</span></dt><dd><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer number of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to ‘no_pca’ the PCA step is skipped.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequency bins for connectivity estimation.</p>
</dd>
<dt><strong>backend</strong><span class="classifier">dict-like, optional</span></dt><dd><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>`unmixing_`</strong><span class="classifier">array</span></dt><dd><p>Estimated unmixing matrix.</p>
</dd>
<dt><strong>`mixing_`</strong><span class="classifier">array</span></dt><dd><p>Estimated mixing matrix.</p>
</dd>
<dt><strong>`plot_diagonal`</strong><span class="classifier">str</span></dt><dd><p>Configures what is plotted in the diagonal subplots.
<strong>‘topo’</strong> (default) plots topoplots on the diagonal,
<strong>‘S’</strong> plots the spectral density of each component, and
<strong>‘fill’</strong> plots connectivity on the diagonal.</p>
</dd>
<dt><strong>`plot_outside_topo`</strong><span class="classifier">bool</span></dt><dd><p>Whether to place topoplots in the left column and top row.</p>
</dd>
<dt><strong>`plot_f_range`</strong><span class="classifier">(int, int)</span></dt><dd><p>Lower and upper frequency limits for plotting. Defaults to [0, fs/2].</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.compare_conditions">
<span class="sig-name descname"><span class="pre">compare_conditions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.compare_conditions" title="Link to this definition">¶</a></dt>
<dd><p>Test for significant difference in connectivity of two sets of class labels.</p>
<p>Connectivity estimates are obtained by bootstrapping. Correction for multiple testing is performed by
controlling the false discovery rate (FDR).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels1, labels2</strong><span class="classifier">list of class labels</span></dt><dd><p>The two sets of class labels to compare. Each set may contain more than one label.</p>
</dd>
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum allowed FDR. The ratio of falsely detected significant differences is guaranteed to be less than
<cite>alpha</cite>.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>How many bootstrap estimates to take.</p>
</dd>
<dt><strong>num_samples</strong><span class="classifier">int, optional</span></dt><dd><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</dd>
<dt><strong>plot</strong><span class="classifier">{False, None, Figure object}, optional</span></dt><dd><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p</strong><span class="classifier">array, shape = [n_channels, n_channels, nfft]</span></dt><dd><p>Uncorrected p-values.</p>
</dd>
<dt><strong>s</strong><span class="classifier">array, dtype=bool, shape = [n_channels, n_channels, nfft]</span></dt><dd><p>FDR corrected significance. True means the difference is significant in this location.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.do_cspvarica">
<span class="sig-name descname"><span class="pre">do_cspvarica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varfit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ensemble'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.do_cspvarica" title="Link to this definition">¶</a></dt>
<dd><p>Perform CSPVARICA</p>
<p>Perform CSPVARICA source decomposition and VAR model fitting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>varfit</strong><span class="classifier">string</span></dt><dd><p>Determines how to calculate the residuals for source decomposition.
‘ensemble’ (default) fits one model to the whole data set,
‘class’ fits a different model for each class, and
‘trial’ fits a different model for each individual trial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">cspvarica()</span></code></dt><dd><p>CSPVARICA implementation</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.do_ica">
<span class="sig-name descname"><span class="pre">do_ica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.do_ica" title="Link to this definition">¶</a></dt>
<dd><p>Perform ICA</p>
<p>Perform plain ICA source decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.do_mvarica">
<span class="sig-name descname"><span class="pre">do_mvarica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varfit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ensemble'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.do_mvarica" title="Link to this definition">¶</a></dt>
<dd><p>Perform MVARICA</p>
<p>Perform MVARICA source decomposition and VAR model fitting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>varfit</strong><span class="classifier">string</span></dt><dd><p>Determines how to calculate the residuals for source decomposition.
‘ensemble’ (default) fits one model to the whole data set,
‘class’ fits a different model for each class, and
‘trial’ fits a different model for each individual trial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">mvarica()</span></code></dt><dd><p>MVARICA implementation</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.fit_var">
<span class="sig-name descname"><span class="pre">fit_var</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.fit_var" title="Link to this definition">¶</a></dt>
<dd><p>Fit a VAR model to the source activations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain source activations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.get_bootstrap_connectivity">
<span class="sig-name descname"><span class="pre">get_bootstrap_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.get_bootstrap_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate bootstrap estimates of spectral connectivity measures.</p>
<p>Bootstrapping is performed on trial level.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_names</strong><span class="classifier">{str, list of str}</span></dt><dd><p>Name(s) of the connectivity measure(s) to calculate. See <code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>How many bootstrap estimates to take.</p>
</dd>
<dt><strong>num_samples</strong><span class="classifier">int, optional</span></dt><dd><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>measure</strong><span class="classifier">array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</span></dt><dd><p>Values of the connectivity measure for each bootstrap estimate. If <cite>measure_names</cite> is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are
ndarrays of shape [<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#scot.connectivity_statistics.bootstrap_connectivity" title="scot.connectivity_statistics.bootstrap_connectivity"><code class="xref py py-func docutils literal notranslate"><span class="pre">scot.connectivity_statistics.bootstrap_connectivity()</span></code></a></dt><dd><p>Calculates bootstrap connectivity</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.get_connectivity">
<span class="sig-name descname"><span class="pre">get_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.get_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>plot</strong><span class="classifier">{False, None, Figure object}, optional</span></dt><dd><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">array, shape = [n_channels, n_channels, nfft]</span></dt><dd><p>Values of the connectivity measure.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain a fitted VAR model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.get_surrogate_connectivity">
<span class="sig-name descname"><span class="pre">get_surrogate_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.get_surrogate_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>How many surrogate samples to take.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>measure</strong><span class="classifier">array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</span></dt><dd><p>Values of the connectivity measure for each surrogate.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#scot.connectivity_statistics.surrogate_connectivity" title="scot.connectivity_statistics.surrogate_connectivity"><code class="xref py py-func docutils literal notranslate"><span class="pre">scot.connectivity_statistics.surrogate_connectivity()</span></code></a></dt><dd><p>Calculates surrogate connectivity</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.get_tf_connectivity">
<span class="sig-name descname"><span class="pre">get_tf_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winlen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winstep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.get_tf_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate estimate of time-varying connectivity.</p>
<p>Connectivity is estimated in a sliding window approach on the current data set. The window is stepped
<cite>n_steps</cite> = (<cite>n_samples</cite> - <cite>winlen</cite>) // <cite>winstep</cite> times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>winlen</strong><span class="classifier">int</span></dt><dd><p>Length of the sliding window (in samples).</p>
</dd>
<dt><strong>winstep</strong><span class="classifier">int</span></dt><dd><p>Step size for sliding window (in samples).</p>
</dd>
<dt><strong>plot</strong><span class="classifier">{False, None, Figure object}, optional</span></dt><dd><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</dd>
<dt><strong>baseline</strong><span class="classifier">[int, int] or None</span></dt><dd><p>Start and end of the baseline period in samples. The baseline is subtracted from the connectivity. It is
computed as the average of all windows that contain start or end, or fall between start and end.
If set to None no baseline is subtracted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">array, shape = [n_channels, n_channels, nfft, n_steps]</span></dt><dd><p>Values of the connectivity measure.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain a fitted VAR model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.keep_sources">
<span class="sig-name descname"><span class="pre">keep_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.keep_sources" title="Link to this definition">¶</a></dt>
<dd><p>Keep only the specified sources in the decomposition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.optimize_var">
<span class="sig-name descname"><span class="pre">optimize_var</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.optimize_var" title="Link to this definition">¶</a></dt>
<dd><p>Optimize the VAR model’s hyperparameters (such as regularization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain source activations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.plot_connectivity_surrogate">
<span class="sig-name descname"><span class="pre">plot_connectivity_surrogate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.plot_connectivity_surrogate" title="Link to this definition">¶</a></dt>
<dd><p>Plot spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code> for supported measures.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>How many surrogate samples to take.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">{None, Figure object}, optional</span></dt><dd><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>Instance of the figure in which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.plot_connectivity_topos">
<span class="sig-name descname"><span class="pre">plot_connectivity_topos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.plot_connectivity_topos" title="Link to this definition">¶</a></dt>
<dd><p>Plot scalp projections of the sources.</p>
<p>This function only plots the topos. Use in combination with connectivity plotting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">{None, Figure object}, optional</span></dt><dd><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>Instance of the figure in which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.plot_source_topos">
<span class="sig-name descname"><span class="pre">plot_source_topos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">common_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.plot_source_topos" title="Link to this definition">¶</a></dt>
<dd><p>Plot topography of the Source decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>common_scale</strong><span class="classifier">float, optional</span></dt><dd><p>If set to None, each topoplot’s color axis is scaled individually. Otherwise specifies the percentile
(1-99) of values in all plot. This value is taken as the maximum color scale.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.plotting">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plotting</span></span><a class="headerlink" href="#scot.ooapi.Workspace.plotting" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.remove_sources">
<span class="sig-name descname"><span class="pre">remove_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.remove_sources" title="Link to this definition">¶</a></dt>
<dd><p>Remove sources from the decomposition.</p>
<p>This function removes sources from the decomposition. Doing so invalidates currently fitted VAR models and
connectivity estimates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sources</strong><span class="classifier">{slice, int, array of ints}</span></dt><dd><p>Indices of components to remove.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain a source decomposition.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.set_data" title="Link to this definition">¶</a></dt>
<dd><p>Assign data to the workspace.</p>
<p>This function assigns a new data set to the workspace. Doing so invalidates currently fitted VAR models,
connectivity estimates, and activations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</span></dt><dd><p>EEG data set</p>
</dd>
<dt><strong>cl</strong><span class="classifier">list of valid dict keys</span></dt><dd><p>Class labels associated with each trial.</p>
</dd>
<dt><strong>time_offset</strong><span class="classifier">float, optional</span></dt><dd><p>Trial starting time; used for labelling the x-axis of time/frequency plots.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.set_locations">
<span class="sig-name descname"><span class="pre">set_locations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">locations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.set_locations" title="Link to this definition">¶</a></dt>
<dd><p>Set sensor locations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>locations</strong><span class="classifier">array_like</span></dt><dd><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.set_premixing">
<span class="sig-name descname"><span class="pre">set_premixing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">premixing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.set_premixing" title="Link to this definition">¶</a></dt>
<dd><p>Set premixing matrix.</p>
<p>The premixing matrix maps data to physical channels. If the data is actual channel data,
the premixing matrix can be set to identity. Use this functionality if the data was pre-
transformed with e.g. PCA.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>premixing</strong><span class="classifier">array_like, shape = [n_signals, n_channels]</span></dt><dd><p>Matrix that maps data signals to physical channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.set_used_labels">
<span class="sig-name descname"><span class="pre">set_used_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.set_used_labels" title="Link to this definition">¶</a></dt>
<dd><p>Specify which trials to use in subsequent analysis steps.</p>
<p>This function masks trials based on their class labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">list of class labels</span></dt><dd><p>Marks all trials that have a label that is in the <cite>labels</cite> list for further processing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.ooapi.Workspace.show_plots">
<span class="sig-name descname"><span class="pre">show_plots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.ooapi.Workspace.show_plots" title="Link to this definition">¶</a></dt>
<dd><p>Show current plots.</p>
<p>This is only a convenience wrapper around <code class="xref py py-func docutils literal notranslate"><span class="pre">matplotlib.pyplot.show_plots()</span></code>.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-scot.parallel">
<span id="scot-parallel-module"></span><h2>scot.parallel module<a class="headerlink" href="#module-scot.parallel" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="scot.parallel.parallel_loop">
<span class="sig-prename descclassname"><span class="pre">scot.parallel.</span></span><span class="sig-name descname"><span class="pre">parallel_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.parallel.parallel_loop" title="Link to this definition">¶</a></dt>
<dd><p>run loops in parallel, if joblib is available.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>function to be executed in parallel</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int | None</span></dt><dd><p>Number of jobs. If set to None, do not attempt to use joblib.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">int</span></dt><dd><p>verbosity level</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Execution of the main script must be guarded with <cite>if __name__ == ‘__main__’:</cite> when using parallelization.</p>
</dd></dl>

</section>
<section id="module-scot.pca">
<span id="scot-pca-module"></span><h2>scot.pca module<a class="headerlink" href="#module-scot.pca" title="Link to this heading">¶</a></h2>
<p>Principal component analysis (PCA) implementation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.pca.pca">
<span class="sig-prename descclassname"><span class="pre">scot.pca.</span></span><span class="sig-name descname"><span class="pre">pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subtract_mean=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_components=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reducedim=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm=&lt;function</span> <span class="pre">pca_eig&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.pca.pca" title="Link to this definition">¶</a></dt>
<dd><p>Calculate principal component analysis (PCA).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray, shape (trials, channels, samples) or (channels, samples)</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>subtract_mean</strong><span class="classifier">bool, optional</span></dt><dd><p>Subtract sample mean from x.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>Normalize variances before applying PCA.</p>
</dd>
<dt><strong>sort_components</strong><span class="classifier">bool, optional</span></dt><dd><p>Sort principal components in order of decreasing eigenvalues.</p>
</dd>
<dt><strong>reducedim</strong><span class="classifier">float or int or None, optional</span></dt><dd><p>A value less than 1 is interpreted as the fraction of variance that
should be retained in the data. All components that account for less
than <cite>1 - reducedim</cite> of the variance are removed.
An integer value of 1 or greater is interpreted as the number of
(sorted) components to retain.
If None, do not reduce dimensionality (i.e. keep all components).</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier">func, optional</span></dt><dd><p>Function to use for eigenvalue decomposition
(<a class="reference internal" href="#scot.pca.pca_eig" title="scot.pca.pca_eig"><code class="xref py py-func docutils literal notranslate"><span class="pre">pca_eig()</span></code></a> or <a class="reference internal" href="#scot.pca.pca_svd" title="scot.pca.pca_svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">pca_svd()</span></code></a>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray, shape (channels, components)</span></dt><dd><p>PCA transformation matrix.</p>
</dd>
<dt><strong>v</strong><span class="classifier">ndarray, shape (components, channels)</span></dt><dd><p>Inverse PCA transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.pca.pca_eig">
<span class="sig-prename descclassname"><span class="pre">scot.pca.</span></span><span class="sig-name descname"><span class="pre">pca_eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.pca.pca_eig" title="Link to this definition">¶</a></dt>
<dd><p>Calculate PCA using eigenvalue decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray, shape (channels, samples)</span></dt><dd><p>Two-dimensional input data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray, shape (channels, channels)</span></dt><dd><p>Eigenvectors (principal components) (in columns).</p>
</dd>
<dt><strong>s</strong><span class="classifier">ndarray, shape (channels,)</span></dt><dd><p>Eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.pca.pca_svd">
<span class="sig-prename descclassname"><span class="pre">scot.pca.</span></span><span class="sig-name descname"><span class="pre">pca_svd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.pca.pca_svd" title="Link to this definition">¶</a></dt>
<dd><p>Calculate PCA using SVD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">ndarray, shape (channels, samples)</span></dt><dd><p>Two-dimensional input data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray, shape (channels, channels)</span></dt><dd><p>Eigenvectors (principal components) (in columns).</p>
</dd>
<dt><strong>s</strong><span class="classifier">ndarray, shape (channels,)</span></dt><dd><p>Eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-scot.plainica">
<span id="scot-plainica-module"></span><h2>scot.plainica module<a class="headerlink" href="#module-scot.plainica" title="Link to this heading">¶</a></h2>
<p>Source decomposition with ICA.</p>
<dl class="py class">
<dt class="sig sig-object py" id="scot.plainica.ResultICA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.plainica.</span></span><span class="sig-name descname"><span class="pre">ResultICA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ux</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plainica.ResultICA" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Result of <a class="reference internal" href="#scot.plainica.plainica" title="scot.plainica.plainica"><code class="xref py py-func docutils literal notranslate"><span class="pre">plainica()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>`mixing`</strong><span class="classifier">array</span></dt><dd><p>estimate of the mixing matrix</p>
</dd>
<dt><strong>`unmixing`</strong><span class="classifier">array</span></dt><dd><p>estimate of the unmixing matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plainica.plainica">
<span class="sig-prename descclassname"><span class="pre">scot.plainica.</span></span><span class="sig-name descname"><span class="pre">plainica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reducedim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plainica.plainica" title="Link to this definition">¶</a></dt>
<dd><p>Source decomposition with ICA.</p>
<p>Apply ICA to the data x, with optional PCA dimensionality reduction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array, shape (n_trials, n_channels, n_samples) or (n_channels, n_samples)</span></dt><dd><p>data set</p>
</dd>
<dt><strong>reducedim</strong><span class="classifier">{int, float, ‘no_pca’}, optional</span></dt><dd><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer numer of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to ‘no_pca’ the PCA step is skipped.</p>
</dd>
<dt><strong>backend</strong><span class="classifier">dict-like, optional</span></dt><dd><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ResultICA</span></dt><dd><p>Source decomposition</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-scot.plotting">
<span id="scot-plotting-module"></span><h2>scot.plotting module<a class="headerlink" href="#module-scot.plotting" title="Link to this heading">¶</a></h2>
<p>Graphical output with matplotlib.</p>
<p>This module attempts to import matplotlib for plotting functionality.
If matplotlib is not available no error is raised, but plotting functions will not be available.</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.MaxNLocator">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">MaxNLocator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.MaxNLocator" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.current_axis">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">current_axis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.current_axis" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.new_figure">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">new_figure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.new_figure" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.plot_circular">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_circular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">widths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curviness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topomaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_circular" title="Link to this definition">¶</a></dt>
<dd><p>Circluar connectivity plot.</p>
<p>Topos are arranged in a circle, with arrows indicating connectivity</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>widths</strong><span class="classifier">float or array, shape (n_channels, n_channels)</span></dt><dd><p>Width of each arrow. Can be a scalar to assign the same width to all arrows.</p>
</dd>
<dt><strong>colors</strong><span class="classifier">array, shape (n_channels, n_channels, 3) or (3)</span></dt><dd><p>RGB color values for each arrow or one RGB color value for all arrows.</p>
</dd>
<dt><strong>curviness</strong><span class="classifier">float, optional</span></dt><dd><p>Factor that determines how much arrows tend to deviate from a straight line.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array, dtype = bool, shape (n_channels, n_channels)</span></dt><dd><p>Enable or disable individual arrows</p>
</dd>
<dt><strong>topo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topoplot</span></code></span></dt><dd><p>This object draws the topo plot</p>
</dd>
<dt><strong>topomaps</strong><span class="classifier">array, shape = [w_pixels, h_pixels]</span></dt><dd><p>Scalp-projected map</p>
</dd>
<dt><strong>axes</strong><span class="classifier">axis, optional</span></dt><dd><p>Axis to draw into. A new figure is created by default.</p>
</dd>
<dt><strong>order</strong><span class="classifier">list of int</span></dt><dd><p>Rearrange channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>axes</strong><span class="classifier">Axes object</span></dt><dd><p>The axes into which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.plot_connectivity_significance">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_connectivity_significance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(-inf,</span> <span class="pre">inf)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_connectivity_significance" title="Link to this definition">¶</a></dt>
<dd><p>Plot significance.</p>
<p>Significance is drawn as a background image where dark vertical stripes indicate freuquencies where a evaluates to
True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array, shape (n_channels, n_channels, n_fft), dtype bool</span></dt><dd><p>Significance</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float</span></dt><dd><p>Sampling frequency</p>
</dd>
<dt><strong>freq_range</strong><span class="classifier">(float, float)</span></dt><dd><p>Frequency range to plot</p>
</dd>
<dt><strong>diagonal</strong><span class="classifier">{-1, 0, 1}</span></dt><dd><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</dd>
<dt><strong>border</strong><span class="classifier">bool</span></dt><dd><p>If border == true the leftmost column and the topmost row are left blank</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>The figure into which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.plot_connectivity_spectrum">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_connectivity_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(-inf,</span> <span class="pre">inf)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_connectivity_spectrum" title="Link to this definition">¶</a></dt>
<dd><p>Draw connectivity plots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array, shape (n_channels, n_channels, n_fft) or (1 or 3, n_channels, n_channels, n_fft)</span></dt><dd><p>If a.ndim == 3, normal plots are created,
If a.ndim == 4 and a.shape[0] == 1, the area between the curve and y=0 is filled transparently,
If a.ndim == 4 and a.shape[0] == 3, a[0,:,:,:] is plotted normally and the area between a[1,:,:,:] and
a[2,:,:,:] is filled transparently.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float</span></dt><dd><p>Sampling frequency</p>
</dd>
<dt><strong>freq_range</strong><span class="classifier">(float, float)</span></dt><dd><p>Frequency range to plot</p>
</dd>
<dt><strong>diagonal</strong><span class="classifier">{-1, 0, 1}</span></dt><dd><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</dd>
<dt><strong>border</strong><span class="classifier">bool</span></dt><dd><p>If border == true the leftmost column and the topmost row are left blank</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>The figure into which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.plot_connectivity_timespectrum">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_connectivity_timespectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(-inf,</span> <span class="pre">inf)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_connectivity_timespectrum" title="Link to this definition">¶</a></dt>
<dd><p>Draw time/frequency connectivity plots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array, shape (n_channels, n_channels, n_fft, n_timesteps)</span></dt><dd><p>Values to draw</p>
</dd>
<dt><strong>fs</strong><span class="classifier">float</span></dt><dd><p>Sampling frequency</p>
</dd>
<dt><strong>crange</strong><span class="classifier">[int, int], optional</span></dt><dd><p>Range of values covered by the colormap.
If set to None, [min(a), max(a)] is substituted.</p>
</dd>
<dt><strong>freq_range</strong><span class="classifier">(float, float)</span></dt><dd><p>Frequency range to plot</p>
</dd>
<dt><strong>time_range</strong><span class="classifier">(float, float)</span></dt><dd><p>Time range covered by <cite>a</cite></p>
</dd>
<dt><strong>diagonal</strong><span class="classifier">{-1, 0, 1}</span></dt><dd><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</dd>
<dt><strong>border</strong><span class="classifier">bool</span></dt><dd><p>If border == true the leftmost column and the topmost row are left blank</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>The figure into which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.plot_connectivity_topos">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_connectivity_topos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'diagonal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topomaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_connectivity_topos" title="Link to this definition">¶</a></dt>
<dd><p>Place topo plots in a figure suitable for connectivity visualization.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <cite>topo</cite> is modified by the function by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">set_map()</span></code>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>layout</strong><span class="classifier">str</span></dt><dd><p>‘diagonal’ -&gt; place topo plots on diagonal.
otherwise -&gt; place topo plots in left column and top row.</p>
</dd>
<dt><strong>topo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topoplot</span></code></span></dt><dd><p>This object draws the topo plot</p>
</dd>
<dt><strong>topomaps</strong><span class="classifier">array, shape = [w_pixels, h_pixels]</span></dt><dd><p>Scalp-projected map</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>The figure into which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.plot_sources">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mixmaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unmixmaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_sources" title="Link to this definition">¶</a></dt>
<dd><p>Plot all scalp projections of mixing- and unmixing-maps.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <cite>topo</cite> is modified by the function by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">set_map()</span></code>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>topo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topoplot</span></code></span></dt><dd><p>This object draws the topo plot</p>
</dd>
<dt><strong>mixmaps</strong><span class="classifier">array, shape = [w_pixels, h_pixels]</span></dt><dd><p>Scalp-projected mixing matrix</p>
</dd>
<dt><strong>unmixmaps</strong><span class="classifier">array, shape = [w_pixels, h_pixels]</span></dt><dd><p>Scalp-projected unmixing matrix</p>
</dd>
<dt><strong>global_scale</strong><span class="classifier">float, optional</span></dt><dd><p>Set common color scale as given percentile of all map values to use as the maximum.
<cite>None</cite> scales each plot individually (default).</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>The figure into which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.plot_topo">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_topo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topomap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_locations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_head</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_topo" title="Link to this definition">¶</a></dt>
<dd><p>Draw a topoplot in given axis.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <cite>topo</cite> is modified by the function by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">set_map()</span></code>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">axis</span></dt><dd><p>Axis to draw into.</p>
</dd>
<dt><strong>topo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topoplot</span></code></span></dt><dd><p>This object draws the topo plot</p>
</dd>
<dt><strong>topomap</strong><span class="classifier">array, shape = [w_pixels, h_pixels]</span></dt><dd><p>Scalp-projected data</p>
</dd>
<dt><strong>crange</strong><span class="classifier">[int, int], optional</span></dt><dd><p>Range of values covered by the colormap.
If set to None, [-max(abs(topomap)), max(abs(topomap))] is substituted.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">[float, float], optional</span></dt><dd><p>Shift the topo plot by [x,y] in axis units.</p>
</dd>
<dt><strong>plot_locations</strong><span class="classifier">bool, optional</span></dt><dd><p>Plot electrode locations.</p>
</dd>
<dt><strong>plot_head</strong><span class="classifier">bool, optional</span></dt><dd><p>Plot head cartoon.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h</strong><span class="classifier">image</span></dt><dd><p>Image object the map was plotted into</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.plot_whiteness">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_whiteness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.plot_whiteness" title="Link to this definition">¶</a></dt>
<dd><p>Draw distribution of the Portmanteu whiteness test.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>var</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VARBase</span></code>-like object</span></dt><dd><p>Vector autoregressive model (VAR) object whose residuals are tested for whiteness.</p>
</dd>
<dt><strong>h</strong><span class="classifier">int</span></dt><dd><p>Maximum lag to include in the test.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>Number of surrogate estimates to draw under the null hypothesis.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">axis, optional</span></dt><dd><p>Axis to draw into. By default draws into <code class="xref py py-func docutils literal notranslate"><span class="pre">matplotlib.pyplot.gca()</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pr</strong><span class="classifier">float</span></dt><dd><p><em>p</em>-value of whiteness under the null hypothesis</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.prepare_topoplots">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">prepare_topoplots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.prepare_topoplots" title="Link to this definition">¶</a></dt>
<dd><p>Prepare multiple topo maps for cached plotting.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameter <cite>topo</cite> is modified by the function by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">set_values()</span></code>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>topo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topoplot</span></code></span></dt><dd><p>Scalp maps are created with this class</p>
</dd>
<dt><strong>values</strong><span class="classifier">array, shape = [n_topos, n_channels]</span></dt><dd><p>Channel values for each topo plot</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>topomaps</strong><span class="classifier">list of array</span></dt><dd><p>The map for each topo plot</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.plotting.show_plots">
<span class="sig-prename descclassname"><span class="pre">scot.plotting.</span></span><span class="sig-name descname"><span class="pre">show_plots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.plotting.show_plots" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-scot.utils">
<span id="scot-utils-module"></span><h2>scot.utils module<a class="headerlink" href="#module-scot.utils" title="Link to this heading">¶</a></h2>
<p>Utility functions</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.utils.cartesian">
<span class="sig-prename descclassname"><span class="pre">scot.utils.</span></span><span class="sig-name descname"><span class="pre">cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arrays</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.utils.cartesian" title="Link to this definition">¶</a></dt>
<dd><p>Generate a cartesian product of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arrays</strong><span class="classifier">list of array-like</span></dt><dd><p>1-D arrays to form the cartesian product of.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array to place the cartesian product in.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>2-D array of shape (M, len(arrays)) containing cartesian products
formed of input arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p><a class="reference external" href="http://stackoverflow.com/a/1235363/3005167">http://stackoverflow.com/a/1235363/3005167</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cartesian</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">array([[1, 4, 6],</span>
<span class="go">       [1, 4, 7],</span>
<span class="go">       [1, 5, 6],</span>
<span class="go">       [1, 5, 7],</span>
<span class="go">       [2, 4, 6],</span>
<span class="go">       [2, 4, 7],</span>
<span class="go">       [2, 5, 6],</span>
<span class="go">       [2, 5, 7],</span>
<span class="go">       [3, 4, 6],</span>
<span class="go">       [3, 4, 7],</span>
<span class="go">       [3, 5, 6],</span>
<span class="go">       [3, 5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.utils.check_random_state">
<span class="sig-prename descclassname"><span class="pre">scot.utils.</span></span><span class="sig-name descname"><span class="pre">check_random_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.utils.check_random_state" title="Link to this definition">¶</a></dt>
<dd><p>Turn seed into a np.random.RandomState instance.</p>
<p>If seed is None, return the RandomState singleton used by np.random.
If seed is an int, return a new RandomState instance seeded with seed.
If seed is already a RandomState instance, return it.
Otherwise raise ValueError.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.utils.cuthill_mckee">
<span class="sig-prename descclassname"><span class="pre">scot.utils.</span></span><span class="sig-name descname"><span class="pre">cuthill_mckee</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.utils.cuthill_mckee" title="Link to this definition">¶</a></dt>
<dd><p>Implementation of the Cuthill-McKee algorithm.</p>
<p>Permute a symmetric binary matrix into a band matrix form with a small bandwidth.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">ndarray, dtype=bool, shape = [n, n]</span></dt><dd><p>The matrix is internally converted to a symmetric matrix by setting each element [i,j] to True if either
[i,j] or [j,i] evaluates to true.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>order</strong><span class="classifier">list of int</span></dt><dd><p>Permutation intices</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">cuthill_mckee</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[0, 0, 1, 1],</span>
<span class="go">       [0, 0, 0, 0],</span>
<span class="go">       [1, 0, 1, 0],</span>
<span class="go">       [1, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,:][:,</span><span class="n">p</span><span class="p">]</span>
<span class="go">array([[0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 1],</span>
<span class="go">       [0, 0, 1, 1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="scot.utils.memoize">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.utils.</span></span><span class="sig-name descname"><span class="pre">memoize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.utils.memoize" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Cache the return value of a method.</p>
<p>This class is meant to be used as a decorator of methods. The return value
from a given method invocation will be cached on the instance whose method
was invoked. All arguments passed to a method decorated with memoize must
be hashable.</p>
<p>If a memoized method is invoked directly on its class the result will not
be cached. Instead the method will be invoked like a static method:</p>
</dd></dl>

</section>
<section id="module-scot.var">
<span id="scot-var-module"></span><h2>scot.var module<a class="headerlink" href="#module-scot.var" title="Link to this heading">¶</a></h2>
<p>Vector autoregressive (VAR) model implementation.</p>
<dl class="py class">
<dt class="sig sig-object py" id="scot.var.VAR">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.var.</span></span><span class="sig-name descname"><span class="pre">VAR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvschema=&lt;function</span> <span class="pre">multitrial&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#scot.varbase.VARBase" title="scot.varbase.VARBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">VARBase</span></code></a></p>
<p>Builtin VAR implementation.</p>
<p>This class provides least squares VAR model fitting with optional ridge
regression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_order</strong><span class="classifier">int</span></dt><dd><p>Autoregressive model order.</p>
</dd>
<dt><strong>delta</strong><span class="classifier">float, optional</span></dt><dd><p>Ridge penalty parameter.</p>
</dd>
<dt><strong>xvschema</strong><span class="classifier">func, optional</span></dt><dd><p>Function that creates training and test sets for cross-validation. The
function takes two parameters: the current cross-validation run (int)
and the number of trials (int). It returns a tuple of two arrays: the
training set and the testing set.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int | None, optional</span></dt><dd><p>Number of jobs to run in parallel for various tasks (e.g. whiteness
testing). If set to None, joblib is not used at all. Note that the main
script must be guarded with <cite>if __name__ == ‘__main__’:</cite> when using
parallelization.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool | None, optional</span></dt><dd><p>Whether to print information to stdout. The default is None, which
means the verbosity setting from the global configuration is used.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="scot.var.VAR.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR.fit" title="Link to this definition">¶</a></dt>
<dd><p>Fit VAR model to data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (trials, channels, samples) or (channels, samples)</span></dt><dd><p>Epoched or continuous data set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>self</strong><span class="classifier"><a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code></a> object to facilitate method chaining (see usage
example).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.var.VAR.optimize">
<span class="sig-name descname"><span class="pre">optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skipstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR.optimize" title="Link to this definition">¶</a></dt>
<dd><p>Find optimal ridge penalty with bisection search.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (n_trials, n_channels, n_samples)</span></dt><dd><p>Epoched data set. At least two trials are required.</p>
</dd>
<dt><strong>skipstep</strong><span class="classifier">int, optional</span></dt><dd><p>Speed up calculation by skipping samples during cost function
calculation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>self</strong><span class="classifier"><a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code></a> object to facilitate method chaining (see usage
example).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.var.VAR.optimize_delta_bisection">
<span class="sig-name descname"><span class="pre">optimize_delta_bisection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skipstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR.optimize_delta_bisection" title="Link to this definition">¶</a></dt>
<dd><p>Find optimal ridge penalty with bisection search.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (n_trials, n_channels, n_samples)</span></dt><dd><p>Epoched data set. At least two trials are required.</p>
</dd>
<dt><strong>skipstep</strong><span class="classifier">int, optional</span></dt><dd><p>Speed up calculation by skipping samples during cost function
calculation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>self</strong><span class="classifier"><a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code></a></span></dt><dd><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code></a> object to facilitate method chaining (see usage
example).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.var.VAR.optimize_order">
<span class="sig-name descname"><span class="pre">optimize_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.var.VAR.optimize_order" title="Link to this definition">¶</a></dt>
<dd><p>Determine optimal model order by minimizing the mean squared
generalization error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (n_trials, n_channels, n_samples)</span></dt><dd><p>Epoched data set on which to optimize the model order. At least two
trials are required.</p>
</dd>
<dt><strong>min_p</strong><span class="classifier">int</span></dt><dd><p>Minimal model order to check.</p>
</dd>
<dt><strong>max_p</strong><span class="classifier">int</span></dt><dd><p>Maximum model order to check</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-scot.varbase">
<span id="scot-varbase-module"></span><h2>scot.varbase module<a class="headerlink" href="#module-scot.varbase" title="Link to this heading">¶</a></h2>
<p>Vector autoregressive (VAR) model.</p>
<dl class="py class">
<dt class="sig sig-object py" id="scot.varbase.Defaults">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.varbase.</span></span><span class="sig-name descname"><span class="pre">Defaults</span></span><a class="headerlink" href="#scot.varbase.Defaults" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.Defaults.xvschema">
<span class="sig-name descname"><span class="pre">xvschema</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">skipstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.Defaults.xvschema" title="Link to this definition">¶</a></dt>
<dd><p>Multi-trial cross-validation schema</p>
<p>Use one trial for testing, all others for training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_trials</strong><span class="classifier">int</span></dt><dd><p>Total number of trials</p>
</dd>
<dt><strong>skipstep</strong><span class="classifier">int</span></dt><dd><p>only use every <cite>skipstep</cite> trial for testing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gen</strong><span class="classifier">generator object</span></dt><dd><p>the generator returns tuples (trainset, testset)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="scot.varbase.VARBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.varbase.</span></span><span class="sig-name descname"><span class="pre">VARBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a vector autoregressive (VAR) model.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><cite>VARBase</cite> is an abstract class that defines the interface for</p>
</div>
<p>VAR model implementations. Several methods must be implemented by derived
classes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model_order</strong><span class="classifier">int</span></dt><dd><p>Autoregressive model order.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int | None, optional</span></dt><dd><p>Number of jobs to run in parallel for various tasks (e.g. whiteness
testing). If set to None, joblib is not used at all. Note that the main
script must be guarded with <cite>if __name__ == ‘__main__’:</cite> when using
parallelization.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool | None, optional</span></dt><dd><p>Whether to print information to stdout. The default is None, which
means the verbosity setting from the global configuration is used.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><em>b</em> is of shape [m, m*p], with sub matrices arranged as follows:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>b_00</p></td>
<td><p>b_01</p></td>
<td><p>…</p></td>
<td><p>b_0m</p></td>
</tr>
<tr class="row-even"><td><p>b_10</p></td>
<td><p>b_11</p></td>
<td><p>…</p></td>
<td><p>b_1m</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>b_m0</p></td>
<td><p>b_m1</p></td>
<td><p>…</p></td>
<td><p>b_mm</p></td>
</tr>
</tbody>
</table>
<p>Each sub matrix b_ij is a column vector of length p that contains the
filter coefficients from channel j (source) to channel i (sink).</p>
<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.VARBase.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.copy" title="Link to this definition">¶</a></dt>
<dd><p>Create a copy of the VAR model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.VARBase.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.fit" title="Link to this definition">¶</a></dt>
<dd><p>Fit VAR model to data.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function must be implemented by derived classes.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (trials, channels, samples) or (channels, samples)</span></dt><dd><p>Epoched or continuous data set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>self</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code></span></dt><dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code> object to facilitate method chaining (see usage
example).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.VARBase.from_yw">
<span class="sig-name descname"><span class="pre">from_yw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">acms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.from_yw" title="Link to this definition">¶</a></dt>
<dd><p>Determine VAR model from autocorrelation matrices by solving the
Yule-Walker equations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>acms</strong><span class="classifier">array, shape (n_lags, n_channels, n_channels)</span></dt><dd><p>acms[l] contains the autocorrelation matrix at lag l. The highest
lag must equal the model order.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>self</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code></span></dt><dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">VAR</span></code> object to facilitate method chaining (see usage
example).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.VARBase.is_stable">
<span class="sig-name descname"><span class="pre">is_stable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.is_stable" title="Link to this definition">¶</a></dt>
<dd><p>Test if VAR model is stable.</p>
<p>This function tests stability of the VAR model as described in <a class="reference internal" href="#r452c2954e721-1" id="id8">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd><p>True if the model is stable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r452c2954e721-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">1</a><span class="fn-bracket">]</span></span>
<p>H. Lütkepohl, “New Introduction to Multiple Time Series
Analysis”, 2005, Springer, Berlin, Germany.</p>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.VARBase.optimize">
<span class="sig-name descname"><span class="pre">optimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.optimize" title="Link to this definition">¶</a></dt>
<dd><p>Optimize model fitting hyperparameters (e.g. regularization).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function must be implemented by derived classes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (trials, channels, samples) or (channels, samples)</span></dt><dd><p>Epoched or continuous data set.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.VARBase.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.predict" title="Link to this definition">¶</a></dt>
<dd><p>Predict samples on actual data.</p>
<p>The result of this function is used for calculating the residuals.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (trials, channels, samples) or (channels, samples)</span></dt><dd><p>Epoched or continuous data set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>predicted</strong><span class="classifier">array, shape <cite>data</cite>.shape</span></dt><dd><p>Data as predicted by the VAR model.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Residuals are obtained by r = x - var.predict(x)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.VARBase.simulate">
<span class="sig-name descname"><span class="pre">simulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisefunc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.simulate" title="Link to this definition">¶</a></dt>
<dd><p>Simulate vector autoregressive (VAR) model.</p>
<p>This function generates data from the VAR model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>l</strong><span class="classifier">int or [int, int]</span></dt><dd><p>Number of samples to generate. Can be a tuple or list, where l[0]
is the number of samples and l[1] is the number of trials.</p>
</dd>
<dt><strong>noisefunc</strong><span class="classifier">func, optional</span></dt><dd><p>This function is used to create the generating noise process. If
set to None, Gaussian white noise with zero mean and unit variance
is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (n_trials, n_samples, n_channels)</span></dt><dd><p>Generated data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.varbase.VARBase.test_whiteness">
<span class="sig-name descname"><span class="pre">test_whiteness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.VARBase.test_whiteness" title="Link to this definition">¶</a></dt>
<dd><p>Test if VAR model residuals are white (up to a lag of h).</p>
<p>This function calculates the Li-McLeod Portmanteau test statistic Q to
test against the null hypothesis H0 (the residuals are white) <a class="reference internal" href="#r3a472ddbb8ee-1" id="id10">[1]</a>.
Surrogate data for H0 is created by sampling from random permutations
of the residuals.</p>
<p>Usually, the returned p-value is compared against a pre-defined type I
error level of alpha=0.05 or alpha=0.01. If p&lt;=alpha, the hypothesis of
white residuals is rejected, which indicates that the VAR model does
not adequately describe the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>h</strong><span class="classifier">int</span></dt><dd><p>Maximum lag that is included in the test statistic.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>Number of samples to create under the null hypothesis.</p>
</dd>
<dt><strong>get_q</strong><span class="classifier">bool, optional</span></dt><dd><p>Return Q statistic along with p-value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>pr</strong><span class="classifier">float</span></dt><dd><p>Probability of observing a more extreme value of Q under the
assumption that H0 is true.</p>
</dd>
<dt><strong>q0</strong><span class="classifier">list of float, optional (<cite>get_q</cite>)</span></dt><dd><p>Individual surrogate estimates that were used for estimating the
distribution of Q under H0.</p>
</dd>
<dt><strong>q</strong><span class="classifier">float, optional (<cite>get_q</cite>)</span></dt><dd><p>Value of the Q statistic of the residuals</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>According to <a class="reference internal" href="#r3a472ddbb8ee-2" id="id11">[2]</a>, h must satisfy h = O(n^0.5), where n is the length
(time samples) of the residuals.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3a472ddbb8ee-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">1</a><span class="fn-bracket">]</span></span>
<p>H. Lütkepohl, “New Introduction to Multiple Time Series
Analysis”, 2005, Springer, Berlin, Germany.</p>
</div>
<div class="citation" id="r3a472ddbb8ee-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">2</a><span class="fn-bracket">]</span></span>
<p>J.R.M. Hosking, “The Multivariate Portmanteau Statistic”, 1980,
J. Am. Statist. Assoc.</p>
</div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.varbase.test_whiteness">
<span class="sig-prename descclassname"><span class="pre">scot.varbase.</span></span><span class="sig-name descname"><span class="pre">test_whiteness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varbase.test_whiteness" title="Link to this definition">¶</a></dt>
<dd><p>Test if signals are white (serially uncorrelated up to a lag of h).</p>
<p>This function calculates the Li-McLeod Portmanteau test statistic Q to test
against the null hypothesis H0 (the residuals are white) <a class="reference internal" href="#rb0dfaa547d44-1" id="id14">[1]</a>.
Surrogate data for H0 is created by sampling from random permutations of
the residuals.</p>
<p>Usually, the returned p-value is compared against a pre-defined type I
error level of alpha=0.05 or alpha=0.01. If p&lt;=alpha, the hypothesis of
white residuals is rejected, which indicates that the VAR model does not
adequately describe the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (trials, channels, samples) or (channels, samples)</span></dt><dd><p>Epoched or continuous data set.</p>
</dd>
<dt><strong>h</strong><span class="classifier">int</span></dt><dd><p>Maximum lag that is included in the test statistic.</p>
</dd>
<dt><strong>p</strong><span class="classifier">int, optional</span></dt><dd><p>Model order (if <cite>data</cite> are the residuals resulting from fitting a VAR
model).</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>Number of samples to create under the null hypothesis.</p>
</dd>
<dt><strong>get_q</strong><span class="classifier">bool, optional</span></dt><dd><p>Return Q statistic along with <em>p</em>-value</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int | None, optional</span></dt><dd><p>Number of jobs to run in parallel. If set to None, joblib is not used
at all. See <cite>joblib.Parallel</cite> for details.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">int</span></dt><dd><p>Verbosity level passed to joblib.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>pr</strong><span class="classifier">float</span></dt><dd><p>Probability of observing a more extreme value of Q under the assumption
that H0 is true.</p>
</dd>
<dt><strong>q0</strong><span class="classifier">list of float, optional (<cite>get_q</cite>)</span></dt><dd><p>Individual surrogate estimates that were used for estimating the
distribution of Q under H0.</p>
</dd>
<dt><strong>q</strong><span class="classifier">float, optional (<cite>get_q</cite>)</span></dt><dd><p>Value of the Q statistic of the residuals.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>According to <a class="reference internal" href="#rb0dfaa547d44-2" id="id15">[2]</a>, h must satisfy h = O(n^0.5), where n is the length (time
samples) of the residuals.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb0dfaa547d44-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">1</a><span class="fn-bracket">]</span></span>
<p>H. Lütkepohl, “New Introduction to Multiple Time Series Analysis”,
2005, Springer, Berlin, Germany.</p>
</div>
<div class="citation" id="rb0dfaa547d44-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">2</a><span class="fn-bracket">]</span></span>
<p>J.R.M. Hosking, “The Multivariate Portmanteau Statistic”, 1980, J.
Am. Statist. Assoc.</p>
</div>
</div>
</dd></dl>

</section>
<section id="module-scot.varica">
<span id="scot-varica-module"></span><h2>scot.varica module<a class="headerlink" href="#module-scot.varica" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="scot.varica.cspvarica">
<span class="sig-prename descclassname"><span class="pre">scot.varica.</span></span><span class="sig-name descname"><span class="pre">cspvarica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reducedim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize_var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">varfit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ensemble'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varica.cspvarica" title="Link to this definition">¶</a></dt>
<dd><p>Performs joint VAR model fitting and ICA source separation.</p>
<p>This function implements the CSPVARICA procedure <a class="reference internal" href="#r20b79c6e360b-1" id="id18">[1]</a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</span></dt><dd><p>data set</p>
</dd>
<dt><strong>var</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VARBase</span></code>-like object</span></dt><dd><p>Vector autoregressive model (VAR) object that is used for model fitting.</p>
</dd>
<dt><strong>cl</strong><span class="classifier">list of valid dict keys</span></dt><dd><p>Class labels associated with each trial.</p>
</dd>
<dt><strong>reducedim</strong><span class="classifier">{int}, optional</span></dt><dd><p>Number of (most discriminative) components to keep after applying the CSP.
If set to None, retain all components.</p>
</dd>
<dt><strong>optimize_var</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to call automatic optimization of the VAR fitting routine.</p>
</dd>
<dt><strong>backend</strong><span class="classifier">dict-like, optional</span></dt><dd><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</dd>
<dt><strong>varfit</strong><span class="classifier">string</span></dt><dd><p>Determines how to calculate the residuals for source decomposition.
‘ensemble’ (default) fits one model to the whole data set,
‘class’ fits a new model for each class, and
‘trial’ fits a new model for each individual trial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>Result</strong><span class="classifier">class</span></dt><dd><p>A class with the following attributes is returned:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>mixing</p></td>
<td><p>Source mixing matrix</p></td>
</tr>
<tr class="row-even"><td><p>unmixing</p></td>
<td><p>Source unmixing matrix</p></td>
</tr>
<tr class="row-odd"><td><p>residuals</p></td>
<td><p>Residuals of the VAR model(s) in source space</p></td>
</tr>
<tr class="row-even"><td><p>var_residuals</p></td>
<td><p>Residuals of the VAR model(s) in EEG space (before ICA)</p></td>
</tr>
<tr class="row-odd"><td><p>c</p></td>
<td><p>Noise covariance of the VAR model(s) in source space</p></td>
</tr>
<tr class="row-even"><td><p>b</p></td>
<td><p>VAR model coefficients (source space)</p></td>
</tr>
<tr class="row-odd"><td><p>a</p></td>
<td><p>VAR model coefficients (EEG space)</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>CSPVARICA is performed with the following steps:
1. Dimensionality reduction with CSP
2. Fitting a VAR model tho the data
3. Decomposing the VAR model residuals with ICA
4. Correcting the VAR coefficients</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r20b79c6e360b-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">1</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="13">
<li><p>Billinger et al. “SCoT: A Python Toolbox for EEG Source Connectivity”, Frontiers in Neuroinformatics, 2014</p></li>
</ol>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.varica.mvarica">
<span class="sig-prename descclassname"><span class="pre">scot.varica.</span></span><span class="sig-name descname"><span class="pre">mvarica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reducedim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize_var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">varfit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ensemble'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.varica.mvarica" title="Link to this definition">¶</a></dt>
<dd><p>Performs joint VAR model fitting and ICA source separation.</p>
<p>This function implements the MVARICA procedure <a class="reference internal" href="#r001faf6bb0ff-1" id="id20">[1]</a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</span></dt><dd><p>data set</p>
</dd>
<dt><strong>var</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VARBase</span></code>-like object</span></dt><dd><p>Vector autoregressive model (VAR) object that is used for model fitting.</p>
</dd>
<dt><strong>cl</strong><span class="classifier">list of valid dict keys, optional</span></dt><dd><p>Class labels associated with each trial.</p>
</dd>
<dt><strong>reducedim</strong><span class="classifier">{int, float, ‘no_pca’, None}, optional</span></dt><dd><p>A number of less than 1 is interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer number of 1 or greater is interpreted as the number of components to keep after applying PCA.
If set to None, all PCA components are retained. If set to ‘no_pca’, the PCA step is skipped.</p>
</dd>
<dt><strong>optimize_var</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to call automatic optimization of the VAR fitting routine.</p>
</dd>
<dt><strong>backend</strong><span class="classifier">dict-like, optional</span></dt><dd><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</dd>
<dt><strong>varfit</strong><span class="classifier">string</span></dt><dd><p>Determines how to calculate the residuals for source decomposition.
‘ensemble’ (default) fits one model to the whole data set,
‘class’ fits a new model for each class, and
‘trial’ fits a new model for each individual trial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">class</span></dt><dd><p>A class with the following attributes is returned:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>mixing</p></td>
<td><p>Source mixing matrix</p></td>
</tr>
<tr class="row-even"><td><p>unmixing</p></td>
<td><p>Source unmixing matrix</p></td>
</tr>
<tr class="row-odd"><td><p>residuals</p></td>
<td><p>Residuals of the VAR model(s) in source space</p></td>
</tr>
<tr class="row-even"><td><p>var_residuals</p></td>
<td><p>Residuals of the VAR model(s) in EEG space (before ICA)</p></td>
</tr>
<tr class="row-odd"><td><p>c</p></td>
<td><p>Noise covariance of the VAR model(s) in source space</p></td>
</tr>
<tr class="row-even"><td><p>b</p></td>
<td><p>VAR model coefficients (source space)</p></td>
</tr>
<tr class="row-odd"><td><p>a</p></td>
<td><p>VAR model coefficients (EEG space)</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>MVARICA is performed with the following steps:        
1. Optional dimensionality reduction with PCA
2. Fitting a VAR model tho the data
3. Decomposing the VAR model residuals with ICA
4. Correcting the VAR coefficients</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r001faf6bb0ff-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">1</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="7">
<li><p>Gomez-Herrero et al. “Measuring directional coupling between EEG sources”, NeuroImage, 2008</p></li>
</ol>
</div>
</div>
</dd></dl>

</section>
<section id="module-scot.xvschema">
<span id="scot-xvschema-module"></span><h2>scot.xvschema module<a class="headerlink" href="#module-scot.xvschema" title="Link to this heading">¶</a></h2>
<p>Cross-validation schemas</p>
<dl class="py function">
<dt class="sig sig-object py" id="scot.xvschema.make_nfold">
<span class="sig-prename descclassname"><span class="pre">scot.xvschema.</span></span><span class="sig-name descname"><span class="pre">make_nfold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.xvschema.make_nfold" title="Link to this definition">¶</a></dt>
<dd><p>n-fold cross validation</p>
<p>Use each of n blocks for testing once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>number of blocks</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gengen</strong><span class="classifier">func</span></dt><dd><p>a function that returns the generator</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.xvschema.multitrial">
<span class="sig-prename descclassname"><span class="pre">scot.xvschema.</span></span><span class="sig-name descname"><span class="pre">multitrial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_trials</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skipstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.xvschema.multitrial" title="Link to this definition">¶</a></dt>
<dd><p>Multi-trial cross-validation schema</p>
<p>Use one trial for testing, all others for training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_trials</strong><span class="classifier">int</span></dt><dd><p>Total number of trials</p>
</dd>
<dt><strong>skipstep</strong><span class="classifier">int</span></dt><dd><p>only use every <cite>skipstep</cite> trial for testing</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gen</strong><span class="classifier">generator object</span></dt><dd><p>the generator returns tuples (trainset, testset)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.xvschema.singletrial">
<span class="sig-prename descclassname"><span class="pre">scot.xvschema.</span></span><span class="sig-name descname"><span class="pre">singletrial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_trials</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skipstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.xvschema.singletrial" title="Link to this definition">¶</a></dt>
<dd><p>Single-trial cross-validation schema</p>
<p>Use one trial for training, all others for testing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_trials</strong><span class="classifier">int</span></dt><dd><p>Total number of trials</p>
</dd>
<dt><strong>skipstep</strong><span class="classifier">int</span></dt><dd><p>only use every <cite>skipstep</cite> trial for training</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gen</strong><span class="classifier">generator object</span></dt><dd><p>the generator returns tuples (trainset, testset)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scot.xvschema.splitset">
<span class="sig-prename descclassname"><span class="pre">scot.xvschema.</span></span><span class="sig-name descname"><span class="pre">splitset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_trials</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skipstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.xvschema.splitset" title="Link to this definition">¶</a></dt>
<dd><p>Split-set cross validation</p>
<p>Use half the trials for training, and the other half for testing. Then
repeat the other way round.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_trials</strong><span class="classifier">int</span></dt><dd><p>Total number of trials</p>
</dd>
<dt><strong>skipstep</strong><span class="classifier">int</span></dt><dd><p>unused</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gen</strong><span class="classifier">generator object</span></dt><dd><p>the generator returns tuples (trainset, testset)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-scot">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-scot" title="Link to this heading">¶</a></h2>
<p>SCoT: The Source Connectivity Toolbox.</p>
<dl class="py class">
<dt class="sig sig-object py" id="scot.Connectivity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.</span></span><span class="sig-name descname"><span class="pre">Connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Calculation of connectivity measures.</p>
<p>This class calculates various spectral connectivity measures from a vector
autoregressive (VAR) model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>b</strong><span class="classifier">array, shape (n_channels, n_channels * model_order)</span></dt><dd><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><span class="std std-ref">On the arrangement of VAR model coefficients</span></a> for details
about the arrangement of coefficients.</p>
</dd>
<dt><strong>c</strong><span class="classifier">array, shape (n_channels, n_channels), optional</span></dt><dd><p>Covariance matrix of the driving noise process. Identity matrix is used
if set to None (default).</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequency bins to calculate. Note that these points cover the
range between 0 and half the sampling rate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Connectivity measures are returned by member functions that take no
arguments and return a matrix of shape (m, m, nfft). The first dimension is
the sink, the second dimension is the source, and the third dimension is
the frequency.</p>
<p>An overview of most supported measures can be found in <a class="reference internal" href="#r15d45fecccb0-1" id="id22">[1]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r15d45fecccb0-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id22">1</a><span class="fn-bracket">]</span></span>
<p>M. Billinger, C. Brunner, G. R. Müller-Putz. Single-trial
connectivity estimation for classification of motor imagery data. J.
Neural Eng. 10, 2013.</p>
</div>
</div>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>:func:`A`</strong></p></td>
<td><p>Spectral representation of the VAR coefficients.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`H`</strong></p></td>
<td><p>Transfer function (turns the innovation process into the VAR process).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`S`</strong></p></td>
<td><p>Cross-spectral density.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`logS`</strong></p></td>
<td><p>Logarithm of the cross-spectral density (S).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`G`</strong></p></td>
<td><p>Inverse cross-spectral density.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`logG`</strong></p></td>
<td><p>Logarithm of the inverse cross-spectral density.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`PHI`</strong></p></td>
<td><p>Phase angle.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`COH`</strong></p></td>
<td><p>Coherence.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`pCOH`</strong></p></td>
<td><p>Partial coherence.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`PDC`</strong></p></td>
<td><p>Partial directed coherence.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`ffPDC`</strong></p></td>
<td><p>Full frequency partial directed coherence.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`PDCF`</strong></p></td>
<td><p>PDC factor.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`GPDC`</strong></p></td>
<td><p>Generalized partial directed coherence.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`DTF`</strong></p></td>
<td><p>Directed transfer function.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`ffDTF`</strong></p></td>
<td><p>Full frequency directed transfer function.</p></td>
</tr>
<tr class="row-even"><td><p><strong>:func:`dDTF`</strong></p></td>
<td><p>Direct directed transfer function.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>:func:`GDTF`</strong></p></td>
<td><p>Generalized directed transfer function.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.A">
<span class="sig-name descname"><span class="pre">A</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.A" title="Link to this definition">¶</a></dt>
<dd><p>Spectral VAR coefficients.</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}(f) = \mathbf{I} - \sum_{k=1}^{p} \mathbf{a}^{(k)}
\mathrm{e}^{-2\pi f}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.COH">
<span class="sig-name descname"><span class="pre">COH</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.COH" title="Link to this definition">¶</a></dt>
<dd><p>Coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{COH}_{ij}(f) = \\frac{S_{ij}(f)}
{\sqrt{S_{ii}(f) S_{jj}(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>P. L. Nunez, R. Srinivasan, A. F. Westdorp, R. S. Wijesinghe,
D. M. Tucker, R. B. Silverstein, P. J. Cadusch. EEG coherency I:
statistics, reference electrode, volume conduction, Laplacians,
cortical imaging, and interpretation at multiple scales. Electroenceph.
Clin. Neurophysiol. 103(5): 499-515, 1997.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.Cinv">
<span class="sig-name descname"><span class="pre">Cinv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.Cinv" title="Link to this definition">¶</a></dt>
<dd><p>Inverse of the noise covariance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.DTF">
<span class="sig-name descname"><span class="pre">DTF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.DTF" title="Link to this definition">¶</a></dt>
<dd><p>Directed transfer function.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{DTF}_{ij}(f) = \\frac{H_{ij}(f)}
{\sqrt{H_{i:}(f) H_{i:}'(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>M. J. Kaminski, K. J. Blinowska. A new method of the description of the
information flow in the brain structures. Biol. Cybernetics 65(3):
203-210, 1991.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.G">
<span class="sig-name descname"><span class="pre">G</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.G" title="Link to this definition">¶</a></dt>
<dd><p>Inverse cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathbf{G}(f) = \mathbf{A}(f) \mathbf{C}^{-1} \mathbf{A}'(f)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.GDTF">
<span class="sig-name descname"><span class="pre">GDTF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.GDTF" title="Link to this definition">¶</a></dt>
<dd><p>Generalized directed transfer function.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{GPDC}_{ij}(f) = \\frac{\sigma_j |H_{ij}(f)|}
{\sqrt{H_{i:}(f) \mathrm{diag}(\mathbf{C}) H_{i:}'(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring connectivity in linear
multivariate processes: definitions, interpretation, and practical
analysis. Comput. Math. Meth. Med. 2012: 140513, 2012.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.GPDC">
<span class="sig-name descname"><span class="pre">GPDC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.GPDC" title="Link to this definition">¶</a></dt>
<dd><p>Generalized partial directed coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{GPDC}_{ij}(f) = \\frac{|A_{ij}(f)|}\end{split}\]</div>
<p>{sigma_i sqrt{A_{:j}’(f) mathrm{diag}(mathbf{C})^{-1} A_{:j}(f)}}</p>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring connectivity in linear
multivariate processes: definitions, interpretation, and practical
analysis. Comput. Math. Meth. Med. 2012: 140513, 2012.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.H">
<span class="sig-name descname"><span class="pre">H</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.H" title="Link to this definition">¶</a></dt>
<dd><p>VAR transfer function.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}(f) = \mathbf{A}(f)^{-1}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.PDC">
<span class="sig-name descname"><span class="pre">PDC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.PDC" title="Link to this definition">¶</a></dt>
<dd><p>Partial directed coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{PDC}_{ij}(f) = \\frac{A_{ij}(f)}
{\sqrt{A_{:j}'(f) A_{:j}(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept
in neural structure determination. Biol. Cybernetics 84(6): 463-474,
2001.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.PDCF">
<span class="sig-name descname"><span class="pre">PDCF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.PDCF" title="Link to this definition">¶</a></dt>
<dd><p>Partial directed coherence factor.</p>
<div class="math notranslate nohighlight">
\[\mathrm{PDCF}_{ij}(f) =\]</div>
<p>\frac{A_{ij}(f)}{sqrt{A_{:j}’(f) mathbf{C}^{-1} A_{:j}(f)}}</p>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept
in neural structure determination. Biol. Cybernetics 84(6): 463-474,
2001.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.PHI">
<span class="sig-name descname"><span class="pre">PHI</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.PHI" title="Link to this definition">¶</a></dt>
<dd><p>Phase angle.</p>
<p>Phase angle of complex <a class="reference internal" href="#scot.Connectivity.S" title="scot.Connectivity.S"><code class="xref py py-func docutils literal notranslate"><span class="pre">S()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.S">
<span class="sig-name descname"><span class="pre">S</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.S" title="Link to this definition">¶</a></dt>
<dd><p>Cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathbf{S}(f) = \mathbf{H}(f) \mathbf{C} \mathbf{H}'(f)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.absS">
<span class="sig-name descname"><span class="pre">absS</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.absS" title="Link to this definition">¶</a></dt>
<dd><p>Absolute cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathrm{absS}(f) = | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.dDTF">
<span class="sig-name descname"><span class="pre">dDTF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.dDTF" title="Link to this definition">¶</a></dt>
<dd><p>Direct directed transfer function.</p>
<div class="math notranslate nohighlight">
\[\mathrm{dDTF}_{ij}(f) = |\mathrm{pCOH}_{ij}(f)|
\mathrm{ffDTF}_{ij}(f)\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki.
Determination of information flow direction among brain structures by a
modified directed transfer function (dDTF) method. J. Neurosci. Meth.
125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.ffDTF">
<span class="sig-name descname"><span class="pre">ffDTF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.ffDTF" title="Link to this definition">¶</a></dt>
<dd><p>Full frequency directed transfer function.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{ffDTF}_{ij}(f) =
\\frac{H_{ij}(f)}{\sqrt{\sum_f H_{i:}(f) H_{i:}'(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki.
Determination of information flow direction among brain structures by a
modified directed transfer function (dDTF) method. J. Neurosci. Meth.
125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.ffPDC">
<span class="sig-name descname"><span class="pre">ffPDC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.ffPDC" title="Link to this definition">¶</a></dt>
<dd><p>Full frequency partial directed coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{ffPDC}_{ij}(f) =
\\frac{A_{ij}(f)}{\sqrt{\sum_f A_{:j}'(f) A_{:j}(f)}}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.logG">
<span class="sig-name descname"><span class="pre">logG</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.logG" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic inverse cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathrm{logG}(f) = \log | \mathbf{G}(f) |\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.logS">
<span class="sig-name descname"><span class="pre">logS</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.logS" title="Link to this definition">¶</a></dt>
<dd><p>Logarithmic cross-spectral density.</p>
<div class="math notranslate nohighlight">
\[\mathrm{logS}(f) = \log | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.pCOH">
<span class="sig-name descname"><span class="pre">pCOH</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.pCOH" title="Link to this definition">¶</a></dt>
<dd><p>Partial coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{pCOH}_{ij}(f) = \\frac{G_{ij}(f)}
{\sqrt{G_{ii}(f) G_{jj}(f)}}\end{split}\]</div>
<p class="rubric">References</p>
<p>P. J. Franaszczuk, K. J. Blinowska, M. Kowalczyk. The application of
parametric multichannel spectral estimates in the study of electrical
brain activity. Biol. Cybernetics 51(4): 239-247, 1985.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Connectivity.sPDC">
<span class="sig-name descname"><span class="pre">sPDC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Connectivity.sPDC" title="Link to this definition">¶</a></dt>
<dd><p>Squared partial directed coherence.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{sPDC}_{ij}(f) = \\frac{|A_{ij}(f)|^2}
{\mathbf{1}^T | A_{:j}(f) |^2}\end{split}\]</div>
<p class="rubric">References</p>
<p>L. Astolfi, F. Cincotti, D. Mattia, M. G. Marciani, L. Baccala, F. D.
Fallani, S. Salinari, M. Ursino, M. Zavaglia, F. Babiloni. Partial
directed coherence: a new concept in neural structure determination.
IEEE Trans. Biomed. Eng. 53(9): 1802-1812, 2006.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="scot.Workspace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">scot.</span></span><span class="sig-name descname"><span class="pre">Workspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reducedim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>SCoT Workspace</p>
<p>This class provides high-level functionality for source identification, connectivity estimation, and visualization.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>var</strong><span class="classifier">{<code class="xref py py-class docutils literal notranslate"><span class="pre">VARBase</span></code>-like object, dict}</span></dt><dd><p>Vector autoregressive model (VAR) object that is used for model fitting.
This can also be a dictionary that is passed as <cite>**kwargs</cite> to backend[‘var’]() in order to
construct a new VAR model object.</p>
</dd>
<dt><strong>locations</strong><span class="classifier">array_like, optional</span></dt><dd><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</dd>
<dt><strong>reducedim</strong><span class="classifier">{int, float, ‘no_pca’}, optional</span></dt><dd><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer number of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to ‘no_pca’ the PCA step is skipped.</p>
</dd>
<dt><strong>nfft</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frequency bins for connectivity estimation.</p>
</dd>
<dt><strong>backend</strong><span class="classifier">dict-like, optional</span></dt><dd><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>`unmixing_`</strong><span class="classifier">array</span></dt><dd><p>Estimated unmixing matrix.</p>
</dd>
<dt><strong>`mixing_`</strong><span class="classifier">array</span></dt><dd><p>Estimated mixing matrix.</p>
</dd>
<dt><strong>`plot_diagonal`</strong><span class="classifier">str</span></dt><dd><p>Configures what is plotted in the diagonal subplots.
<strong>‘topo’</strong> (default) plots topoplots on the diagonal,
<strong>‘S’</strong> plots the spectral density of each component, and
<strong>‘fill’</strong> plots connectivity on the diagonal.</p>
</dd>
<dt><strong>`plot_outside_topo`</strong><span class="classifier">bool</span></dt><dd><p>Whether to place topoplots in the left column and top row.</p>
</dd>
<dt><strong>`plot_f_range`</strong><span class="classifier">(int, int)</span></dt><dd><p>Lower and upper frequency limits for plotting. Defaults to [0, fs/2].</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.compare_conditions">
<span class="sig-name descname"><span class="pre">compare_conditions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.compare_conditions" title="Link to this definition">¶</a></dt>
<dd><p>Test for significant difference in connectivity of two sets of class labels.</p>
<p>Connectivity estimates are obtained by bootstrapping. Correction for multiple testing is performed by
controlling the false discovery rate (FDR).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels1, labels2</strong><span class="classifier">list of class labels</span></dt><dd><p>The two sets of class labels to compare. Each set may contain more than one label.</p>
</dd>
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum allowed FDR. The ratio of falsely detected significant differences is guaranteed to be less than
<cite>alpha</cite>.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>How many bootstrap estimates to take.</p>
</dd>
<dt><strong>num_samples</strong><span class="classifier">int, optional</span></dt><dd><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</dd>
<dt><strong>plot</strong><span class="classifier">{False, None, Figure object}, optional</span></dt><dd><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>p</strong><span class="classifier">array, shape = [n_channels, n_channels, nfft]</span></dt><dd><p>Uncorrected p-values.</p>
</dd>
<dt><strong>s</strong><span class="classifier">array, dtype=bool, shape = [n_channels, n_channels, nfft]</span></dt><dd><p>FDR corrected significance. True means the difference is significant in this location.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.do_cspvarica">
<span class="sig-name descname"><span class="pre">do_cspvarica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varfit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ensemble'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.do_cspvarica" title="Link to this definition">¶</a></dt>
<dd><p>Perform CSPVARICA</p>
<p>Perform CSPVARICA source decomposition and VAR model fitting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>varfit</strong><span class="classifier">string</span></dt><dd><p>Determines how to calculate the residuals for source decomposition.
‘ensemble’ (default) fits one model to the whole data set,
‘class’ fits a different model for each class, and
‘trial’ fits a different model for each individual trial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">cspvarica()</span></code></dt><dd><p>CSPVARICA implementation</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.do_ica">
<span class="sig-name descname"><span class="pre">do_ica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.do_ica" title="Link to this definition">¶</a></dt>
<dd><p>Perform ICA</p>
<p>Perform plain ICA source decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.do_mvarica">
<span class="sig-name descname"><span class="pre">do_mvarica</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varfit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ensemble'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.do_mvarica" title="Link to this definition">¶</a></dt>
<dd><p>Perform MVARICA</p>
<p>Perform MVARICA source decomposition and VAR model fitting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>varfit</strong><span class="classifier">string</span></dt><dd><p>Determines how to calculate the residuals for source decomposition.
‘ensemble’ (default) fits one model to the whole data set,
‘class’ fits a different model for each class, and
‘trial’ fits a different model for each individual trial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain data.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">mvarica()</span></code></dt><dd><p>MVARICA implementation</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.fit_var">
<span class="sig-name descname"><span class="pre">fit_var</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.fit_var" title="Link to this definition">¶</a></dt>
<dd><p>Fit a VAR model to the source activations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain source activations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.get_bootstrap_connectivity">
<span class="sig-name descname"><span class="pre">get_bootstrap_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.get_bootstrap_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate bootstrap estimates of spectral connectivity measures.</p>
<p>Bootstrapping is performed on trial level.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_names</strong><span class="classifier">{str, list of str}</span></dt><dd><p>Name(s) of the connectivity measure(s) to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>How many bootstrap estimates to take.</p>
</dd>
<dt><strong>num_samples</strong><span class="classifier">int, optional</span></dt><dd><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>measure</strong><span class="classifier">array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</span></dt><dd><p>Values of the connectivity measure for each bootstrap estimate. If <cite>measure_names</cite> is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are
ndarrays of shape [<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#scot.connectivity_statistics.bootstrap_connectivity" title="scot.connectivity_statistics.bootstrap_connectivity"><code class="xref py py-func docutils literal notranslate"><span class="pre">scot.connectivity_statistics.bootstrap_connectivity()</span></code></a></dt><dd><p>Calculates bootstrap connectivity</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.get_connectivity">
<span class="sig-name descname"><span class="pre">get_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.get_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</dd>
<dt><strong>plot</strong><span class="classifier">{False, None, Figure object}, optional</span></dt><dd><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">array, shape = [n_channels, n_channels, nfft]</span></dt><dd><p>Values of the connectivity measure.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain a fitted VAR model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.get_surrogate_connectivity">
<span class="sig-name descname"><span class="pre">get_surrogate_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.get_surrogate_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>How many surrogate samples to take.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>measure</strong><span class="classifier">array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</span></dt><dd><p>Values of the connectivity measure for each surrogate.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#scot.connectivity_statistics.surrogate_connectivity" title="scot.connectivity_statistics.surrogate_connectivity"><code class="xref py py-func docutils literal notranslate"><span class="pre">scot.connectivity_statistics.surrogate_connectivity()</span></code></a></dt><dd><p>Calculates surrogate connectivity</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.get_tf_connectivity">
<span class="sig-name descname"><span class="pre">get_tf_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winlen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winstep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.get_tf_connectivity" title="Link to this definition">¶</a></dt>
<dd><p>Calculate estimate of time-varying connectivity.</p>
<p>Connectivity is estimated in a sliding window approach on the current data set. The window is stepped
<cite>n_steps</cite> = (<cite>n_samples</cite> - <cite>winlen</cite>) // <cite>winstep</cite> times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</dd>
<dt><strong>winlen</strong><span class="classifier">int</span></dt><dd><p>Length of the sliding window (in samples).</p>
</dd>
<dt><strong>winstep</strong><span class="classifier">int</span></dt><dd><p>Step size for sliding window (in samples).</p>
</dd>
<dt><strong>plot</strong><span class="classifier">{False, None, Figure object}, optional</span></dt><dd><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</dd>
<dt><strong>baseline</strong><span class="classifier">[int, int] or None</span></dt><dd><p>Start and end of the baseline period in samples. The baseline is subtracted from the connectivity. It is
computed as the average of all windows that contain start or end, or fall between start and end.
If set to None no baseline is subtracted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">array, shape = [n_channels, n_channels, nfft, n_steps]</span></dt><dd><p>Values of the connectivity measure.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">Figure object, optional</span></dt><dd><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain a fitted VAR model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.keep_sources">
<span class="sig-name descname"><span class="pre">keep_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.keep_sources" title="Link to this definition">¶</a></dt>
<dd><p>Keep only the specified sources in the decomposition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.optimize_var">
<span class="sig-name descname"><span class="pre">optimize_var</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.optimize_var" title="Link to this definition">¶</a></dt>
<dd><p>Optimize the VAR model’s hyperparameters (such as regularization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain source activations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.plot_connectivity_surrogate">
<span class="sig-name descname"><span class="pre">plot_connectivity_surrogate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.plot_connectivity_surrogate" title="Link to this definition">¶</a></dt>
<dd><p>Plot spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure_name</strong><span class="classifier">str</span></dt><dd><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connectivity</span></code></a> for supported measures.</p>
</dd>
<dt><strong>repeats</strong><span class="classifier">int, optional</span></dt><dd><p>How many surrogate samples to take.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">{None, Figure object}, optional</span></dt><dd><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>Instance of the figure in which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.plot_connectivity_topos">
<span class="sig-name descname"><span class="pre">plot_connectivity_topos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.plot_connectivity_topos" title="Link to this definition">¶</a></dt>
<dd><p>Plot scalp projections of the sources.</p>
<p>This function only plots the topos. Use in combination with connectivity plotting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">{None, Figure object}, optional</span></dt><dd><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig</strong><span class="classifier">Figure object</span></dt><dd><p>Instance of the figure in which was plotted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.plot_source_topos">
<span class="sig-name descname"><span class="pre">plot_source_topos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">common_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.plot_source_topos" title="Link to this definition">¶</a></dt>
<dd><p>Plot topography of the Source decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>common_scale</strong><span class="classifier">float, optional</span></dt><dd><p>If set to None, each topoplot’s color axis is scaled individually. Otherwise specifies the percentile
(1-99) of values in all plot. This value is taken as the maximum color scale.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="scot.Workspace.plotting">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plotting</span></span><a class="headerlink" href="#scot.Workspace.plotting" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.remove_sources">
<span class="sig-name descname"><span class="pre">remove_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.remove_sources" title="Link to this definition">¶</a></dt>
<dd><p>Remove sources from the decomposition.</p>
<p>This function removes sources from the decomposition. Doing so invalidates currently fitted VAR models and
connectivity estimates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sources</strong><span class="classifier">{slice, int, array of ints}</span></dt><dd><p>Indices of components to remove.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Workspace</span></code></a> instance does not contain a source decomposition.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.set_data" title="Link to this definition">¶</a></dt>
<dd><p>Assign data to the workspace.</p>
<p>This function assigns a new data set to the workspace. Doing so invalidates currently fitted VAR models,
connectivity estimates, and activations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array-like, shape = [n_trials, n_channels, n_samples] or [n_channels, n_samples]</span></dt><dd><p>EEG data set</p>
</dd>
<dt><strong>cl</strong><span class="classifier">list of valid dict keys</span></dt><dd><p>Class labels associated with each trial.</p>
</dd>
<dt><strong>time_offset</strong><span class="classifier">float, optional</span></dt><dd><p>Trial starting time; used for labelling the x-axis of time/frequency plots.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.set_locations">
<span class="sig-name descname"><span class="pre">set_locations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">locations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.set_locations" title="Link to this definition">¶</a></dt>
<dd><p>Set sensor locations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>locations</strong><span class="classifier">array_like</span></dt><dd><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.set_premixing">
<span class="sig-name descname"><span class="pre">set_premixing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">premixing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.set_premixing" title="Link to this definition">¶</a></dt>
<dd><p>Set premixing matrix.</p>
<p>The premixing matrix maps data to physical channels. If the data is actual channel data,
the premixing matrix can be set to identity. Use this functionality if the data was pre-
transformed with e.g. PCA.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>premixing</strong><span class="classifier">array_like, shape = [n_signals, n_channels]</span></dt><dd><p>Matrix that maps data signals to physical channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.set_used_labels">
<span class="sig-name descname"><span class="pre">set_used_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.set_used_labels" title="Link to this definition">¶</a></dt>
<dd><p>Specify which trials to use in subsequent analysis steps.</p>
<p>This function masks trials based on their class labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">list of class labels</span></dt><dd><p>Marks all trials that have a label that is in the <cite>labels</cite> list for further processing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Workspace</span></dt><dd><p>The Workspace object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="scot.Workspace.show_plots">
<span class="sig-name descname"><span class="pre">show_plots</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scot.Workspace.show_plots" title="Link to this definition">¶</a></dt>
<dd><p>Show current plots.</p>
<p>This is only a convenience wrapper around <code class="xref py py-func docutils literal notranslate"><span class="pre">matplotlib.pyplot.show_plots()</span></code>.</p>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scot.eegtopo.html" title="scot.eegtopo package"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="scot"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SCoT</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../api_reference.html" >API Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >scot</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">scot package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2013-2016 SCoT Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>