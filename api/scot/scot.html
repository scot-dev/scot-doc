<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>scot package &mdash; SCoT 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="SCoT 0.1.0 documentation" href="../../index.html" />
    <link rel="up" title="scot" href="modules.html" />
    <link rel="next" title="scot.eegtopo package" href="scot.eegtopo.html" />
    <link rel="prev" title="scot" href="modules.html" /> 
  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scot.eegtopo.html" title="scot.eegtopo package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="scot"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li><a href="../../api_reference.html" >API Reference</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">scot</a> &raquo;</li> 
      </ul>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="scot-package">
<h1>scot package<a class="headerlink" href="#scot-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="scot.eegtopo.html">scot.eegtopo package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.eegpos3d">scot.eegtopo.eegpos3d module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.geo_euclidean">scot.eegtopo.geo_euclidean module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.geo_spherical">scot.eegtopo.geo_spherical module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.projections">scot.eegtopo.projections module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.tools">scot.eegtopo.tools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo.topoplot">scot.eegtopo.topoplot module</a></li>
<li class="toctree-l2"><a class="reference internal" href="scot.eegtopo.html#module-scot.eegtopo">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-scot.backend_builtin">
<span id="scot-backend-builtin-module"></span><h2>scot.backend_builtin module<a class="headerlink" href="#module-scot.backend_builtin" title="Permalink to this headline">¶</a></h2>
<p>Use internally implemented functions as backend.</p>
<dl class="function">
<dt id="scot.backend_builtin.activate">
<tt class="descclassname">scot.backend_builtin.</tt><tt class="descname">activate</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.backend_builtin.activate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.backend_builtin.wrapper_binica">
<tt class="descclassname">scot.backend_builtin.</tt><tt class="descname">wrapper_binica</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.backend_builtin.wrapper_binica" title="Permalink to this definition">¶</a></dt>
<dd><p>Call binica for ICA calculation.</p>
</dd></dl>

<dl class="function">
<dt id="scot.backend_builtin.wrapper_csp">
<tt class="descclassname">scot.backend_builtin.</tt><tt class="descname">wrapper_csp</tt><big>(</big><em>x</em>, <em>cl</em>, <em>reducedim</em><big>)</big><a class="headerlink" href="#scot.backend_builtin.wrapper_csp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.backend_builtin.wrapper_pca">
<tt class="descclassname">scot.backend_builtin.</tt><tt class="descname">wrapper_pca</tt><big>(</big><em>x</em>, <em>reducedim</em><big>)</big><a class="headerlink" href="#scot.backend_builtin.wrapper_pca" title="Permalink to this definition">¶</a></dt>
<dd><p>Call SCoT&#8217;s PCA algorithm.</p>
</dd></dl>

</div>
<div class="section" id="module-scot.backend_sklearn">
<span id="scot-backend-sklearn-module"></span><h2>scot.backend_sklearn module<a class="headerlink" href="#module-scot.backend_sklearn" title="Permalink to this headline">¶</a></h2>
<p>Use scikit-learn routines as backend.</p>
<dl class="class">
<dt id="scot.backend_sklearn.VAR">
<em class="property">class </em><tt class="descclassname">scot.backend_sklearn.</tt><tt class="descname">VAR</tt><big>(</big><em>model_order</em>, <em>fitobj=None</em><big>)</big><a class="headerlink" href="#scot.backend_sklearn.VAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#scot.varbase.VARBase" title="scot.varbase.VARBase"><tt class="xref py py-class docutils literal"><span class="pre">scot.varbase.VARBase</span></tt></a></p>
<p>Scikit-learn based implementation of VARBase.</p>
<p>This class fits VAR models using various implementations of generalized linear model fitting available in scikit-learn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model_order</strong> : int</p>
<blockquote>
<div><p>Autoregressive model order</p>
</div></blockquote>
<p><strong>fitobj</strong> : class, optional</p>
<blockquote class="last">
<div><p>Instance of a linear model implementation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.backend_sklearn.VAR.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.backend_sklearn.VAR.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit VAR model to data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <a class="reference internal" href="#scot.backend_sklearn.VAR" title="scot.backend_sklearn.VAR"><tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></a></p>
<blockquote class="last">
<div><p>The <a class="reference internal" href="#scot.backend_sklearn.VAR" title="scot.backend_sklearn.VAR"><tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></a> object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="scot.backend_sklearn.activate">
<tt class="descclassname">scot.backend_sklearn.</tt><tt class="descname">activate</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.backend_sklearn.activate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set backend attribute in the config module.</p>
</dd></dl>

<dl class="function">
<dt id="scot.backend_sklearn.wrapper_fastica">
<tt class="descclassname">scot.backend_sklearn.</tt><tt class="descname">wrapper_fastica</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.backend_sklearn.wrapper_fastica" title="Permalink to this definition">¶</a></dt>
<dd><p>Call FastICA implementation from scikit-learn.</p>
</dd></dl>

<dl class="function">
<dt id="scot.backend_sklearn.wrapper_pca">
<tt class="descclassname">scot.backend_sklearn.</tt><tt class="descname">wrapper_pca</tt><big>(</big><em>x</em>, <em>reducedim</em><big>)</big><a class="headerlink" href="#scot.backend_sklearn.wrapper_pca" title="Permalink to this definition">¶</a></dt>
<dd><p>Call PCA implementation from scikit-learn.</p>
</dd></dl>

</div>
<div class="section" id="module-scot.binica">
<span id="scot-binica-module"></span><h2>scot.binica module<a class="headerlink" href="#module-scot.binica" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="scot.binica.binica">
<tt class="descclassname">scot.binica.</tt><tt class="descname">binica</tt><big>(</big><em>data</em>, <em>binary='/home/billinger/git-working/SCoT/scot/binica/ica_linux'</em><big>)</big><a class="headerlink" href="#scot.binica.binica" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple wrapper for the BINICA binary.</p>
<p>This function calculates the ICA transformation using the Infomax algorithm implemented in BINICA.</p>
<dl class="docutils">
<dt>BINICA is bundled with EEGLAB, or can be downloaded from here:</dt>
<dd><a class="reference external" href="http://sccn.ucsd.edu/eeglab/binica/">http://sccn.ucsd.edu/eeglab/binica/</a></dd>
</dl>
<p>This function attempts to automatically download and extract the BINICA binary.</p>
<p>By default the binary is expected to be &#8220;binica/ica_linux&#8221; relative
to the directory where this module lies (typically scot/binica/ica_linux)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>binary</strong> : str</p>
<blockquote>
<div><p>Full path to the binica binary</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array, shape = [n_channels, n_channels]</p>
<blockquote>
<div><p>ICA weights matrix</p>
</div></blockquote>
<p><strong>s</strong> : array, shape = [n_channels, n_channels]</p>
<blockquote class="last">
<div><p>Sphering matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The unmixing matrix is obtained by multiplying U = dot(s, w)</p>
</dd></dl>

<dl class="function">
<dt id="scot.binica.check_binary_">
<tt class="descclassname">scot.binica.</tt><tt class="descname">check_binary_</tt><big>(</big><em>binary</em><big>)</big><a class="headerlink" href="#scot.binica.check_binary_" title="Permalink to this definition">¶</a></dt>
<dd><p>check if binary is available, and try to download it if not</p>
</dd></dl>

</div>
<div class="section" id="module-scot.config">
<span id="scot-config-module"></span><h2>scot.config module<a class="headerlink" href="#module-scot.config" title="Permalink to this headline">¶</a></h2>
<p>Global configuration</p>
</div>
<div class="section" id="module-scot.connectivity">
<span id="scot-connectivity-module"></span><h2>scot.connectivity module<a class="headerlink" href="#module-scot.connectivity" title="Permalink to this headline">¶</a></h2>
<p>Connectivity Analysis</p>
<dl class="class">
<dt id="scot.connectivity.Connectivity">
<em class="property">class </em><tt class="descclassname">scot.connectivity.</tt><tt class="descname">Connectivity</tt><big>(</big><em>b</em>, <em>c=None</em>, <em>nfft=512</em><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Calculation of connectivity measures</p>
<p>This class calculates various spectral connectivity measures from a vector autoregressive (VAR) model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>b</strong> : ndarray, shape = [n_channels, n_channels*model_order]</p>
<blockquote>
<div><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><em>On the arrangement of VAR model coefficients</em></a> for details about the arrangement of coefficients.</p>
</div></blockquote>
<p><strong>c</strong> : ndarray, shape = [n_channels, n_channels], optional</p>
<blockquote>
<div><p>Covariance matrix of the driving noise process. Identity matrix is used if set to None.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote class="last">
<div><p>Number of frequency bins to calculate. Note that these points cover the range between 0 and half the
sampling rate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Connectivity measures are returned by member functions that take no arguments and return a matrix of
shape [m,m,nfft]. The first dimension is the sink, the second dimension is the source, and the third dimension is
the frequency.</p>
<p>A summary of most supported measures can be found in <a class="reference internal" href="#r1" id="id1">[R1]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> M. Billinger et al, “Single-trial connectivity estimation for classification of motor imagery data”,
<em>J. Neural Eng.</em> 10, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.A" title="scot.connectivity.Connectivity.A"><tt class="xref py py-func docutils literal"><span class="pre">A()</span></tt></a></td>
<td>Spectral representation of the VAR coefficients</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.H" title="scot.connectivity.Connectivity.H"><tt class="xref py py-func docutils literal"><span class="pre">H()</span></tt></a></td>
<td>Transfer function that turns the innovation process into the VAR process</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.S" title="scot.connectivity.Connectivity.S"><tt class="xref py py-func docutils literal"><span class="pre">S()</span></tt></a></td>
<td>Cross spectral density</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.logS" title="scot.connectivity.Connectivity.logS"><tt class="xref py py-func docutils literal"><span class="pre">logS()</span></tt></a></td>
<td>Logarithm of the cross spectral density (S), for convenience.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.G" title="scot.connectivity.Connectivity.G"><tt class="xref py py-func docutils literal"><span class="pre">G()</span></tt></a></td>
<td>Inverse cross spectral density</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.logG" title="scot.connectivity.Connectivity.logG"><tt class="xref py py-func docutils literal"><span class="pre">logG()</span></tt></a></td>
<td>Logarithm of the inverse cross spectral density</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.PHI" title="scot.connectivity.Connectivity.PHI"><tt class="xref py py-func docutils literal"><span class="pre">PHI()</span></tt></a></td>
<td>Phase angle</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.COH" title="scot.connectivity.Connectivity.COH"><tt class="xref py py-func docutils literal"><span class="pre">COH()</span></tt></a></td>
<td>Coherence</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.pCOH" title="scot.connectivity.Connectivity.pCOH"><tt class="xref py py-func docutils literal"><span class="pre">pCOH()</span></tt></a></td>
<td>Partial coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.PDC" title="scot.connectivity.Connectivity.PDC"><tt class="xref py py-func docutils literal"><span class="pre">PDC()</span></tt></a></td>
<td>Partial directed coherence</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.ffPDC" title="scot.connectivity.Connectivity.ffPDC"><tt class="xref py py-func docutils literal"><span class="pre">ffPDC()</span></tt></a></td>
<td>Full frequency partial directed coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.PDCF" title="scot.connectivity.Connectivity.PDCF"><tt class="xref py py-func docutils literal"><span class="pre">PDCF()</span></tt></a></td>
<td>PDC factor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.GPDC" title="scot.connectivity.Connectivity.GPDC"><tt class="xref py py-func docutils literal"><span class="pre">GPDC()</span></tt></a></td>
<td>Generalized partial directed coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.DTF" title="scot.connectivity.Connectivity.DTF"><tt class="xref py py-func docutils literal"><span class="pre">DTF()</span></tt></a></td>
<td>Directed transfer function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.ffDTF" title="scot.connectivity.Connectivity.ffDTF"><tt class="xref py py-func docutils literal"><span class="pre">ffDTF()</span></tt></a></td>
<td>Full frequency directed transfer function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.connectivity.Connectivity.dDTF" title="scot.connectivity.Connectivity.dDTF"><tt class="xref py py-func docutils literal"><span class="pre">dDTF()</span></tt></a></td>
<td>Direct directed transfer function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.connectivity.Connectivity.GDTF" title="scot.connectivity.Connectivity.GDTF"><tt class="xref py py-func docutils literal"><span class="pre">GDTF()</span></tt></a></td>
<td>Generalized directed transfer function</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.connectivity.Connectivity.A">
<tt class="descname">A</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectral VAR coefficients</p>
<div class="math">
\[\mathbf{A}(f) = \mathbf{I} - \sum_{k=1}^{p} \mathbf{a}^{(k)} \mathrm{e}^{-2\pi f}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.COH">
<tt class="descname">COH</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.COH" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherence</p>
<div class="math">
\[\mathrm{COH}_{ij}(f) = \frac{S_{ij}(f)}{\sqrt{S_{ii}(f) S_{jj}(f)}}\]</div>
<p class="rubric">References</p>
<p>P. L. Nunez, R. Srinivasan, A. F. Westdorp, R. S. Wijesinghe, D. M. Tucker,
R. B. Silverstein, P. J. Cadusch. EEG coherency: I: statistics, reference electrode,
volume conduction, Laplacians, cortical imaging, and interpretation at multiple scales.
Electroenceph. Clin. Neurophysiol. 103(5): 499-515, 1997.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.Cinv">
<tt class="descname">Cinv</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.Cinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of the noise covariance</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.DTF">
<tt class="descname">DTF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.DTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Directed transfer function</p>
<div class="math">
\[\mathrm{DTF}_{ij}(f) = \frac{H_{ij}(f)}{\sqrt{H_{i:}(f) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>M. J. Kaminski, K. J. Blinowska. A new method of the description of the information flow
in the brain structures. Biol. Cybernetics 65(3): 203-210, 1991.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.G">
<tt class="descname">G</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.G" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse cross spectral density</p>
<div class="math">
\[\mathbf{G}(f) = \mathbf{A}(f) \mathbf{C}^{-1} \mathbf{A}'(f)\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.GDTF">
<tt class="descname">GDTF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.GDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized directed transfer function</p>
<div class="math">
\[\mathrm{GPDC}_{ij}(f) = \frac{\sigma_j |H_{ij}(f)|}
{\sqrt{H_{i:}(f) \mathrm{diag}(\mathbf{C}) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring Connectivity in Linear Multivariate Processes:
Definitions, Interpretation, and Practical Analysis. Comput. Math. Meth. Med. 2012:140513, 2012.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.GPDC">
<tt class="descname">GPDC</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.GPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized partial directed coherence</p>
<div class="math">
\[\mathrm{GPDC}_{ij}(f) = \frac{|A_{ij}(f)|}
{\sigma_i \sqrt{A_{:j}'(f) \mathrm{diag}(\mathbf{C})^{-1} A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring Connectivity in Linear Multivariate Processes:
Definitions, Interpretation, and Practical Analysis. Comput. Math. Meth. Med. 2012:140513, 2012.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.H">
<tt class="descname">H</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.H" title="Permalink to this definition">¶</a></dt>
<dd><p>VAR transfer function</p>
<div class="math">
\[\mathbf{H}(f) = \mathbf{A}(f)^{-1}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.PDC">
<tt class="descname">PDC</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.PDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial directed coherence</p>
<div class="math">
\[\mathrm{PDC}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{A_{:j}'(f) A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept in neural structure
determination. Biol. Cybernetics 84(6):463-474, 2001.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.PDCF">
<tt class="descname">PDCF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.PDCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial directed coherence factor</p>
<div class="math">
\[\mathrm{PDCF}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{A_{:j}'(f) \mathbf{C}^{-1} A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept in neural structure
determination. Biol. Cybernetics 84(6):463-474, 2001.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.PHI">
<tt class="descname">PHI</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.PHI" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase angle</p>
<p>Returns the phase angle of complex <a class="reference internal" href="#scot.connectivity.Connectivity.S" title="scot.connectivity.Connectivity.S"><tt class="xref py py-func docutils literal"><span class="pre">S()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.S">
<tt class="descname">S</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.S" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross spectral density</p>
<div class="math">
\[\mathbf{S}(f) = \mathbf{H}(f) \mathbf{C} \mathbf{H}'(f)\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.absS">
<tt class="descname">absS</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.absS" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute cross spectral density</p>
<div class="math">
\[\mathrm{absS}(f) = | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.dDTF">
<tt class="descname">dDTF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.dDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8221; Direct&#8221; directed transfer function</p>
<div class="math">
\[\mathrm{dDTF}_{ij}(f) = |\mathrm{pCOH}_{ij}(f)| \mathrm{ffDTF}_{ij}(f)\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki. Determination of
information flow direction among brain structures by a modified directed transfer 
function (dDTF) method. J. Neurosci. Meth. 125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.ffDTF">
<tt class="descname">ffDTF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.ffDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Full frequency directed transfer function</p>
<div class="math">
\[\mathrm{ffDTF}_{ij}(f) = \frac{H_{ij}(f)}{\sqrt{\sum_f H_{i:}(f) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki. Determination of
information flow direction among brain structures by a modified directed transfer 
function (dDTF) method. J. Neurosci. Meth. 125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.ffPDC">
<tt class="descname">ffPDC</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.ffPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Full frequency partial directed coherence</p>
<div class="math">
\[\mathrm{ffPDC}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{\sum_f A_{:j}'(f) A_{:j}(f)}}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.logG">
<tt class="descname">logG</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.logG" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithmic inverse cross spectral density</p>
<div class="math">
\[\mathrm{logG}(f) = \log | \mathbf{G}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.logS">
<tt class="descname">logS</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.logS" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithmic cross spectral density</p>
<div class="math">
\[\mathrm{logS}(f) = \log | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.connectivity.Connectivity.pCOH">
<tt class="descname">pCOH</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.connectivity.Connectivity.pCOH" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial coherence</p>
<div class="math">
\[\mathrm{pCOH}_{ij}(f) = \frac{G_{ij}(f)}{\sqrt{G_{ii}(f) G_{jj}(f)}}\]</div>
<p class="rubric">References</p>
<p>P. J. Franaszczuk, K. J. Blinowska, M. Kowalczyk. The application of parametric multichannel
spectral estimates in the study of electrical brain activity. Biol. Cybernetics 51(4): 239-247, 1985.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="scot.connectivity.connectivity">
<tt class="descclassname">scot.connectivity.</tt><tt class="descname">connectivity</tt><big>(</big><em>measure_names</em>, <em>b</em>, <em>c=None</em>, <em>nfft=512</em><big>)</big><a class="headerlink" href="#scot.connectivity.connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate connectivity measures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <a class="reference internal" href="#scot.connectivity.Connectivity" title="scot.connectivity.Connectivity"><tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt></a> for supported measures.</p>
</div></blockquote>
<p><strong>b</strong> : ndarray, shape = [n_channels, n_channels*model_order]</p>
<blockquote>
<div><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><em>On the arrangement of VAR model coefficients</em></a> for details about the arrangement of coefficients.</p>
</div></blockquote>
<p><strong>c</strong> : ndarray, shape = [n_channels, n_channels], optional</p>
<blockquote>
<div><p>Covariance matrix of the driving noise process. Identity matrix is used if set to None.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins to calculate. Note that these points cover the range between 0 and half the
sampling rate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : ndarray, shape = [n_channels, n_channels, <cite>nfft</cite>]</p>
<blockquote class="last">
<div><p>An ndarray of shape [m, m, nfft] is returned if measures is a string. If measures is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are ndarrays
of shape [m, m, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>When using this function it is more efficient to get several measures at once than calling the function multiple times.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">([</span><span class="s">&#39;DTF&#39;</span><span class="p">,</span> <span class="s">&#39;PDC&#39;</span><span class="p">],</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-scot.connectivity_statistics">
<span id="scot-connectivity-statistics-module"></span><h2>scot.connectivity_statistics module<a class="headerlink" href="#module-scot.connectivity_statistics" title="Permalink to this headline">¶</a></h2>
<p>Routines for statistical evaluation of connectivity.</p>
<dl class="function">
<dt id="scot.connectivity_statistics.bootstrap_connectivity">
<tt class="descclassname">scot.connectivity_statistics.</tt><tt class="descname">bootstrap_connectivity</tt><big>(</big><em>measures</em>, <em>data</em>, <em>var</em>, <em>nfft=512</em>, <em>repeats=100</em>, <em>num_samples=None</em><big>)</big><a class="headerlink" href="#scot.connectivity_statistics.bootstrap_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Bootstrap estimates of connectivity.</p>
<p>To obtain a bootstrap estimate trials are sampled randomly with replacement from the data set.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>var</cite> will be modified by the function. Treat as undefined after the function returned.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>data</strong> : ndarray, shape = [n_samples, n_channels, (n_trials)]</p>
<blockquote>
<div><p>Time series data (2D or 3D for multiple trials)</p>
</div></blockquote>
<p><strong>var</strong> : VARBase-like object</p>
<blockquote>
<div><p>Instance of a VAR model.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each bootstrap estimate. If <cite>measure_names</cite> is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are
ndarrays of shape [<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.convert_output_">
<tt class="descclassname">scot.connectivity_statistics.</tt><tt class="descname">convert_output_</tt><big>(</big><em>output</em>, <em>measures</em><big>)</big><a class="headerlink" href="#scot.connectivity_statistics.convert_output_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.jackknife_connectivity">
<tt class="descclassname">scot.connectivity_statistics.</tt><tt class="descname">jackknife_connectivity</tt><big>(</big><em>measure_names</em>, <em>data</em>, <em>var</em>, <em>nfft=512</em>, <em>leaveout=1</em><big>)</big><a class="headerlink" href="#scot.connectivity_statistics.jackknife_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Jackknife estimates of connectivity.</p>
<p>For each Jackknife estimate a block of trials is left out. This is repeated until each trial was left out exactly
once. The number of estimates depends on the number of trials and the value of <cite>leaveout</cite>. It is calculated by
repeats = n_trials // leaveout.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>var</cite> will be modified by the function. Treat as undefined after the function returned.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>data</strong> : ndarray, shape = [n_samples, n_channels, (n_trials)]</p>
<blockquote>
<div><p>Time series data (2D or 3D for multiple trials)</p>
</div></blockquote>
<p><strong>var</strong> : VARBase-like object</p>
<blockquote>
<div><p>Instance of a VAR model.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins to calculate. Note that these points cover the range between 0 and half the
sampling rate.</p>
</div></blockquote>
<p><strong>leaveout</strong> : int, optional</p>
<blockquote>
<div><p>Number of trials to leave out in each estimate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each surrogate. If <cite>measure_names</cite> is a list of strings a dictionary
is returned, where each key is the name of the measure, and the corresponding values are ndarrays of shape
[<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.significance_fdr">
<tt class="descclassname">scot.connectivity_statistics.</tt><tt class="descname">significance_fdr</tt><big>(</big><em>p</em>, <em>alpha</em><big>)</big><a class="headerlink" href="#scot.connectivity_statistics.significance_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate significance by controlling for the false discovery rate.</p>
<p>This function determines which of the <em>p</em>-values in <cite>p</cite> can be considered significant. Correction for multiple
comparisons is performed by controlling the false discovery rate (FDR). The FDR is the maximum fraction of
<em>p</em>-values that are wrongly considered significant <a class="reference internal" href="#r2" id="id3">[R2]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> : ndarray, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p><em>p</em>-values</p>
</div></blockquote>
<p><strong>alpha</strong> : float</p>
<blockquote>
<div><p>Maximum false discovery rate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong> : ndarray, dtype=bool, shape = [n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Significance of each <em>p</em>-value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Y. Benjamini, Y. Hochberg, &#8220;Controlling the false discovery rate: a practical and powerful approach to
multiple testing&#8221;, Journal of the Royal Statistical Society, Series B 57(1), pp 289-300, 1995</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.surrogate_connectivity">
<tt class="descclassname">scot.connectivity_statistics.</tt><tt class="descname">surrogate_connectivity</tt><big>(</big><em>measure_names</em>, <em>data</em>, <em>var</em>, <em>nfft=512</em>, <em>repeats=100</em><big>)</big><a class="headerlink" href="#scot.connectivity_statistics.surrogate_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates surrogate connectivity for a multivariate time series by phase randomization <a class="reference internal" href="#r3" id="id5">[R3]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>var</cite> will be modified by the function. Treat as undefined after the function returned.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>data</strong> : ndarray, shape = [n_samples, n_channels, (n_trials)]</p>
<blockquote>
<div><p>Time series data (2D or 3D for multiple trials)</p>
</div></blockquote>
<p><strong>var</strong> : VARBase-like object</p>
<blockquote>
<div><p>Instance of a VAR model.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins to calculate. Note that these points cover the range between 0 and half the
sampling rate.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Values of the connectivity measure for each surrogate. If <cite>measure_names</cite> is a list of strings a dictionary
is returned, where each key is the name of the measure, and the corresponding values are ndarrays of shape
[<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
<table class="last docutils citation" frame="void" id="r3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R3]</a></td><td><ol class="first upperalpha simple" start="10">
<li>Theiler et al. &#8220;Testing for nonlinearity in time series: the method of surrogate data&#8221;, Physica D,</li>
</ol>
<p class="last">vol 58, pp. 77-94, 1992</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.connectivity_statistics.test_bootstrap_difference">
<tt class="descclassname">scot.connectivity_statistics.</tt><tt class="descname">test_bootstrap_difference</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#scot.connectivity_statistics.test_bootstrap_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Test mean difference between two bootstrap estimates.</p>
<p>This function calculates the probability <cite>p</cite> of observing a more extreme mean difference between <cite>a</cite> and <cite>b</cite> under the
null hypothesis that <cite>a</cite> and <cite>b</cite> come from the same distribution.</p>
<p>If p is smaller than e.g. 0.05 we can reject the null hypothesis at an alpha-level of 0.05 and conclude that <cite>a</cite> and
<cite>b</cite> are likely to come from different distributions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><em>p</em>-values are calculated along the first dimension. Thus, n_channels * n_channels * nfft individual
<em>p</em>-values are obtained. To determine if a difference is significant it is important to correct for
multiple testing.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a, b</strong> : ndarray, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Two bootstrap estimates to compare. The number of repetitions (first dimension) does not have be equal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : ndarray, shape = [n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p><em>p</em>-values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.significance_fdr" title="scot.connectivity_statistics.significance_fdr"><tt class="xref py py-func docutils literal"><span class="pre">significance_fdr()</span></tt></a></dt>
<dd>Correct for multiple testing by controlling the false discovery rate.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The function estimates the distribution of <cite>b[j]</cite> - <cite>a[i]</cite> by calculating the difference for each combination of <cite>i</cite>
and <cite>j</cite>. The total number of difference samples available is therefore a.shape[0] * b.shape[0].
The <em>p</em>-value is calculated as the smallest percentile of that distribution that does not contain 0.</p>
</dd></dl>

</div>
<div class="section" id="module-scot.csp">
<span id="scot-csp-module"></span><h2>scot.csp module<a class="headerlink" href="#module-scot.csp" title="Permalink to this headline">¶</a></h2>
<p>common spatial patterns (CSP) implementation</p>
<dl class="function">
<dt id="scot.csp.csp">
<tt class="descclassname">scot.csp.</tt><tt class="descname">csp</tt><big>(</big><em>x</em>, <em>cl</em>, <em>numcomp=inf</em><big>)</big><a class="headerlink" href="#scot.csp.csp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate common spatial patterns (CSP)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys</p>
<blockquote>
<div><p>Class labels associated with each trial. Currently only two classes are supported.</p>
</div></blockquote>
<p><strong>numcomp</strong> : {int}, optional</p>
<blockquote>
<div><p>Number of patterns to keep after applying the CSP. If <cite>numcomp</cite> is greater than n_channels, all n_channels
patterns are returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array, shape = [n_channels, n_components]</p>
<blockquote>
<div><p>CSP weight matrix</p>
</div></blockquote>
<p><strong>v</strong> : array, shape = [n_components, n_channels]</p>
<blockquote class="last">
<div><p>CSP projection matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.datatools">
<span id="scot-datatools-module"></span><h2>scot.datatools module<a class="headerlink" href="#module-scot.datatools" title="Permalink to this headline">¶</a></h2>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>Tools for basic data manipulation.</p>
<dl class="function">
<dt id="scot.datatools.cat_trials">
<tt class="descclassname">scot.datatools.</tt><tt class="descname">cat_trials</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#scot.datatools.cat_trials" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate trials along time axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>Segmented input data of shape [<cite>n</cite>,`m`,`t`], with <cite>n</cite> time samples, <cite>m</cite> signals, and <cite>t</cite> trials.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>Trials are concatenated along the first (time) axis. Shape of the output is [<cite>n``t</cite>,`m`].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.datatools.cut_segments" title="scot.datatools.cut_segments"><tt class="xref py py-obj docutils literal"><span class="pre">cut_segments</span></tt></a></dt>
<dd>Cut segments from continuous data</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">cat_trials</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(900, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scot.datatools.cut_segments">
<tt class="descclassname">scot.datatools.</tt><tt class="descname">cut_segments</tt><big>(</big><em>rawdata</em>, <em>tr</em>, <em>start</em>, <em>stop</em><big>)</big><a class="headerlink" href="#scot.datatools.cut_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Cut continuous signal into segments.</p>
<p>This function cuts segments from a continuous signal. Segments are stop - start samples long.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rawdata</strong> : array_like</p>
<blockquote>
<div><p>Input data of shape [<cite>n</cite>,`m`], with <cite>n</cite> samples and <cite>m</cite> signals.</p>
</div></blockquote>
<p><strong>tr</strong> : list of int</p>
<blockquote>
<div><p>Trigger positions.</p>
</div></blockquote>
<p><strong>start</strong> : int</p>
<blockquote>
<div><p>Window start (offset relative to trigger)</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote>
<div><p>Window end (offset relative to trigger)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>x</strong> : ndarray</p>
<blockquote class="last">
<div><p>Segments cut from <cite>rawdata</cite>. Individual segments are stacked along the third dimension.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.datatools.cat_trials" title="scot.datatools.cat_trials"><tt class="xref py py-obj docutils literal"><span class="pre">cat_trials</span></tt></a></dt>
<dd>Concatenate segments</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">750</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cut_segments</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(50, 5, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scot.datatools.dot_special">
<tt class="descclassname">scot.datatools.</tt><tt class="descname">dot_special</tt><big>(</big><em>x</em>, <em>a</em><big>)</big><a class="headerlink" href="#scot.datatools.dot_special" title="Permalink to this definition">¶</a></dt>
<dd><p>Trial-wise dot product.</p>
<p>This function calculates the dot product of <cite>x[:,:,i]</cite> with <cite>a</cite> for each <cite>i</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array_like</p>
<blockquote>
<div><p>Segmented input data of shape [<cite>n</cite>,`m`,`t`], with <cite>n</cite> time samples, <cite>m</cite> signals, and <cite>t</cite> trials.
The dot product is calculated for each trial.</p>
</div></blockquote>
<p><strong>a</strong> : array_like</p>
<blockquote>
<div><p>Second argument</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>Returns the dot product of each trial.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">40</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">dot_special</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(150, 7, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scot.datatools.randomize_phase">
<tt class="descclassname">scot.datatools.</tt><tt class="descname">randomize_phase</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.datatools.randomize_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase randomization.</p>
<p>This function randomizes the input array&#8217;s spectral phase along the first dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array_like</p>
<blockquote>
<div><p>Input array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>Array of same shape as <cite>data</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm randomizes the phase component of the input&#8217;s complex fourier transform.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scot.datatools</span> <span class="kn">import</span> <span class="n">randomize_phase</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">randomize_phase</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">title</span><span class="p">(</span><span class="s">&#39;Phase randomization of sine wave and rectangular function&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../../api/scot/scot-1.py">Source code</a>, <a class="reference external" href="../../api/scot/scot-1.png">png</a>, <a class="reference external" href="../../api/scot/scot-1.hires.png">hires.png</a>, <a class="reference external" href="../../api/scot/scot-1.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../../_images/scot-1.png" src="../../_images/scot-1.png" />
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-scot.matfiles">
<span id="scot-matfiles-module"></span><h2>scot.matfiles module<a class="headerlink" href="#module-scot.matfiles" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id6">
<h3>Summary<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Routines for loading and saving Matlab&#8217;s .mat files.</p>
<dl class="function">
<dt id="scot.matfiles.loadmat">
<tt class="descclassname">scot.matfiles.</tt><tt class="descname">loadmat</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#scot.matfiles.loadmat" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should be called instead of direct spio.loadmat
as it cures the problem of not properly recovering python dictionaries
from mat files. It calls the function check keys to cure all entries
which are still mat-objects</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-scot.ooapi">
<span id="scot-ooapi-module"></span><h2>scot.ooapi module<a class="headerlink" href="#module-scot.ooapi" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id7">
<h3>Summary<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Object oriented API to SCoT.</p>
</div>
<div class="section" id="extended-summary">
<h3>Extended Summary<a class="headerlink" href="#extended-summary" title="Permalink to this headline">¶</a></h3>
<p>The object oriented API provides a the <cite>Workspace</cite> class, which provides high-level functionality and serves as an
example usage of the low-level API.</p>
<dl class="class">
<dt id="scot.ooapi.Workspace">
<em class="property">class </em><tt class="descclassname">scot.ooapi.</tt><tt class="descname">Workspace</tt><big>(</big><em>var</em>, <em>locations=None</em>, <em>reducedim=0.99</em>, <em>nfft=512</em>, <em>fs=2</em>, <em>backend=None</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>SCoT Workspace</p>
<p>This class provides high-level functionality for source identification, connectivity estimation, and visualization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>var</strong> : {<tt class="xref py py-class docutils literal"><span class="pre">VARBase</span></tt>-like object, dict}</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object that is used for model fitting.
This can also be a dictionary that is passed as <cite>**kwargs</cite> to backend[&#8216;var&#8217;]() in order to
construct a new VAR model object.</p>
</div></blockquote>
<p><strong>locations</strong> : array_like, optional</p>
<blockquote>
<div><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int, float, &#8216;no_pca&#8217;}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer numer of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to &#8216;no_pca&#8217; the PCA step is skipped.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins for connectivity estimation.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote class="last">
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>unmixing_</cite></td>
<td>(array) Estimated unmixing matrix.</td>
</tr>
<tr class="row-even"><td><cite>mixing_</cite></td>
<td>(array) Estimated mixing matrix.</td>
</tr>
<tr class="row-odd"><td><cite>plot_diagonal</cite></td>
<td>(str) Configures what is plotted in the diagonal subplots. <strong>&#8216;topo&#8217;</strong> (default) plots topoplots on the diagonal, <strong>&#8216;S&#8217;</strong> plots the spectral density of each component, and <strong>&#8216;fill&#8217;</strong> plots connectivity on the diagonal.</td>
</tr>
<tr class="row-even"><td><cite>plot_outside_topo</cite></td>
<td>(bool) Whether to place topoplots in the left column and top row.</td>
</tr>
<tr class="row-odd"><td><cite>plot_f_range</cite></td>
<td>((int, int)) Lower and upper frequency limits for plotting. Defaults to [0, fs/2].</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.ooapi.Workspace.compare_conditions">
<tt class="descname">compare_conditions</tt><big>(</big><em>labels1</em>, <em>labels2</em>, <em>measure_name</em>, <em>alpha=0.01</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>plot=False</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.compare_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for significant difference in connectivity of two sets of class labels.</p>
<p>Connectivity estimates are obtained by bootstrapping. Correction for multiple testing is performed by
controlling the false discovery rate (FDR).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels1, labels2</strong> : list of class labels</p>
<blockquote>
<div><p>The two sets of class labels to compare. Each set may contain more than one label.</p>
</div></blockquote>
<p><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>alpha</strong> : float, optional</p>
<blockquote>
<div><p>Maximum allowed FDR. The ratio of falsely detected significant differences is guaranteed to be less than
<cite>alpha</cite>.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : array, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Uncorrected p-values.</p>
</div></blockquote>
<p><strong>s</strong> : array, dtype=bool, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>FDR corrected significance. True means the difference is significant in this location.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.do_cspvarica">
<tt class="descname">do_cspvarica</tt><big>(</big><em>varfit='ensemble'</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.do_cspvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform CSPVARICA</p>
<p>Perform CSPVARICA source decomposition and VAR model fitting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a different model for each class, and
&#8216;trial&#8217; fits a different model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <tt class="xref py py-func docutils literal"><span class="pre">cspvarica()</span></tt> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-func docutils literal"><span class="pre">cspvarica()</span></tt></dt>
<dd>CSPVARICA implementation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.do_ica">
<tt class="descname">do_ica</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.do_ica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform ICA</p>
<p>Perform plain ICA source decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <tt class="xref py py-func docutils literal"><span class="pre">plainica()</span></tt> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.do_mvarica">
<tt class="descname">do_mvarica</tt><big>(</big><em>varfit='ensemble'</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.do_mvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform MVARICA</p>
<p>Perform MVARICA source decomposition and VAR model fitting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a different model for each class, and
&#8216;trial&#8217; fits a different model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <tt class="xref py py-func docutils literal"><span class="pre">mvarica()</span></tt> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-func docutils literal"><span class="pre">mvarica()</span></tt></dt>
<dd>MVARICA implementation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.fit_var">
<tt class="descname">fit_var</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.fit_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a var model to the source activations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain source activations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.get_bootstrap_connectivity">
<tt class="descname">get_bootstrap_connectivity</tt><big>(</big><em>measure_names</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>plot=False</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.get_bootstrap_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bootstrap estimates of spectral connectivity measures.</p>
<p>Bootstrapping is performed on trial level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each bootstrap estimate. If <cite>measure_names</cite> is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are
ndarrays of shape [<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.bootstrap_connectivity" title="scot.connectivity_statistics.bootstrap_connectivity"><tt class="xref py py-func docutils literal"><span class="pre">scot.connectivity_statistics.bootstrap_connectivity()</span></tt></a></dt>
<dd>Calculates bootstrap connectivity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.get_connectivity">
<tt class="descname">get_connectivity</tt><big>(</big><em>measure_name</em>, <em>plot=False</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.get_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Values of the connectivity measure.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object</p>
<blockquote>
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain a fitted VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.get_surrogate_connectivity">
<tt class="descname">get_surrogate_connectivity</tt><big>(</big><em>measure_name</em>, <em>repeats=100</em>, <em>plot=False</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.get_surrogate_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each surrogate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.surrogate_connectivity" title="scot.connectivity_statistics.surrogate_connectivity"><tt class="xref py py-func docutils literal"><span class="pre">scot.connectivity_statistics.surrogate_connectivity()</span></tt></a></dt>
<dd>Calculates surrogate connectivity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.get_tf_connectivity">
<tt class="descname">get_tf_connectivity</tt><big>(</big><em>measure_name</em>, <em>winlen</em>, <em>winstep</em>, <em>plot=False</em>, <em>crange='default'</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.get_tf_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate estimate of time-varying connectivity.</p>
<p>Connectivity is estimated in a sliding window approach on the current data set. The window is stepped
<cite>n_steps</cite> = (<cite>n_samples</cite> - <cite>winlen</cite>) // <cite>winstep</cite> times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>winlen</strong> : int</p>
<blockquote>
<div><p>Length of the sliding window (in samples).</p>
</div></blockquote>
<p><strong>winstep</strong> : int</p>
<blockquote>
<div><p>Step size for sliding window (in samples).</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array, shape = [n_channels, n_channels, nfft, n_steps]</p>
<blockquote>
<div><p>Values of the connectivity measure.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain a fitted VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.optimize_var">
<tt class="descname">optimize_var</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.optimize_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the var model&#8217;s hyperparameters (such as regularization).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain source activations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.plot_connectivity_surrogate">
<tt class="descname">plot_connectivity_surrogate</tt><big>(</big><em>measure_name</em>, <em>repeats=100</em>, <em>fig=None</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.plot_connectivity_surrogate" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
<p><strong>fig</strong> : {None, Figure object}, optional</p>
<blockquote>
<div><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.plot_connectivity_topos">
<tt class="descname">plot_connectivity_topos</tt><big>(</big><em>fig=None</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.plot_connectivity_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot scalp projections of the sources.</p>
<p>This function only plots the topos. Use in combination with connectivity plotting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fig</strong> : {None, Figure object}, optional</p>
<blockquote>
<div><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.plot_source_topos">
<tt class="descname">plot_source_topos</tt><big>(</big><em>common_scale=None</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.plot_source_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topography of the Source decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>common_scale</strong> : float, optional</p>
<blockquote class="last">
<div><p>If set to None, each topoplot&#8217;s color axis is scaled individually. Otherwise specifies the percentile
(1-99) of values in all plot. This value is taken as the maximum color scale.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="scot.ooapi.Workspace.plotting">
<tt class="descname">plotting</tt><a class="headerlink" href="#scot.ooapi.Workspace.plotting" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.remove_sources">
<tt class="descname">remove_sources</tt><big>(</big><em>sources</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.remove_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sources from the decomposition.</p>
<p>This function removes sources from the decomposition. Doing so invalidates currently fitted VAR models and
connectivity estimates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sources</strong> : {slice, int, array of ints}</p>
<blockquote>
<div><p>Indices of components to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.ooapi.Workspace" title="scot.ooapi.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain a source decomposition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.set_data">
<tt class="descname">set_data</tt><big>(</big><em>data</em>, <em>cl=None</em>, <em>time_offset=0</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign data to the workspace.</p>
<p>This function assigns a new data set to the workspace. Doing so invalidates currently fitted VAR models,
connectivity estimates, and activations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys</p>
<blockquote>
<div><p>Class labels associated with each trial.</p>
</div></blockquote>
<p><strong>time_offset</strong> : float, optional</p>
<blockquote class="last">
<div><p>Trial starting time; used for labelling the x-axis of time/frequency plots.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.set_locations">
<tt class="descname">set_locations</tt><big>(</big><em>locations</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.set_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sensor locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>locations</strong> : array_like</p>
<blockquote class="last">
<div><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.set_premixing">
<tt class="descname">set_premixing</tt><big>(</big><em>premixing</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.set_premixing" title="Permalink to this definition">¶</a></dt>
<dd><p>Set premixing matrix.</p>
<p>The premixing matrix maps data to physical channels. If the data is actual channel data,
the premixing matrix can be set to identity. Use this functionality if the data was pre-
transformed with e.g. PCA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>premixing</strong> : array_like, shape = [n_signals, n_channels]</p>
<blockquote class="last">
<div><p>Matrix that maps data signals to physical channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.set_used_labels">
<tt class="descname">set_used_labels</tt><big>(</big><em>labels</em><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.set_used_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify which trials to use in subsequent analysis steps.</p>
<p>This function masks trials based on their class labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : list of class labels</p>
<blockquote class="last">
<div><p>Marks all trials that have a label that is in the <cite>labels</cite> list for further processing.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.ooapi.Workspace.show_plots">
<tt class="descname">show_plots</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.ooapi.Workspace.show_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Show current plots.</p>
<p>This is only a convenience wrapper around <tt class="xref py py-func docutils literal"><span class="pre">matplotlib.pyplot.show_plots()</span></tt>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-scot.pca">
<span id="scot-pca-module"></span><h2>scot.pca module<a class="headerlink" href="#module-scot.pca" title="Permalink to this headline">¶</a></h2>
<p>principal component analysis (PCA) implementation</p>
<dl class="function">
<dt id="scot.pca.pca">
<tt class="descclassname">scot.pca.</tt><tt class="descname">pca</tt><big>(</big><em>x</em>, <em>subtract_mean=False</em>, <em>normalize=False</em>, <em>sort_components=True</em>, <em>reducedim=None</em>, <em>algorithm=&lt;function pca_eig at 0x7fde0498da60&gt;</em><big>)</big><a class="headerlink" href="#scot.pca.pca" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate principal component analysis (PCA)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>subtract_mean</strong> : bool, optional</p>
<blockquote>
<div><p>Subtract sample mean from x.</p>
</div></blockquote>
<p><strong>normalize</strong> : bool, optional</p>
<blockquote>
<div><p>Normalize variances to 1 before applying PCA.</p>
</div></blockquote>
<p><strong>sort_components</strong> : bool, optional</p>
<blockquote>
<div><p>Sort principal components in order of decreasing eigenvalues.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {float, int}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer numer of 1 or greater is interpreted as the number of components to keep after applying the PCA.</p>
</div></blockquote>
<p><strong>algorithm</strong> : func, optional</p>
<blockquote>
<div><p>Specify function to use for eigenvalue decomposition (<a class="reference internal" href="#scot.pca.pca_eig" title="scot.pca.pca_eig"><tt class="xref py py-func docutils literal"><span class="pre">pca_eig()</span></tt></a> or <a class="reference internal" href="#scot.pca.pca_svd" title="scot.pca.pca_svd"><tt class="xref py py-func docutils literal"><span class="pre">pca_svd()</span></tt></a>)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array, shape = [n_channels, n_components]</p>
<blockquote>
<div><p>PCA transformation matrix</p>
</div></blockquote>
<p><strong>v</strong> : array, shape = [n_components, n_channels]</p>
<blockquote class="last">
<div><p>PCA backtransformation matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.pca.pca_eig">
<tt class="descclassname">scot.pca.</tt><tt class="descname">pca_eig</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#scot.pca.pca_eig" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate PCA using Eigenvalue decomposition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape = [n_samples, n_channels]</p>
<blockquote>
<div><p>Two dimensional data array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array</p>
<blockquote>
<div><p>Eigenvectors</p>
</div></blockquote>
<p><strong>s</strong> : array</p>
<blockquote class="last">
<div><p>Eigenvalues</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.pca.pca_svd">
<tt class="descclassname">scot.pca.</tt><tt class="descname">pca_svd</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.pca.pca_svd" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate PCA using SVD</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape = [n_samples, n_channels]</p>
<blockquote>
<div><p>Two dimensional data array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : array</p>
<blockquote>
<div><p>Eigenvectors</p>
</div></blockquote>
<p><strong>s</strong> : array</p>
<blockquote class="last">
<div><p>Eigenvalues</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.plainica">
<span id="scot-plainica-module"></span><h2>scot.plainica module<a class="headerlink" href="#module-scot.plainica" title="Permalink to this headline">¶</a></h2>
<p>Source decomposition with ICA.</p>
<dl class="class">
<dt id="scot.plainica.ResultICA">
<em class="property">class </em><tt class="descclassname">scot.plainica.</tt><tt class="descname">ResultICA</tt><big>(</big><em>mx</em>, <em>ux</em><big>)</big><a class="headerlink" href="#scot.plainica.ResultICA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Result of <a class="reference internal" href="#scot.plainica.plainica" title="scot.plainica.plainica"><tt class="xref py py-func docutils literal"><span class="pre">plainica()</span></tt></a></p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>mixing</cite></td>
<td>(array) estimate of the mixing matrix</td>
</tr>
<tr class="row-even"><td><cite>unmixing</cite></td>
<td>(array) estimate of the unmixing matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plainica.plainica">
<tt class="descclassname">scot.plainica.</tt><tt class="descname">plainica</tt><big>(</big><em>x</em>, <em>reducedim=0.99</em>, <em>backend=None</em><big>)</big><a class="headerlink" href="#scot.plainica.plainica" title="Permalink to this definition">¶</a></dt>
<dd><p>Source decomposition with ICA.</p>
<p>Apply ICA to the data x, with optional PCA dimensionality reduction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>data set</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int, float, &#8216;no_pca&#8217;}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer numer of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to &#8216;no_pca&#8217; the PCA step is skipped.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote>
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : ResultICA</p>
<blockquote class="last">
<div><p>Source decomposition</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.plotting">
<span id="scot-plotting-module"></span><h2>scot.plotting module<a class="headerlink" href="#module-scot.plotting" title="Permalink to this headline">¶</a></h2>
<p>Graphical output with matplotlib</p>
<p>This module attempts to import matplotlib for plotting functionality.
If matplotlib is not available no error is raised, but plotting functions will not be available.</p>
<dl class="function">
<dt id="scot.plotting.MaxNLocator">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">MaxNLocator</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scot.plotting.MaxNLocator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.plotting.current_axis">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">current_axis</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.plotting.current_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.plotting.new_figure">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">new_figure</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scot.plotting.new_figure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_circular">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">plot_circular</tt><big>(</big><em>widths</em>, <em>colors</em>, <em>curviness=0.2</em>, <em>mask=True</em>, <em>topo=None</em>, <em>topomaps=None</em>, <em>axes=None</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#scot.plotting.plot_circular" title="Permalink to this definition">¶</a></dt>
<dd><p>Circluar connectivity plot</p>
<p>Topos are arranged in a circle, with arrows indicating connectivity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>widths</strong> : {float or array, shape = [n_channels, n_channels]}</p>
<blockquote>
<div><p>Width of each arrow. Can be a scalar to assign the same width to all arrows.</p>
</div></blockquote>
<p><strong>colors</strong> : array, shape = [n_channels, n_channels, 3] or [3]</p>
<blockquote>
<div><p>RGB color values for each arrow or one RGB color value for all arrows.</p>
</div></blockquote>
<p><strong>curviness</strong> : float, optional</p>
<blockquote>
<div><p>Factor that determines how much arrows tend to deviate from a straight line.</p>
</div></blockquote>
<p><strong>mask</strong> : array, dtype = bool, shape = [n_channels, n_channels]</p>
<blockquote>
<div><p>Enable or disable individual arrows</p>
</div></blockquote>
<p><strong>topo</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Topoplot</span></tt></p>
<blockquote>
<div><p>This object draws the topo plot</p>
</div></blockquote>
<p><strong>topomaps</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected map</p>
</div></blockquote>
<p><strong>axes</strong> : axis, optional</p>
<blockquote>
<div><p>Axis to draw into. A new figure is created by default.</p>
</div></blockquote>
<p><strong>order</strong> : list of int</p>
<blockquote>
<div><p>Rearrange channels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>axes</strong> : Axes object</p>
<blockquote class="last">
<div><p>The axes into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_connectivity_significance">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">plot_connectivity_significance</tt><big>(</big><em>s</em>, <em>fs=2</em>, <em>freq_range=(-inf</em>, <em>inf)</em>, <em>diagonal=0</em>, <em>border=False</em>, <em>fig=None</em><big>)</big><a class="headerlink" href="#scot.plotting.plot_connectivity_significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot significance.</p>
<p>Significance is drawn as a background image where dark vertical stripes indicate freuquencies where a evaluates to
True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array, dtype=bool, shape = [n_channels, n_channels, n_fft]</p>
<blockquote>
<div><p>Significance</p>
</div></blockquote>
<p><strong>fs</strong> : float</p>
<blockquote>
<div><p>Sampling frequency</p>
</div></blockquote>
<p><strong>freq_range</strong> : (float, float)</p>
<blockquote>
<div><p>Frequency range to plot</p>
</div></blockquote>
<p><strong>diagonal</strong> : {-1, 0, 1}</p>
<blockquote>
<div><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</div></blockquote>
<p><strong>border</strong> : bool</p>
<blockquote>
<div><p>If border == true the leftmost column and the topmost row are left blank</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_connectivity_spectrum">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">plot_connectivity_spectrum</tt><big>(</big><em>a</em>, <em>fs=2</em>, <em>freq_range=(-inf</em>, <em>inf)</em>, <em>diagonal=0</em>, <em>border=False</em>, <em>fig=None</em><big>)</big><a class="headerlink" href="#scot.plotting.plot_connectivity_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw connectivity plots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array, shape = [n_channels, n_channels, n_fft] or [1 or 3, n_channels, n_channels, n_fft]</p>
<blockquote>
<div><p>If a.ndim == 3, normal plots are created,
If a.ndim == 4 and a.shape[0] == 1, the area between the curve and y=0 is filled transparently,
If a.ndim == 4 and a.shape[0] == 3, a[0,:,:,:] is plotted normally and the area between a[1,:,:,:] and
a[2,:,:,:] is filled transparently.</p>
</div></blockquote>
<p><strong>fs</strong> : float</p>
<blockquote>
<div><p>Sampling frequency</p>
</div></blockquote>
<p><strong>freq_range</strong> : (float, float)</p>
<blockquote>
<div><p>Frequency range to plot</p>
</div></blockquote>
<p><strong>diagonal</strong> : {-1, 0, 1}</p>
<blockquote>
<div><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</div></blockquote>
<p><strong>border</strong> : bool</p>
<blockquote>
<div><p>If border == true the leftmost column and the topmost row are left blank</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_connectivity_timespectrum">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">plot_connectivity_timespectrum</tt><big>(</big><em>a</em>, <em>fs=2</em>, <em>crange=None</em>, <em>freq_range=(-inf</em>, <em>inf)</em>, <em>time_range=None</em>, <em>diagonal=0</em>, <em>border=False</em>, <em>fig=None</em><big>)</big><a class="headerlink" href="#scot.plotting.plot_connectivity_timespectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw time/frequency connectivity plots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array, shape = [n_channels, n_channels, n_fft, n_timesteps]</p>
<blockquote>
<div><p>Values to draw</p>
</div></blockquote>
<p><strong>fs</strong> : float</p>
<blockquote>
<div><p>Sampling frequency</p>
</div></blockquote>
<p><strong>crange</strong> : [int, int], optional</p>
<blockquote>
<div><p>Range of values covered by the colormap.
If set to None, [min(a), max(a)] is substituted.</p>
</div></blockquote>
<p><strong>freq_range</strong> : (float, float)</p>
<blockquote>
<div><p>Frequency range to plot</p>
</div></blockquote>
<p><strong>time_range</strong> : (float, float)</p>
<blockquote>
<div><p>Time range covered by <cite>a</cite></p>
</div></blockquote>
<p><strong>diagonal</strong> : {-1, 0, 1}</p>
<blockquote>
<div><p>If diagonal == -1 nothing is plotted on the diagonal (a[i,i,:] are not plotted),
if diagonal == 0, a is plotted on the diagonal too (all a[i,i,:] are plotted),
if diagonal == 1, a is plotted on the diagonal only (only a[i,i,:] are plotted)</p>
</div></blockquote>
<p><strong>border</strong> : bool</p>
<blockquote>
<div><p>If border == true the leftmost column and the topmost row are left blank</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_connectivity_topos">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">plot_connectivity_topos</tt><big>(</big><em>layout='diagonal'</em>, <em>topo=None</em>, <em>topomaps=None</em>, <em>fig=None</em><big>)</big><a class="headerlink" href="#scot.plotting.plot_connectivity_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Place topo plots in a figure suitable for connectivity visualization.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>topo</cite> is modified by the function by calling <tt class="xref py py-func docutils literal"><span class="pre">set_map()</span></tt>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>layout</strong> : str</p>
<blockquote>
<div><p>&#8216;diagonal&#8217; -&gt; place topo plots on diagonal.
otherwise -&gt; place topo plots in left column and top row.</p>
</div></blockquote>
<p><strong>topo</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Topoplot</span></tt></p>
<blockquote>
<div><p>This object draws the topo plot</p>
</div></blockquote>
<p><strong>topomaps</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected map</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_sources">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">plot_sources</tt><big>(</big><em>topo</em>, <em>mixmaps</em>, <em>unmixmaps</em>, <em>global_scale=None</em>, <em>fig=None</em><big>)</big><a class="headerlink" href="#scot.plotting.plot_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot all scalp projections of mixing- and unmixing-maps.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>topo</cite> is modified by the function by calling <tt class="xref py py-func docutils literal"><span class="pre">set_map()</span></tt>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topo</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Topoplot</span></tt></p>
<blockquote>
<div><p>This object draws the topo plot</p>
</div></blockquote>
<p><strong>mixmaps</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected mixing matrix</p>
</div></blockquote>
<p><strong>unmixmaps</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected unmixing matrix</p>
</div></blockquote>
<p><strong>global_scale</strong> : float, optional</p>
<blockquote>
<div><p>Set common color scale as given percentile of all map values to use as the maximum.
<cite>None</cite> scales each plot individually (default).</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Figure to plot into. If set to <cite>None</cite>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>The figure into which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_topo">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">plot_topo</tt><big>(</big><em>axis</em>, <em>topo</em>, <em>topomap</em>, <em>crange=None</em>, <em>offset=(0</em>, <em>0)</em><big>)</big><a class="headerlink" href="#scot.plotting.plot_topo" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a topoplot in given axis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>topo</cite> is modified by the function by calling <tt class="xref py py-func docutils literal"><span class="pre">set_map()</span></tt>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : axis</p>
<blockquote>
<div><p>Axis to draw into.</p>
</div></blockquote>
<p><strong>topo</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Topoplot</span></tt></p>
<blockquote>
<div><p>This object draws the topo plot</p>
</div></blockquote>
<p><strong>topomap</strong> : array, shape = [w_pixels, h_pixels]</p>
<blockquote>
<div><p>Scalp-projected data</p>
</div></blockquote>
<p><strong>crange</strong> : [int, int], optional</p>
<blockquote>
<div><p>Range of values covered by the colormap.
If set to None, [-max(abs(topomap)), max(abs(topomap))] is substituted.</p>
</div></blockquote>
<p><strong>offset</strong> : [float, float], optional</p>
<blockquote>
<div><p>Shift the topo plot by [x,y] in axis units.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>h</strong> : image</p>
<blockquote class="last">
<div><p>Image object the map was plotted into</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.plot_whiteness">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">plot_whiteness</tt><big>(</big><em>var</em>, <em>h</em>, <em>repeats=1000</em>, <em>axis=None</em><big>)</big><a class="headerlink" href="#scot.plotting.plot_whiteness" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw distribution of the Portmanteu whiteness test.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>var</strong> : <tt class="xref py py-class docutils literal"><span class="pre">VARBase</span></tt>-like object</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object whose residuals are tested for whiteness.</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Maximum lag to include in the test.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>Number of surrogate estimates to draw under the null hypothesis.</p>
</div></blockquote>
<p><strong>axis</strong> : axis, optional</p>
<blockquote>
<div><p>Axis to draw into. By default draws into <tt class="xref py py-func docutils literal"><span class="pre">matplotlib.pyplot.gca()</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pr</strong> : float</p>
<blockquote class="last">
<div><p><em>p</em>-value of whiteness under the null hypothesis</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.prepare_topoplots">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">prepare_topoplots</tt><big>(</big><em>topo</em>, <em>values</em><big>)</big><a class="headerlink" href="#scot.plotting.prepare_topoplots" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare multiple topo maps for cached plotting.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Parameter <cite>topo</cite> is modified by the function by calling <tt class="xref py py-func docutils literal"><span class="pre">set_values()</span></tt>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>topo</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Topoplot</span></tt></p>
<blockquote>
<div><p>Scalp maps are created with this class</p>
</div></blockquote>
<p><strong>values</strong> : array, shape = [n_topos, n_channels]</p>
<blockquote>
<div><p>Channel values for each topo plot</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>topomaps</strong> : list of array</p>
<blockquote class="last">
<div><p>The map for each topo plot</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.plotting.show_plots">
<tt class="descclassname">scot.plotting.</tt><tt class="descname">show_plots</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.plotting.show_plots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-scot.utils">
<span id="scot-utils-module"></span><h2>scot.utils module<a class="headerlink" href="#module-scot.utils" title="Permalink to this headline">¶</a></h2>
<p>Utility functions</p>
<dl class="function">
<dt id="scot.utils.acm">
<tt class="descclassname">scot.utils.</tt><tt class="descname">acm</tt><big>(</big><em>x</em>, <em>l</em><big>)</big><a class="headerlink" href="#scot.utils.acm" title="Permalink to this definition">¶</a></dt>
<dd><p>Autocovariance matrix at lag l</p>
<p>This function calculates the autocovariance matrix of <cite>x</cite> at lag <cite>l</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : ndarray, shape = [n_samples, n_channels, (n_trials)]</p>
<blockquote>
<div><p>Signal data (2D or 3D for multiple trials)</p>
</div></blockquote>
<p><strong>l</strong> : int</p>
<blockquote>
<div><p>Lag</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>c</strong> : ndarray, shape = [nchannels, n_channels]</p>
<blockquote class="last">
<div><p>Autocovariance matrix of <cite>x</cite> at lag <cite>l</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.utils.cartesian">
<tt class="descclassname">scot.utils.</tt><tt class="descname">cartesian</tt><big>(</big><em>arrays</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#scot.utils.cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a cartesian product of input arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arrays</strong> : list of array-like</p>
<blockquote>
<div><p>1-D arrays to form the cartesian product of.</p>
</div></blockquote>
<p><strong>out</strong> : ndarray</p>
<blockquote>
<div><p>Array to place the cartesian product in.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>2-D array of shape (M, len(arrays)) containing cartesian products
formed of input arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p><a class="reference external" href="http://stackoverflow.com/a/1235363/3005167">http://stackoverflow.com/a/1235363/3005167</a></p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cartesian</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">array([[1, 4, 6],</span>
<span class="go">       [1, 4, 7],</span>
<span class="go">       [1, 5, 6],</span>
<span class="go">       [1, 5, 7],</span>
<span class="go">       [2, 4, 6],</span>
<span class="go">       [2, 4, 7],</span>
<span class="go">       [2, 5, 6],</span>
<span class="go">       [2, 5, 7],</span>
<span class="go">       [3, 4, 6],</span>
<span class="go">       [3, 4, 7],</span>
<span class="go">       [3, 5, 6],</span>
<span class="go">       [3, 5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scot.utils.cuthill_mckee">
<tt class="descclassname">scot.utils.</tt><tt class="descname">cuthill_mckee</tt><big>(</big><em>matrix</em><big>)</big><a class="headerlink" href="#scot.utils.cuthill_mckee" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuthill-McKee algorithm</p>
<p>Permute a symmetric binary matrix into a band matrix form with a small bandwidth.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>matrix</strong> : ndarray, dtype=bool, shape = [n, n]</p>
<blockquote>
<div><p>The matrix is internally converted to a symmetric matrix by setting each element [i,j] to True if either
[i,j] or [j,i] evaluates to true.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>order</strong> : list of int</p>
<blockquote class="last">
<div><p>Permutation intices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">cuthill_mckee</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[0, 0, 1, 1],</span>
<span class="go">       [0, 0, 0, 0],</span>
<span class="go">       [1, 0, 1, 0],</span>
<span class="go">       [1, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,:][:,</span><span class="n">p</span><span class="p">]</span>
<span class="go">array([[0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 1],</span>
<span class="go">       [0, 0, 1, 1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="scot.utils.memoize">
<em class="property">class </em><tt class="descclassname">scot.utils.</tt><tt class="descname">memoize</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#scot.utils.memoize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>cache the return value of a method</p>
<p>This class is meant to be used as a decorator of methods. The return value
from a given method invocation will be cached on the instance whose method
was invoked. All arguments passed to a method decorated with memoize must
be hashable.</p>
<p>If a memoized method is invoked directly on its class the result will not
be cached. Instead the method will be invoked like a static method:</p>
</dd></dl>

</div>
<div class="section" id="module-scot.var">
<span id="scot-var-module"></span><h2>scot.var module<a class="headerlink" href="#module-scot.var" title="Permalink to this headline">¶</a></h2>
<p>Vector autoregressive (VAR) model implementation</p>
<dl class="class">
<dt id="scot.var.VAR">
<em class="property">class </em><tt class="descclassname">scot.var.</tt><tt class="descname">VAR</tt><big>(</big><em>model_order</em>, <em>delta=0</em>, <em>xvschema=&lt;function multitrial at 0x7fde0494ef28&gt;</em><big>)</big><a class="headerlink" href="#scot.var.VAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#scot.varbase.VARBase" title="scot.varbase.VARBase"><tt class="xref py py-class docutils literal"><span class="pre">scot.varbase.VARBase</span></tt></a></p>
<p>Builtin implementation of VARBase.</p>
<p>This class provides least squares VAR model fitting with optional ridge regression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model_order</strong> : int</p>
<blockquote>
<div><p>Autoregressive model order</p>
</div></blockquote>
<p><strong>delta</strong> : float, optional</p>
<blockquote>
<div><p>Ridge penalty parameter</p>
</div></blockquote>
<p><strong>xvschema</strong> : func, optional</p>
<blockquote class="last">
<div><p>Function that creates training and test sets for cross-validation. The function takes two parameters: the current cross-validation run (int) and the numer of trials (int). It returns a tuple of two arrays: the training set and the testing set.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.var.VAR.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.var.VAR.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit VAR model to data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></a></p>
<blockquote class="last">
<div><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></a> object to facilitate method chaining (see usage example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.var.VAR.optimize">
<tt class="descname">optimize</tt><big>(</big><em>data</em>, <em>skipstep=1</em><big>)</big><a class="headerlink" href="#scot.var.VAR.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Find optimal ridge penalty with bisection search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>Continuous or segmented data set.</p>
</div></blockquote>
<p><strong>skipstep</strong> : int, optional</p>
<blockquote>
<div><p>Speed up calculation by skipping samples during cost function calculation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></a></p>
<blockquote class="last">
<div><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></a> object to facilitate method chaining (see usage example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.var.VAR.optimize_delta_bisection">
<tt class="descname">optimize_delta_bisection</tt><big>(</big><em>data</em>, <em>skipstep=1</em><big>)</big><a class="headerlink" href="#scot.var.VAR.optimize_delta_bisection" title="Permalink to this definition">¶</a></dt>
<dd><p>Find optimal ridge penalty with bisection search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>Continuous or segmented data set.</p>
</div></blockquote>
<p><strong>skipstep</strong> : int, optional</p>
<blockquote>
<div><p>Speed up calculation by skipping samples during cost function calculation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></a></p>
<blockquote class="last">
<div><p>The <a class="reference internal" href="#scot.var.VAR" title="scot.var.VAR"><tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></a> object to facilitate method chaining (see usage example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.var.VAR.optimize_order">
<tt class="descname">optimize_order</tt><big>(</big><em>data</em>, <em>min_p=1</em>, <em>max_p=None</em>, <em>skipstep=1</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#scot.var.VAR.optimize_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine optimal model order by cross-validating the mean-squared
generalization error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>min_p</strong> : int</p>
<blockquote>
<div><p>minimal model order to check</p>
</div></blockquote>
<p><strong>max_p</strong> : int</p>
<blockquote class="last">
<div><p>maximum model order to check</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-scot.varbase">
<span id="scot-varbase-module"></span><h2>scot.varbase module<a class="headerlink" href="#module-scot.varbase" title="Permalink to this headline">¶</a></h2>
<p>vector autoregressive (VAR) model</p>
<dl class="class">
<dt id="scot.varbase.Defaults">
<em class="property">class </em><tt class="descclassname">scot.varbase.</tt><tt class="descname">Defaults</tt><a class="headerlink" href="#scot.varbase.Defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<dl class="method">
<dt id="scot.varbase.Defaults.xvschema">
<tt class="descname">xvschema</tt><big>(</big><em>num_trials</em>, <em>skipstep</em><big>)</big><a class="headerlink" href="#scot.varbase.Defaults.xvschema" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-trial cross-validation schema</p>
<p>Use one trial for testing, all others for training.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_trials</strong> : int</p>
<blockquote>
<div><p>Total number of trials</p>
</div></blockquote>
<p><strong>skipstep</strong> : int</p>
<blockquote>
<div><p>only use every <cite>skipstep</cite> trial for testing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator object</p>
<blockquote class="last">
<div><p>the generator returns tuples (trainset, testset)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="scot.varbase.VARBase">
<em class="property">class </em><tt class="descclassname">scot.varbase.</tt><tt class="descname">VARBase</tt><big>(</big><em>model_order</em><big>)</big><a class="headerlink" href="#scot.varbase.VARBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Represents a vector autoregressive (VAR) model.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><cite>VARBase</cite> is an abstract class that defines the interface for VAR model implementations. Several methods must be implemented by derived classes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model_order</strong> : int</p>
<blockquote class="last">
<div><p>Autoregressive model order</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Note on the arrangement of model coefficients:
<em>b</em> is of shape [m, m*p], with sub matrices arranged as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>b_00</td>
<td>b_01</td>
<td>...</td>
<td>b_0m</td>
</tr>
<tr class="row-even"><td>b_10</td>
<td>b_11</td>
<td>...</td>
<td>b_1m</td>
</tr>
<tr class="row-odd"><td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="row-even"><td>b_m0</td>
<td>b_m1</td>
<td>...</td>
<td>b_mm</td>
</tr>
</tbody>
</table>
<p>Each sub matrix b_ij is a column vector of length p that contains the
filter coefficients from channel j (source) to channel i (sink).</p>
<dl class="method">
<dt id="scot.varbase.VARBase.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.varbase.VARBase.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the VAR model.</p>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.fit">
<tt class="descname">fit</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.varbase.VARBase.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit VAR model to data.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function must be implemented by derived classes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></p>
<blockquote class="last">
<div><p>The <tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt> object to facilitate method chaining (see usage example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.from_yw">
<tt class="descname">from_yw</tt><big>(</big><em>acms</em><big>)</big><a class="headerlink" href="#scot.varbase.VARBase.from_yw" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine VAR model from autocorrelation matrices by solving the
Yule-Walker equations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>acms</strong> : array-like, shape = [n_lags, n_channels, n_channels]</p>
<blockquote>
<div><p>acms[l] contains the autocorrelation matrix at lag l. The highest
lag must equal the model order.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : <tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt></p>
<blockquote class="last">
<div><p>The <tt class="xref py py-class docutils literal"><span class="pre">VAR</span></tt> object to facilitate method chaining (see usage example)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.is_stable">
<tt class="descname">is_stable</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.varbase.VARBase.is_stable" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the VAR model is stable.</p>
<p>This function tests stability of the VAR model as described in <a class="reference internal" href="#r4" id="id8">[R4]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : bool</p>
<blockquote class="last">
<div><p>True if the model is stable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R4]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> <ol class="last upperalpha simple" start="8">
<li>Lütkepohl, &#8220;New Introduction to Multiple Time Series Analysis&#8221;, 2005, Springer, Berlin, Germany</li>
</ol>
</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.optimize">
<tt class="descname">optimize</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.varbase.VARBase.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize model fitting hyperparameters (such as regularization penalty)</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function must be implemented by derived classes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote class="last">
<div><p>Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.predict">
<tt class="descname">predict</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#scot.varbase.VARBase.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict samples on actual data.</p>
<p>The result of this function is used for calculating the residuals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>Continuous or segmented data set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>predicted</strong> : shape = <cite>data</cite>.shape</p>
<blockquote class="last">
<div><p>Data as predicted by the VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Residuals are obtained by r = x - var.predict(x)</p>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.simulate">
<tt class="descname">simulate</tt><big>(</big><em>l</em>, <em>noisefunc=None</em><big>)</big><a class="headerlink" href="#scot.varbase.VARBase.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate vector autoregressive (VAR) model</p>
<p>This function generates data from the VAR model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l</strong> : {int, [int, int]}</p>
<blockquote>
<div><p>Specify number of samples to generate. Can be a tuple or list where l[0] is the number of samples and l[1] is the number of trials.</p>
</div></blockquote>
<p><strong>noisefunc</strong> : func, optional</p>
<blockquote>
<div><p>This function is used to create the generating noise process. If set to None Gaussian white noise with zero mean and unit variance is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>data</strong> : array, shape = [n_samples, n_channels, n_trials]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.varbase.VARBase.test_whiteness">
<tt class="descname">test_whiteness</tt><big>(</big><em>h</em>, <em>repeats=100</em>, <em>get_q=False</em><big>)</big><a class="headerlink" href="#scot.varbase.VARBase.test_whiteness" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the VAR model residuals are white (uncorrelated up to a lag of h).</p>
<p>This function calculates the Li-McLeod as Portmanteau test statistic Q to
test against the null hypothesis H0: &#8220;the residuals are white&#8221; <a class="reference internal" href="#r5" id="id10">[R5]</a>.
Surrogate data for H0 is created by sampling from random permutations of
the residuals.</p>
<p>Usually the returned p-value is compared against a pre-defined type 1 error
level of alpha=0.05 or alpha=0.01. If p&lt;=alpha, the hypothesis of white
residuals is rejected, which indicates that the VAR model does not properly
describe the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h</strong> : int</p>
<blockquote>
<div><p>Maximum lag that is included in the test statistic.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to create under the null hypothesis.</p>
</div></blockquote>
<p><strong>get_q</strong> : bool, optional</p>
<blockquote>
<div><p>Return Q statistic along with <em>p</em>-value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pr</strong> : float</p>
<blockquote>
<div><p>Probability of observing a more extreme value of Q under the assumption that H0 is true.</p>
</div></blockquote>
<p><strong>q0</strong> : list of float, optional (<cite>get_q</cite>)</p>
<blockquote>
<div><p>Individual surrogate estimates that were used for estimating the distribution of Q under H0.</p>
</div></blockquote>
<p><strong>q</strong> : float, optional (<cite>get_q</cite>)</p>
<blockquote class="last">
<div><p>Value of the Q statistic of the residuals</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>According to <a class="reference internal" href="#r6" id="id11">[R6]</a> h must satisfy h = O(n^0.5), where n is the length (time samples) of the residuals.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R5]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> <ol class="last upperalpha simple" start="8">
<li>Lütkepohl, &#8220;New Introduction to Multiple Time Series Analysis&#8221;, 2005, Springer, Berlin, Germany</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R6]</td><td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> J.R.M. Hosking, &#8220;The Multivariate Portmanteau Statistic&#8221;, 1980, J. Am. Statist. Assoc.</td></tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="scot.varbase.test_whiteness">
<tt class="descclassname">scot.varbase.</tt><tt class="descname">test_whiteness</tt><big>(</big><em>data</em>, <em>h</em>, <em>p=0</em>, <em>repeats=100</em>, <em>get_q=False</em><big>)</big><a class="headerlink" href="#scot.varbase.test_whiteness" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if signals are white (serially uncorrelated up to a lag of h).</p>
<p>This function calculates the Li-McLeod as Portmanteau test statistic Q to
test against the null hypothesis H0: &#8220;the residuals are white&#8221; <a class="reference internal" href="#r7" id="id14">[R7]</a>.
Surrogate data for H0 is created by sampling from random permutations of
the residuals.</p>
<p>Usually the returned p-value is compared against a pre-defined type 1 error
level of alpha=0.05 or alpha=0.01. If p&lt;=alpha, the hypothesis of white
residuals is rejected, which indicates that the VAR model does not properly
describe the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>signals</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>Continuous or segmented data set.</p>
</div></blockquote>
<p><strong>h</strong> : int</p>
<blockquote>
<div><p>Maximum lag that is included in the test statistic.</p>
</div></blockquote>
<p><strong>p</strong> : int, optional</p>
<blockquote>
<div><p>Model order if the <cite>signals</cite> are the residuals resulting from fitting a VAR model</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to create under the null hypothesis.</p>
</div></blockquote>
<p><strong>get_q</strong> : bool, optional</p>
<blockquote>
<div><p>Return Q statistic along with <em>p</em>-value</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pr</strong> : float</p>
<blockquote>
<div><p>Probability of observing a more extreme value of Q under the assumption that H0 is true.</p>
</div></blockquote>
<p><strong>q0</strong> : list of float, optional (<cite>get_q</cite>)</p>
<blockquote>
<div><p>Individual surrogate estimates that were used for estimating the distribution of Q under H0.</p>
</div></blockquote>
<p><strong>q</strong> : float, optional (<cite>get_q</cite>)</p>
<blockquote class="last">
<div><p>Value of the Q statistic of the residuals</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>According to <a class="reference internal" href="#r8" id="id15">[R8]</a> h must satisfy h = O(n^0.5), where n is the length (time samples) of the residuals.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R7]</td><td><em>(<a class="fn-backref" href="#id14">1</a>, <a class="fn-backref" href="#id16">2</a>)</em> <ol class="last upperalpha simple" start="8">
<li>Lütkepohl, &#8220;New Introduction to Multiple Time Series Analysis&#8221;, 2005, Springer, Berlin, Germany</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R8]</td><td><em>(<a class="fn-backref" href="#id15">1</a>, <a class="fn-backref" href="#id17">2</a>)</em> J.R.M. Hosking, &#8220;The Multivariate Portmanteau Statistic&#8221;, 1980, J. Am. Statist. Assoc.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.varica">
<span id="scot-varica-module"></span><h2>scot.varica module<a class="headerlink" href="#module-scot.varica" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="scot.varica.cspvarica">
<tt class="descclassname">scot.varica.</tt><tt class="descname">cspvarica</tt><big>(</big><em>x</em>, <em>var</em>, <em>cl</em>, <em>reducedim=inf</em>, <em>optimize_var=False</em>, <em>backend=None</em>, <em>varfit='ensemble'</em><big>)</big><a class="headerlink" href="#scot.varica.cspvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs joint VAR model fitting and ICA source separation.</p>
<p>This function implements the CSPVARICA procedure <a class="reference internal" href="#r9" id="id18">[R9]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>data set</p>
</div></blockquote>
<p><strong>var</strong> : <tt class="xref py py-class docutils literal"><span class="pre">VARBase</span></tt>-like object</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object that is used for model fitting.</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys</p>
<blockquote>
<div><p>Class labels associated with each trial.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int}, optional</p>
<blockquote>
<div><p>Number of (most discriminative) components to keep after applying the CSP.</p>
</div></blockquote>
<p><strong>optimize_var</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to call automatic optimization of the VAR fitting routine.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote>
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
<p><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a new model for each class, and
&#8216;trial&#8217; fits a new model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Result</strong> : class</p>
<blockquote class="last">
<div><p>A class with the following attributes is returned:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mixing</td>
<td>Source mixing matrix</td>
</tr>
<tr class="row-even"><td>unmixing</td>
<td>Source unmixing matrix</td>
</tr>
<tr class="row-odd"><td>residuals</td>
<td>Residuals of the VAR model(s) in source space</td>
</tr>
<tr class="row-even"><td>var_residuals</td>
<td>Residuals of the VAR model(s) in EEG space (before ICA)</td>
</tr>
<tr class="row-odd"><td>c</td>
<td>Noise covariance of the VAR model(s) in source space</td>
</tr>
<tr class="row-even"><td>b</td>
<td>VAR model coefficients (source space)</td>
</tr>
<tr class="row-odd"><td>a</td>
<td>VAR model coefficients (EEG space)</td>
</tr>
</tbody>
</table>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>CSPVARICA is performed with the following steps:
1. Dimensionality reduction with CSP
2. Fitting a VAR model tho the data
3. Decomposing the VAR model residuals with ICA
4. Correcting the VAR coefficients</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R9]</td><td><em>(<a class="fn-backref" href="#id18">1</a>, <a class="fn-backref" href="#id19">2</a>)</em> <ol class="last upperalpha simple" start="13">
<li>Billinger et al. &#8220;SCoT: A Python Toolbox for EEG Source Connectivity&#8221;, Frontiers in Neuroinformatics, 2014</li>
</ol>
</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.varica.mvarica">
<tt class="descclassname">scot.varica.</tt><tt class="descname">mvarica</tt><big>(</big><em>x</em>, <em>var</em>, <em>cl=None</em>, <em>reducedim=0.99</em>, <em>optimize_var=False</em>, <em>backend=None</em>, <em>varfit='ensemble'</em><big>)</big><a class="headerlink" href="#scot.varica.mvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs joint VAR model fitting and ICA source separation.</p>
<p>This function implements the MVARICA procedure <a class="reference internal" href="#r10" id="id20">[R10]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>data set</p>
</div></blockquote>
<p><strong>var</strong> : <tt class="xref py py-class docutils literal"><span class="pre">VARBase</span></tt>-like object</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object that is used for model fitting.</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys, optional</p>
<blockquote>
<div><p>Class labels associated with each trial.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int, float, &#8216;no_pca&#8217;}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer numer of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to &#8216;no_pca&#8217; the PCA step is skipped.</p>
</div></blockquote>
<p><strong>optimize_var</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to call automatic optimization of the VAR fitting routine.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote>
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
<p><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a new model for each class, and
&#8216;trial&#8217; fits a new model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote class="last">
<div><p>A class with the following attributes is returned:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mixing</td>
<td>Source mixing matrix</td>
</tr>
<tr class="row-even"><td>unmixing</td>
<td>Source unmixing matrix</td>
</tr>
<tr class="row-odd"><td>residuals</td>
<td>Residuals of the VAR model(s) in source space</td>
</tr>
<tr class="row-even"><td>var_residuals</td>
<td>Residuals of the VAR model(s) in EEG space (before ICA)</td>
</tr>
<tr class="row-odd"><td>c</td>
<td>Noise covariance of the VAR model(s) in source space</td>
</tr>
<tr class="row-even"><td>b</td>
<td>VAR model coefficients (source space)</td>
</tr>
<tr class="row-odd"><td>a</td>
<td>VAR model coefficients (EEG space)</td>
</tr>
</tbody>
</table>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>MVARICA is performed with the following steps:        
1. Optional dimensionality reduction with PCA
2. Fitting a VAR model tho the data
3. Decomposing the VAR model residuals with ICA
4. Correcting the VAR coefficients</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R10]</td><td><em>(<a class="fn-backref" href="#id20">1</a>, <a class="fn-backref" href="#id21">2</a>)</em> <ol class="last upperalpha simple" start="7">
<li>Gomez-Herrero et al. &#8220;Measuring directional coupling between EEG sources&#8221;, NeuroImage, 2008</li>
</ol>
</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot.xvschema">
<span id="scot-xvschema-module"></span><h2>scot.xvschema module<a class="headerlink" href="#module-scot.xvschema" title="Permalink to this headline">¶</a></h2>
<p>Cross-validation schemas</p>
<dl class="function">
<dt id="scot.xvschema.make_nfold">
<tt class="descclassname">scot.xvschema.</tt><tt class="descname">make_nfold</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#scot.xvschema.make_nfold" title="Permalink to this definition">¶</a></dt>
<dd><p>n-fold cross validation</p>
<p>Use each of n blocks for testing once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int</p>
<blockquote>
<div><p>number of blocks</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gengen</strong> : func</p>
<blockquote class="last">
<div><p>a function that returns the generator</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.xvschema.multitrial">
<tt class="descclassname">scot.xvschema.</tt><tt class="descname">multitrial</tt><big>(</big><em>num_trials</em>, <em>skipstep</em><big>)</big><a class="headerlink" href="#scot.xvschema.multitrial" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-trial cross-validation schema</p>
<p>Use one trial for testing, all others for training.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_trials</strong> : int</p>
<blockquote>
<div><p>Total number of trials</p>
</div></blockquote>
<p><strong>skipstep</strong> : int</p>
<blockquote>
<div><p>only use every <cite>skipstep</cite> trial for testing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator object</p>
<blockquote class="last">
<div><p>the generator returns tuples (trainset, testset)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.xvschema.singletrial">
<tt class="descclassname">scot.xvschema.</tt><tt class="descname">singletrial</tt><big>(</big><em>num_trials</em>, <em>skipstep</em><big>)</big><a class="headerlink" href="#scot.xvschema.singletrial" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-trial cross-validation schema</p>
<p>Use one trial for training, all others for testing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_trials</strong> : int</p>
<blockquote>
<div><p>Total number of trials</p>
</div></blockquote>
<p><strong>skipstep</strong> : int</p>
<blockquote>
<div><p>only use every <cite>skipstep</cite> trial for training</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator object</p>
<blockquote class="last">
<div><p>the generator returns tuples (trainset, testset)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scot.xvschema.splitset">
<tt class="descclassname">scot.xvschema.</tt><tt class="descname">splitset</tt><big>(</big><em>num_trials</em>, <em>skipstep</em><big>)</big><a class="headerlink" href="#scot.xvschema.splitset" title="Permalink to this definition">¶</a></dt>
<dd><p>Split-set cross validation</p>
<p>Use half the trials for training, and the other half for testing. Then
repeat the other way round.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_trials</strong> : int</p>
<blockquote>
<div><p>Total number of trials</p>
</div></blockquote>
<p><strong>skipstep</strong> : int</p>
<blockquote>
<div><p>unused</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gen</strong> : generator object</p>
<blockquote class="last">
<div><p>the generator returns tuples (trainset, testset)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-scot">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-scot" title="Permalink to this headline">¶</a></h2>
<p>SCoT: The Source Connectivity Toolbox</p>
<dl class="class">
<dt id="scot.Workspace">
<em class="property">class </em><tt class="descclassname">scot.</tt><tt class="descname">Workspace</tt><big>(</big><em>var</em>, <em>locations=None</em>, <em>reducedim=0.99</em>, <em>nfft=512</em>, <em>fs=2</em>, <em>backend=None</em><big>)</big><a class="headerlink" href="#scot.Workspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>SCoT Workspace</p>
<p>This class provides high-level functionality for source identification, connectivity estimation, and visualization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>var</strong> : {<tt class="xref py py-class docutils literal"><span class="pre">VARBase</span></tt>-like object, dict}</p>
<blockquote>
<div><p>Vector autoregressive model (VAR) object that is used for model fitting.
This can also be a dictionary that is passed as <cite>**kwargs</cite> to backend[&#8216;var&#8217;]() in order to
construct a new VAR model object.</p>
</div></blockquote>
<p><strong>locations</strong> : array_like, optional</p>
<blockquote>
<div><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</div></blockquote>
<p><strong>reducedim</strong> : {int, float, &#8216;no_pca&#8217;}, optional</p>
<blockquote>
<div><p>A number of less than 1 in interpreted as the fraction of variance that should remain in the data. All
components that describe in total less than <cite>1-reducedim</cite> of the variance are removed by the PCA step.
An integer numer of 1 or greater is interpreted as the number of components to keep after applying the PCA.
If set to &#8216;no_pca&#8217; the PCA step is skipped.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote>
<div><p>Number of frequency bins for connectivity estimation.</p>
</div></blockquote>
<p><strong>backend</strong> : dict-like, optional</p>
<blockquote class="last">
<div><p>Specify backend to use. When set to None the backend configured in config.backend is used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>unmixing_</cite></td>
<td>(array) Estimated unmixing matrix.</td>
</tr>
<tr class="row-even"><td><cite>mixing_</cite></td>
<td>(array) Estimated mixing matrix.</td>
</tr>
<tr class="row-odd"><td><cite>plot_diagonal</cite></td>
<td>(str) Configures what is plotted in the diagonal subplots. <strong>&#8216;topo&#8217;</strong> (default) plots topoplots on the diagonal, <strong>&#8216;S&#8217;</strong> plots the spectral density of each component, and <strong>&#8216;fill&#8217;</strong> plots connectivity on the diagonal.</td>
</tr>
<tr class="row-even"><td><cite>plot_outside_topo</cite></td>
<td>(bool) Whether to place topoplots in the left column and top row.</td>
</tr>
<tr class="row-odd"><td><cite>plot_f_range</cite></td>
<td>((int, int)) Lower and upper frequency limits for plotting. Defaults to [0, fs/2].</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.Workspace.compare_conditions">
<tt class="descname">compare_conditions</tt><big>(</big><em>labels1</em>, <em>labels2</em>, <em>measure_name</em>, <em>alpha=0.01</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>plot=False</em><big>)</big><a class="headerlink" href="#scot.Workspace.compare_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for significant difference in connectivity of two sets of class labels.</p>
<p>Connectivity estimates are obtained by bootstrapping. Correction for multiple testing is performed by
controlling the false discovery rate (FDR).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels1, labels2</strong> : list of class labels</p>
<blockquote>
<div><p>The two sets of class labels to compare. Each set may contain more than one label.</p>
</div></blockquote>
<p><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt></a> for supported measures.</p>
</div></blockquote>
<p><strong>alpha</strong> : float, optional</p>
<blockquote>
<div><p>Maximum allowed FDR. The ratio of falsely detected significant differences is guaranteed to be less than
<cite>alpha</cite>.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : array, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Uncorrected p-values.</p>
</div></blockquote>
<p><strong>s</strong> : array, dtype=bool, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>FDR corrected significance. True means the difference is significant in this location.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.do_cspvarica">
<tt class="descname">do_cspvarica</tt><big>(</big><em>varfit='ensemble'</em><big>)</big><a class="headerlink" href="#scot.Workspace.do_cspvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform CSPVARICA</p>
<p>Perform CSPVARICA source decomposition and VAR model fitting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a different model for each class, and
&#8216;trial&#8217; fits a different model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <tt class="xref py py-func docutils literal"><span class="pre">cspvarica()</span></tt> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-func docutils literal"><span class="pre">cspvarica()</span></tt></dt>
<dd>CSPVARICA implementation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.do_ica">
<tt class="descname">do_ica</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Workspace.do_ica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform ICA</p>
<p>Perform plain ICA source decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <a class="reference internal" href="#module-scot.plainica" title="scot.plainica"><tt class="xref py py-func docutils literal"><span class="pre">plainica()</span></tt></a> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.do_mvarica">
<tt class="descname">do_mvarica</tt><big>(</big><em>varfit='ensemble'</em><big>)</big><a class="headerlink" href="#scot.Workspace.do_mvarica" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform MVARICA</p>
<p>Perform MVARICA source decomposition and VAR model fitting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>varfit</strong> : string</p>
<blockquote>
<div><p>Determines how to calculate the residuals for source decomposition.
&#8216;ensemble&#8217; (default) fits one model to the whole data set,
&#8216;class&#8217; fits a different model for each class, and
&#8216;trial&#8217; fits a different model for each individual trial.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : class</p>
<blockquote>
<div><p>see <tt class="xref py py-func docutils literal"><span class="pre">mvarica()</span></tt> for a description of the return value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-func docutils literal"><span class="pre">mvarica()</span></tt></dt>
<dd>MVARICA implementation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.fit_var">
<tt class="descname">fit_var</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Workspace.fit_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a var model to the source activations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain source activations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.get_bootstrap_connectivity">
<tt class="descname">get_bootstrap_connectivity</tt><big>(</big><em>measure_names</em>, <em>repeats=100</em>, <em>num_samples=None</em>, <em>plot=False</em><big>)</big><a class="headerlink" href="#scot.Workspace.get_bootstrap_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bootstrap estimates of spectral connectivity measures.</p>
<p>Bootstrapping is performed on trial level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_names</strong> : {str, list of str}</p>
<blockquote>
<div><p>Name(s) of the connectivity measure(s) to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt></a> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many bootstrap estimates to take.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>How many samples to take for each bootstrap estimates. Defaults to the same number of trials as present in
the data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each bootstrap estimate. If <cite>measure_names</cite> is a list of strings a
dictionary is returned, where each key is the name of the measure, and the corresponding values are
ndarrays of shape [<cite>repeats</cite>, n_channels, n_channels, nfft].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.bootstrap_connectivity" title="scot.connectivity_statistics.bootstrap_connectivity"><tt class="xref py py-func docutils literal"><span class="pre">scot.connectivity_statistics.bootstrap_connectivity()</span></tt></a></dt>
<dd>Calculates bootstrap connectivity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.get_connectivity">
<tt class="descname">get_connectivity</tt><big>(</big><em>measure_name</em>, <em>plot=False</em><big>)</big><a class="headerlink" href="#scot.Workspace.get_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt></a> for supported measures.</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [n_channels, n_channels, nfft]</p>
<blockquote>
<div><p>Values of the connectivity measure.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object</p>
<blockquote>
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain a fitted VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.get_surrogate_connectivity">
<tt class="descname">get_surrogate_connectivity</tt><big>(</big><em>measure_name</em>, <em>repeats=100</em>, <em>plot=False</em><big>)</big><a class="headerlink" href="#scot.Workspace.get_surrogate_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt></a> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>measure</strong> : array, shape = [<cite>repeats</cite>, n_channels, n_channels, nfft]</p>
<blockquote class="last">
<div><p>Values of the connectivity measure for each surrogate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#scot.connectivity_statistics.surrogate_connectivity" title="scot.connectivity_statistics.surrogate_connectivity"><tt class="xref py py-func docutils literal"><span class="pre">scot.connectivity_statistics.surrogate_connectivity()</span></tt></a></dt>
<dd>Calculates surrogate connectivity</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.get_tf_connectivity">
<tt class="descname">get_tf_connectivity</tt><big>(</big><em>measure_name</em>, <em>winlen</em>, <em>winstep</em>, <em>plot=False</em>, <em>crange='default'</em><big>)</big><a class="headerlink" href="#scot.Workspace.get_tf_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate estimate of time-varying connectivity.</p>
<p>Connectivity is estimated in a sliding window approach on the current data set. The window is stepped
<cite>n_steps</cite> = (<cite>n_samples</cite> - <cite>winlen</cite>) // <cite>winstep</cite> times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt></a> for supported measures.</p>
</div></blockquote>
<p><strong>winlen</strong> : int</p>
<blockquote>
<div><p>Length of the sliding window (in samples).</p>
</div></blockquote>
<p><strong>winstep</strong> : int</p>
<blockquote>
<div><p>Step size for sliding window (in samples).</p>
</div></blockquote>
<p><strong>plot</strong> : {False, None, Figure object}, optional</p>
<blockquote>
<div><p>Whether and where to plot the connectivity. If set to <strong>False</strong>, nothing is plotted. Otherwise set to the
Figure object. If set to <strong>None</strong>, a new figure is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array, shape = [n_channels, n_channels, nfft, n_steps]</p>
<blockquote>
<div><p>Values of the connectivity measure.</p>
</div></blockquote>
<p><strong>fig</strong> : Figure object, optional</p>
<blockquote>
<div><p>Instance of the figure in which was plotted. This is only returned if <cite>plot</cite> is not <strong>False</strong>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain a fitted VAR model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.optimize_var">
<tt class="descname">optimize_var</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Workspace.optimize_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the var model&#8217;s hyperparameters (such as regularization).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain source activations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.plot_connectivity_surrogate">
<tt class="descname">plot_connectivity_surrogate</tt><big>(</big><em>measure_name</em>, <em>repeats=100</em>, <em>fig=None</em><big>)</big><a class="headerlink" href="#scot.Workspace.plot_connectivity_surrogate" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot spectral connectivity measure under the assumption of no actual connectivity.</p>
<p>Repeatedly samples connectivity from phase-randomized data. This provides estimates of the connectivity
distribution if there was no causal structure in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>measure_name</strong> : str</p>
<blockquote>
<div><p>Name of the connectivity measure to calculate. See <a class="reference internal" href="#scot.Connectivity" title="scot.Connectivity"><tt class="xref py py-class docutils literal"><span class="pre">Connectivity</span></tt></a> for supported measures.</p>
</div></blockquote>
<p><strong>repeats</strong> : int, optional</p>
<blockquote>
<div><p>How many surrogate samples to take.</p>
</div></blockquote>
<p><strong>fig</strong> : {None, Figure object}, optional</p>
<blockquote>
<div><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.plot_connectivity_topos">
<tt class="descname">plot_connectivity_topos</tt><big>(</big><em>fig=None</em><big>)</big><a class="headerlink" href="#scot.Workspace.plot_connectivity_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot scalp projections of the sources.</p>
<p>This function only plots the topos. Use in combination with connectivity plotting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fig</strong> : {None, Figure object}, optional</p>
<blockquote>
<div><p>Where to plot the topos. f set to <strong>None</strong>, a new figure is created. Otherwise plot into the provided
figure object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Figure object</p>
<blockquote class="last">
<div><p>Instance of the figure in which was plotted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.plot_source_topos">
<tt class="descname">plot_source_topos</tt><big>(</big><em>common_scale=None</em><big>)</big><a class="headerlink" href="#scot.Workspace.plot_source_topos" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topography of the Source decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>common_scale</strong> : float, optional</p>
<blockquote class="last">
<div><p>If set to None, each topoplot&#8217;s color axis is scaled individually. Otherwise specifies the percentile
(1-99) of values in all plot. This value is taken as the maximum color scale.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="scot.Workspace.plotting">
<tt class="descname">plotting</tt><a class="headerlink" href="#scot.Workspace.plotting" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="scot.Workspace.remove_sources">
<tt class="descname">remove_sources</tt><big>(</big><em>sources</em><big>)</big><a class="headerlink" href="#scot.Workspace.remove_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sources from the decomposition.</p>
<p>This function removes sources from the decomposition. Doing so invalidates currently fitted VAR models and
connectivity estimates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sources</strong> : {slice, int, array of ints}</p>
<blockquote>
<div><p>Indices of components to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>If the <a class="reference internal" href="#scot.Workspace" title="scot.Workspace"><tt class="xref py py-class docutils literal"><span class="pre">Workspace</span></tt></a> instance does not contain a source decomposition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.set_data">
<tt class="descname">set_data</tt><big>(</big><em>data</em>, <em>cl=None</em>, <em>time_offset=0</em><big>)</big><a class="headerlink" href="#scot.Workspace.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign data to the workspace.</p>
<p>This function assigns a new data set to the workspace. Doing so invalidates currently fitted VAR models,
connectivity estimates, and activations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like, shape = [n_samples, n_channels, n_trials] or [n_samples, n_channels]</p>
<blockquote>
<div><p>EEG data set</p>
</div></blockquote>
<p><strong>cl</strong> : list of valid dict keys</p>
<blockquote>
<div><p>Class labels associated with each trial.</p>
</div></blockquote>
<p><strong>time_offset</strong> : float, optional</p>
<blockquote class="last">
<div><p>Trial starting time; used for labelling the x-axis of time/frequency plots.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.set_locations">
<tt class="descname">set_locations</tt><big>(</big><em>locations</em><big>)</big><a class="headerlink" href="#scot.Workspace.set_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sensor locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>locations</strong> : array_like</p>
<blockquote class="last">
<div><p>3D Electrode locations. Each row holds the x, y, and z coordinates of an electrode.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.set_premixing">
<tt class="descname">set_premixing</tt><big>(</big><em>premixing</em><big>)</big><a class="headerlink" href="#scot.Workspace.set_premixing" title="Permalink to this definition">¶</a></dt>
<dd><p>Set premixing matrix.</p>
<p>The premixing matrix maps data to physical channels. If the data is actual channel data,
the premixing matrix can be set to identity. Use this functionality if the data was pre-
transformed with e.g. PCA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>premixing</strong> : array_like, shape = [n_signals, n_channels]</p>
<blockquote class="last">
<div><p>Matrix that maps data signals to physical channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.set_used_labels">
<tt class="descname">set_used_labels</tt><big>(</big><em>labels</em><big>)</big><a class="headerlink" href="#scot.Workspace.set_used_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify which trials to use in subsequent analysis steps.</p>
<p>This function masks trials based on their class labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : list of class labels</p>
<blockquote class="last">
<div><p>Marks all trials that have a label that is in the <cite>labels</cite> list for further processing.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scot.Workspace.show_plots">
<tt class="descname">show_plots</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Workspace.show_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Show current plots.</p>
<p>This is only a convenience wrapper around <tt class="xref py py-func docutils literal"><span class="pre">matplotlib.pyplot.show_plots()</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="scot.Connectivity">
<em class="property">class </em><tt class="descclassname">scot.</tt><tt class="descname">Connectivity</tt><big>(</big><em>b</em>, <em>c=None</em>, <em>nfft=512</em><big>)</big><a class="headerlink" href="#scot.Connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Calculation of connectivity measures</p>
<p>This class calculates various spectral connectivity measures from a vector autoregressive (VAR) model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>b</strong> : ndarray, shape = [n_channels, n_channels*model_order]</p>
<blockquote>
<div><p>VAR model coefficients. See <a class="reference internal" href="../../var.html#var-model-coefficients"><em>On the arrangement of VAR model coefficients</em></a> for details about the arrangement of coefficients.</p>
</div></blockquote>
<p><strong>c</strong> : ndarray, shape = [n_channels, n_channels], optional</p>
<blockquote>
<div><p>Covariance matrix of the driving noise process. Identity matrix is used if set to None.</p>
</div></blockquote>
<p><strong>nfft</strong> : int, optional</p>
<blockquote class="last">
<div><p>Number of frequency bins to calculate. Note that these points cover the range between 0 and half the
sampling rate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Connectivity measures are returned by member functions that take no arguments and return a matrix of
shape [m,m,nfft]. The first dimension is the sink, the second dimension is the source, and the third dimension is
the frequency.</p>
<p>A summary of most supported measures can be found in <a class="reference internal" href="#r11" id="id22">[R11]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R11]</td><td><em>(<a class="fn-backref" href="#id22">1</a>, <a class="fn-backref" href="#id23">2</a>)</em> M. Billinger et al, “Single-trial connectivity estimation for classification of motor imagery data”,
<em>J. Neural Eng.</em> 10, 2013.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.A" title="scot.Connectivity.A"><tt class="xref py py-func docutils literal"><span class="pre">A()</span></tt></a></td>
<td>Spectral representation of the VAR coefficients</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.H" title="scot.Connectivity.H"><tt class="xref py py-func docutils literal"><span class="pre">H()</span></tt></a></td>
<td>Transfer function that turns the innovation process into the VAR process</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.S" title="scot.Connectivity.S"><tt class="xref py py-func docutils literal"><span class="pre">S()</span></tt></a></td>
<td>Cross spectral density</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.logS" title="scot.Connectivity.logS"><tt class="xref py py-func docutils literal"><span class="pre">logS()</span></tt></a></td>
<td>Logarithm of the cross spectral density (S), for convenience.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.G" title="scot.Connectivity.G"><tt class="xref py py-func docutils literal"><span class="pre">G()</span></tt></a></td>
<td>Inverse cross spectral density</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.logG" title="scot.Connectivity.logG"><tt class="xref py py-func docutils literal"><span class="pre">logG()</span></tt></a></td>
<td>Logarithm of the inverse cross spectral density</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.PHI" title="scot.Connectivity.PHI"><tt class="xref py py-func docutils literal"><span class="pre">PHI()</span></tt></a></td>
<td>Phase angle</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.COH" title="scot.Connectivity.COH"><tt class="xref py py-func docutils literal"><span class="pre">COH()</span></tt></a></td>
<td>Coherence</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.pCOH" title="scot.Connectivity.pCOH"><tt class="xref py py-func docutils literal"><span class="pre">pCOH()</span></tt></a></td>
<td>Partial coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.PDC" title="scot.Connectivity.PDC"><tt class="xref py py-func docutils literal"><span class="pre">PDC()</span></tt></a></td>
<td>Partial directed coherence</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.ffPDC" title="scot.Connectivity.ffPDC"><tt class="xref py py-func docutils literal"><span class="pre">ffPDC()</span></tt></a></td>
<td>Full frequency partial directed coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.PDCF" title="scot.Connectivity.PDCF"><tt class="xref py py-func docutils literal"><span class="pre">PDCF()</span></tt></a></td>
<td>PDC factor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.GPDC" title="scot.Connectivity.GPDC"><tt class="xref py py-func docutils literal"><span class="pre">GPDC()</span></tt></a></td>
<td>Generalized partial directed coherence</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.DTF" title="scot.Connectivity.DTF"><tt class="xref py py-func docutils literal"><span class="pre">DTF()</span></tt></a></td>
<td>Directed transfer function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.ffDTF" title="scot.Connectivity.ffDTF"><tt class="xref py py-func docutils literal"><span class="pre">ffDTF()</span></tt></a></td>
<td>Full frequency directed transfer function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scot.Connectivity.dDTF" title="scot.Connectivity.dDTF"><tt class="xref py py-func docutils literal"><span class="pre">dDTF()</span></tt></a></td>
<td>Direct directed transfer function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scot.Connectivity.GDTF" title="scot.Connectivity.GDTF"><tt class="xref py py-func docutils literal"><span class="pre">GDTF()</span></tt></a></td>
<td>Generalized directed transfer function</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scot.Connectivity.A">
<tt class="descname">A</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectral VAR coefficients</p>
<div class="math">
\[\mathbf{A}(f) = \mathbf{I} - \sum_{k=1}^{p} \mathbf{a}^{(k)} \mathrm{e}^{-2\pi f}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.COH">
<tt class="descname">COH</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.COH" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherence</p>
<div class="math">
\[\mathrm{COH}_{ij}(f) = \frac{S_{ij}(f)}{\sqrt{S_{ii}(f) S_{jj}(f)}}\]</div>
<p class="rubric">References</p>
<p>P. L. Nunez, R. Srinivasan, A. F. Westdorp, R. S. Wijesinghe, D. M. Tucker,
R. B. Silverstein, P. J. Cadusch. EEG coherency: I: statistics, reference electrode,
volume conduction, Laplacians, cortical imaging, and interpretation at multiple scales.
Electroenceph. Clin. Neurophysiol. 103(5): 499-515, 1997.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.Cinv">
<tt class="descname">Cinv</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.Cinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of the noise covariance</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.DTF">
<tt class="descname">DTF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.DTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Directed transfer function</p>
<div class="math">
\[\mathrm{DTF}_{ij}(f) = \frac{H_{ij}(f)}{\sqrt{H_{i:}(f) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>M. J. Kaminski, K. J. Blinowska. A new method of the description of the information flow
in the brain structures. Biol. Cybernetics 65(3): 203-210, 1991.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.G">
<tt class="descname">G</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.G" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse cross spectral density</p>
<div class="math">
\[\mathbf{G}(f) = \mathbf{A}(f) \mathbf{C}^{-1} \mathbf{A}'(f)\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.GDTF">
<tt class="descname">GDTF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.GDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized directed transfer function</p>
<div class="math">
\[\mathrm{GPDC}_{ij}(f) = \frac{\sigma_j |H_{ij}(f)|}
{\sqrt{H_{i:}(f) \mathrm{diag}(\mathbf{C}) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring Connectivity in Linear Multivariate Processes:
Definitions, Interpretation, and Practical Analysis. Comput. Math. Meth. Med. 2012:140513, 2012.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.GPDC">
<tt class="descname">GPDC</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.GPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized partial directed coherence</p>
<div class="math">
\[\mathrm{GPDC}_{ij}(f) = \frac{|A_{ij}(f)|}
{\sigma_i \sqrt{A_{:j}'(f) \mathrm{diag}(\mathbf{C})^{-1} A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. Faes, S. Erla, G. Nollo. Measuring Connectivity in Linear Multivariate Processes:
Definitions, Interpretation, and Practical Analysis. Comput. Math. Meth. Med. 2012:140513, 2012.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.H">
<tt class="descname">H</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.H" title="Permalink to this definition">¶</a></dt>
<dd><p>VAR transfer function</p>
<div class="math">
\[\mathbf{H}(f) = \mathbf{A}(f)^{-1}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.PDC">
<tt class="descname">PDC</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.PDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial directed coherence</p>
<div class="math">
\[\mathrm{PDC}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{A_{:j}'(f) A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept in neural structure
determination. Biol. Cybernetics 84(6):463-474, 2001.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.PDCF">
<tt class="descname">PDCF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.PDCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial directed coherence factor</p>
<div class="math">
\[\mathrm{PDCF}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{A_{:j}'(f) \mathbf{C}^{-1} A_{:j}(f)}}\]</div>
<p class="rubric">References</p>
<p>L. A. Baccalá, K. Sameshima. Partial directed coherence: a new concept in neural structure
determination. Biol. Cybernetics 84(6):463-474, 2001.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.PHI">
<tt class="descname">PHI</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.PHI" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase angle</p>
<p>Returns the phase angle of complex <a class="reference internal" href="#scot.Connectivity.S" title="scot.Connectivity.S"><tt class="xref py py-func docutils literal"><span class="pre">S()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.S">
<tt class="descname">S</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.S" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross spectral density</p>
<div class="math">
\[\mathbf{S}(f) = \mathbf{H}(f) \mathbf{C} \mathbf{H}'(f)\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.absS">
<tt class="descname">absS</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.absS" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute cross spectral density</p>
<div class="math">
\[\mathrm{absS}(f) = | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.dDTF">
<tt class="descname">dDTF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.dDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8221; Direct&#8221; directed transfer function</p>
<div class="math">
\[\mathrm{dDTF}_{ij}(f) = |\mathrm{pCOH}_{ij}(f)| \mathrm{ffDTF}_{ij}(f)\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki. Determination of
information flow direction among brain structures by a modified directed transfer 
function (dDTF) method. J. Neurosci. Meth. 125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.ffDTF">
<tt class="descname">ffDTF</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.ffDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Full frequency directed transfer function</p>
<div class="math">
\[\mathrm{ffDTF}_{ij}(f) = \frac{H_{ij}(f)}{\sqrt{\sum_f H_{i:}(f) H_{i:}'(f)}}\]</div>
<p class="rubric">References</p>
<p>A. Korzeniewska, M. Mańczak, M. Kaminski, K. J. Blinowska, S. Kasicki. Determination of
information flow direction among brain structures by a modified directed transfer 
function (dDTF) method. J. Neurosci. Meth. 125(1-2): 195-207, 2003.</p>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.ffPDC">
<tt class="descname">ffPDC</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.ffPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Full frequency partial directed coherence</p>
<div class="math">
\[\mathrm{ffPDC}_{ij}(f) = \frac{A_{ij}(f)}{\sqrt{\sum_f A_{:j}'(f) A_{:j}(f)}}\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.logG">
<tt class="descname">logG</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.logG" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithmic inverse cross spectral density</p>
<div class="math">
\[\mathrm{logG}(f) = \log | \mathbf{G}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.logS">
<tt class="descname">logS</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.logS" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithmic cross spectral density</p>
<div class="math">
\[\mathrm{logS}(f) = \log | \mathbf{S}(f) |\]</div>
</dd></dl>

<dl class="method">
<dt id="scot.Connectivity.pCOH">
<tt class="descname">pCOH</tt><big>(</big><big>)</big><a class="headerlink" href="#scot.Connectivity.pCOH" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial coherence</p>
<div class="math">
\[\mathrm{pCOH}_{ij}(f) = \frac{G_{ij}(f)}{\sqrt{G_{ii}(f) G_{jj}(f)}}\]</div>
<p class="rubric">References</p>
<p>P. J. Franaszczuk, K. J. Blinowska, M. Kowalczyk. The application of parametric multichannel
spectral estimates in the study of electrical brain activity. Biol. Cybernetics 51(4): 239-247, 1985.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">scot package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-scot.backend_builtin">scot.backend_builtin module</a></li>
<li><a class="reference internal" href="#module-scot.backend_sklearn">scot.backend_sklearn module</a></li>
<li><a class="reference internal" href="#module-scot.binica">scot.binica module</a></li>
<li><a class="reference internal" href="#module-scot.config">scot.config module</a></li>
<li><a class="reference internal" href="#module-scot.connectivity">scot.connectivity module</a></li>
<li><a class="reference internal" href="#module-scot.connectivity_statistics">scot.connectivity_statistics module</a></li>
<li><a class="reference internal" href="#module-scot.csp">scot.csp module</a></li>
<li><a class="reference internal" href="#module-scot.datatools">scot.datatools module</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-scot.matfiles">scot.matfiles module</a><ul>
<li><a class="reference internal" href="#id6">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-scot.ooapi">scot.ooapi module</a><ul>
<li><a class="reference internal" href="#id7">Summary</a></li>
<li><a class="reference internal" href="#extended-summary">Extended Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-scot.pca">scot.pca module</a></li>
<li><a class="reference internal" href="#module-scot.plainica">scot.plainica module</a></li>
<li><a class="reference internal" href="#module-scot.plotting">scot.plotting module</a></li>
<li><a class="reference internal" href="#module-scot.utils">scot.utils module</a></li>
<li><a class="reference internal" href="#module-scot.var">scot.var module</a></li>
<li><a class="reference internal" href="#module-scot.varbase">scot.varbase module</a></li>
<li><a class="reference internal" href="#module-scot.varica">scot.varica module</a></li>
<li><a class="reference internal" href="#module-scot.xvschema">scot.xvschema module</a></li>
<li><a class="reference internal" href="#module-scot">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">scot</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scot.eegtopo.html"
                        title="next chapter">scot.eegtopo package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/api/scot/scot.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scot.eegtopo.html" title="scot.eegtopo package"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="scot"
             >previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>

          <li><a href="../../api_reference.html" >API Reference</a> &raquo;</li>
          <li><a href="modules.html" >scot</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Martin Billinger.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>